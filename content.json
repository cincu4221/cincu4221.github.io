{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 안녕하세요~!","link":"/2021/10/28/hello-world/"},{"title":"","text":"Hexo로 깃허브 블로그 만들기Hexo란?Hexo는 Node.js기반의 정적 블로그 프레임워크 입니다. Markdown으로 문서를 작성하고 빌드시 정적 HTML이 생기고이것을 GitHub pages에 배포 하여 블로그를 관리 합니다. 설치환경 Git Node.js 파이참(PyCharm) GitHub 계정 설치환경 확인 아래 코드로 Node.js 설치를 확인해봅니다.1$ node -v 아래 코드로 Git 설치를 확인합니다.1$ git --version npm을 통해 hexo를 전역으로 설치합니다.1$ npm install -g hexo-cli GitHub 블로그 만들기먼저 원하는 디렉토리로 이동하여 헥소 블로그 디렉토리를 만들어줍니다.(이 포스팅에서는 myblog)1$ hexo init myblog 생성된 디렉토리를 우클릭 한 뒤‘Open Folder as PyCharm Community Edition Project‘를 클릭해 파이참으로 열어줍니다. 실행된 파이참의 좌측 아래에서 터미널 메뉴를 선택하고 사진과같이 Git Bash를 클릭해주면파이참에서 Git을 사용할 수 있게 됩니다. 이후 Git에서 다음 명령어들을 입력해줍니다 123$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save 이제 GitHub 접속하고 우측 상단의 아이콘 클릭 후 ‘Your repositories‘에 들어갑니다.Repository name 란에 만들었던 디렉토리와 같은 이름인 ‘myblog’를 넣은 후 아무것도 건드리지 않고 아래의 ‘Create repository’ 버튼을 눌러줍니다. 다시 파이참으로 돌아와서 아래의 Git 명령어들을 입력해줍니다. 1234567echo &quot;# myblog&quot; &gt;&gt; README.mdgit initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/cincu4221/myblog.gitgit push -u origin main GitHub에서 ‘myblog‘ 리포지토리를 만들때와 이름만 다르게 ‘사용자계정명.github.it‘ 으로 바꾸어서 리포지토리를 하나 더 생성해 줍니다. 파이참의 작업영역에서 _config.yml 파일을 열어서 수정해줍니다. 블로그 정보 설정1234title: blog titlesubtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그의 URL정보 설정1234url: https://Username.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 설정12345# Deploymentdeploy: type: git repo: https://github.com/Username/Username.github.io.git branch: main 위의 코드에서 Username으로 되어있는것은 꼭 사용자의 GitHub계정명으로 바꿔주셔야 합니다. 파이참의 Git Bash(Terminal)에 다음 코드들을 입력합니다. 12$ hexo generate$ hexo server 이후 나오는 localhost:4000에서 화면이 뜨는지 확인합니다. 다음 코드를 입력해 최종적으로 배포를 진행합니다. 1$ hexo deploy 배포가 완료되면 브라우저에서 [USERNAME.github.io]로 접속해 정상적으로 배포되었는지 확인합니다. * 참고 : https://dschloe.github.io/settings/hexo_blog/","link":"/2021/10/28/make_github_blog/"},{"title":"","text":"윈도우에서 Git 설치하기다운로드 먼저 Git홈페이지에서 Download for Windows을 클릭해 자신의 윈도우 버전에 맞는 Git을 다운로드 해준다. Git 홈페이지 윈도우 버전에 맞는 Git이 알아서 다운로드된다. 설치 설치파일을 실행시키면 항상 보는 약관페이지가 나온다. Next를 눌러 넘어간다. 설치경로를 정해주고 Next 설치할 Component들을 선택하는 창이다. 기본으로 선택되어 있는것만 선택하고 Next를 눌러 넘어간다. 시작메뉴에 폴더를 생성하는 창이다. 폴더를 추가하고 싶지 않다면 아래에 있는 Don't create a Start Menu folder 체크박스를 클릭하고 Next를 눌러준다. Git의 기본 에디터를 설정하는 창이다. 이번에도 기본으로 선택되어있는 항목을 고르고 Next를 눌러 넘어간다. 선택되어있는 Let Git decide를 고르고 Next를 누른다. 환경변수 옵션 설정이다. Git from the Command line and also from 3rd-party software를 선택하고 Next Use bundled OpenSSH를 선택한채로 Next를 누른다. https 전송시 인증서 선택. Use the OpenSSL library을 선택 후 Next Checkout Windows style, commit Unix-style line endings을 선택하고 Next Git Bash 터미널의 형식. Use MinTTY를 선택하고 넘어갑니다. Git pull 작업방식. Default로 설정해주고 Next를 누른다. Credential Helper 사용에 대한 선택. Git Credential Manager Core선택 후 Next 기타 실행옵션. 필자는 Enable file system caching만 체크 후 넘어갔다. 모든 옵션에 체크를 완료하고 설치가 진행되는 모습. 설치가 완료되면 위와 같은 창이 뜬다. 설치 확인 자 이제 설치가 잘 되었는지 확인할 차례이다.윈도우에 cmd를 검색해 명령 프롬프트를 실행한다.아무것도 하지않은채로 git 을 입력한다. 입력하면 위 사진처럼 Git의 명령어가 나오면서 설치가 완료된걸 확인 할 수 있다.","link":"/2021/10/28/setting_Git/"},{"title":"","text":"Colaboratory란? 줄여서 ‘Colab’이라고도 하는 Colaboratory를 사용하면 브라우저에서 Python을 작성하고 실행할 수 있습니다. Colab은 다음과 같은 이점을 자랑합니다. 구성이 필요하지 않음 GPU 무료 액세스 간편한 공유 학생이든, 데이터 과학자든, AI 연구원이든 Colab으로 업무를 더욱 간편하게 처리할 수 있습니다. Colab 소개 영상에서 자세한 내용을 확인하거나 아래에서 시작해 보세요. 시작하기지금 읽고 계신 문서는 정적 웹페이지가 아니라 코드를 작성하고 실행할 수 있는 대화형 환경인 Colab 메모장입니다. 예를 들어 다음은 값을 계산하여 변수로 저장하고 결과를 출력하는 간단한 Python 스크립트가 포함된 코드 셀입니다. 12seconds_in_a_day = 24 * 60 * 60seconds_in_a_day 86400 위 셀의 코드를 실행하려면 셀을 클릭하여 선택한 후 코드 왼쪽의 실행 버튼을 누르거나 단축키 ‘Command/Ctrl+Enter’를 사용하세요. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 특정 셀에서 정의한 변수를 나중에 다른 셀에서 사용할 수 있습니다. 12seconds_in_a_week = 7 * seconds_in_a_dayseconds_in_a_week 604800 Colab 메모장을 사용하면 실행 코드와 서식 있는 텍스트를 이미지, HTML, LaTeX 등과 함께 하나의 문서로 통합할 수 있습니다. Colab 메모장을 만들면 Google Drive 계정에 저장됩니다. Colab 메모장을 간편하게 공유하여 동료나 친구들이 댓글을 달거나 수정하도록 할 수 있습니다. 자세히 알아보려면 Colab 개요를 참조하세요. 새 Colab 메모장을 만들려면 위의 파일 메뉴를 사용하거나 다음 링크로 이동하세요. 새 Colab 메모장 만들기 Colab 메모장은 Colab에서 호스팅하는 Jupyter 메모장입니다. Jupyter 프로젝트에 관해 자세히 알아보려면 jupyter.org를 참조하세요. 데이터 과학Colab을 통해 인기 있는 Python 라이브러리를 최대한 활용하여 데이터를 분석하고 시각화할 수 있습니다. 아래 코드 셀에서는 Numpy를 사용하여 임의의 데이터를 생성하고 매트플롯립으로 이를 시각화합니다. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 1234567891011import numpy as npfrom matplotlib import pyplot as pltys = 200 + np.random.randn(100)x = [x for x in range(len(ys))]plt.plot(x, ys, '-')plt.fill_between(x, ys, 195, where=(ys &gt; 195), facecolor='g', alpha=0.6)plt.title(&quot;Sample Visualization&quot;)plt.show() Google Drive 계정에서 스프레드시트를 비롯한 데이터를 Colab 메모장으로 가져오거나 GitHub 등의 여러 다른 소스에서 데이터를 가져올 수 있습니다. Colab을 데이터 과학에 활용하는 방법과 데이터 가져오기에 관해 자세히 알아보려면 데이터 사용하기 아래 링크를 참조하세요. 머신러닝Colab을 사용하면 코드 몇 줄만으로 이미지 데이터세트를 가져오고, 이 데이터세트로 이미지 분류기를 학습시키며, 모델을 평가할 수 있습니다. Colab 메모장은 Google 클라우드 서버에서 코드를 실행하므로 사용 중인 컴퓨터의 성능과 관계없이 GPU 및 TPU를 포함한 Google 하드웨어의 성능을 활용할 수 있습니다. 브라우저만 있으면 사용 가능합니다. Colab은 다음과 같은 분야의 머신러닝 커뮤니티에서 널리 쓰이고 있습니다. TensorFlow 시작하기 신경망 개발 및 학습시키기 TPU로 실험하기 AI 연구 보급하기 튜토리얼 만들기 머신러닝 적용 사례를 보여 주는 Colab 메모장 샘플을 확인하려면 아래 머신러닝 예시를 참조하세요. 추가 리소스Colab에서 메모장 사용하기 Colaboratory 개요 Markdown 가이드 라이브러리 가져오기 및 종속 항목 설치하기 GitHub에서 노트 저장 및 로드하기 대화형 양식 대화형 위젯 Colab의 TensorFlow 2 데이터로 작업하기 데이터 로드: 드라이브, 스프레드시트, Google Cloud Storage 차트: 데이터 시각화하기 BigQuery 시작하기 머신러닝 단기집중과정다음은 Google 온라인 머신러닝 과정에서 가져온 일부 메모장입니다. 전체 과정 웹사이트에서 자세한 내용을 확인하세요. Pandas DataFrame 소개 합성 데이터를 사용하는 tf.keras 선형 회귀 가속 하드웨어 사용하기 GPU를 사용한 TensorFlow TPU를 사용한 TensorFlow 머신러닝 예시Colaboratory 덕분에 가능해진 대화형 머신러닝 분석의 예시를 자세히 살펴보려면 TensorFlow Hub의 모델을 사용한 이 튜토리얼을 살펴보세요. 일부 추천 예시는 다음과 같습니다. 이미지 분류기 재훈련: 사전에 훈련된 이미지 분류기를 기반으로 꽃을 분류하기 위한 Keras 모델을 구축합니다. 텍스트 분류: IMDB 영화 리뷰를 긍정적인 리뷰 또는 부정적인 리뷰로 분류합니다. 스타일 트랜스퍼: 딥 러닝을 사용하여 이미지 간에 스타일을 전이시킵니다. Multilingual Universal Sentence Encoder Q&amp;A: 머신러닝 모델을 사용하여 SQuAD 데이터 세트의 질문에 답변합니다. 동영상 보간 유형: 동영상에서 첫 프레임과 마지막 프레임 사이에 발생한 내용을 예측합니다.","link":"/2021/11/01/Colaboratory_exam/"},{"title":"","text":"파이썬(Python) 기본 문법 - 1이 포스트는 필자의 정확한 파이썬 문법을 익히고 필요할때 찾아보기 위해 서술한 것이다. Hello World 어떤 프로그래밍언어든 배우기 시작하면 출력하고 보는 Hello world, 파이썬에서는 다음과 같이 출력한다. 1print(&quot;Hello, world!&quot;) Output: Hello, world! 당연하게도 Hello, world 이외의 다른 문장이 들어가면 그대로 출력되며print() 에서 괄호 내부에 출력을 해주고싶은 변수나 문장을 입력하면 된다, 문장의 경우는 따옴표로 묶어줘야 출력이 된다. 주석처리 접기 / 펼치기 프로그래밍 언어마다 주석처리해주는 방법이 다르다, 파이썬 역시 그러하며 다음과 같이 주석처리한다. 1234567# 한줄을 주석처리하는 방법입니다.&quot;&quot;&quot;여러줄을한번에 주석처리하는방법입니다.&quot;&quot;&quot;print(&quot;Hello, world!&quot;) Output: Hello, world! 위처럼 작성하고 실행시키면 나머지 줄은 모두 주석처리되고 가장 아랫줄인 Hello, world만 출력이 되는걸 볼 수 있다. 변수의 종류 접기 / 펼치기 변수(Variable)는 (문자나 숫자 같은) 값을 담는 컨테이너로 값을 유지할 필요가 있을 때 사용한다. 여기에 담겨진 값은 다른 값으로 바꿀 수 있다. 변수는 마치 (사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다. 출처 : 생활코딩 - 변수 다른 프로그래밍언어와 같이 파이썬 역시 다양한 변수의 종류(타입)가 있는데 이번 단락에서는 그것에 대해 알아보겠다. int타입 (정수형)12num_int = 1print(type(num_int)) 변수에 값을 정수로 주고 그 변수의 타입을 알아본 예제, 출력을 하게되면 &lt;class 'int'&gt;가 줄력된다. float타입 (실수형)12num_float = 0.2print(type(num_float)) 변수에 값을 실수로 주고 그 변수의 타입을 출력한 예제, 출력을 하게되면 &lt;class 'float'&gt;가 출력된다. bool타입 (논리형)12bool_true = Trueprint(type(bool_true)) 변수에 값을 논리타입(True or False)으로 주고 그 변수의 타입을 출력한 예제, 출력하면 &lt;class 'bool&gt;이 출력된다. None타입12none_x = Noneprint(type(none_x)) Null을 나타내는 자료형이다, None라는 한가지 값만 가질 수 있다. (왜 필요한지는 아직 모르겠다) 사칙연산 접기 / 펼치기 파이썬에서의 사칙연산은 일반적인 사칙연산과 같다.그리고 나눈후 정수의값만 구하는 //, 나머지를 구하는 %, 거듭제곱을 뜻하는 ** 등의 연산자가 있다. 123456789a = 3b = 2print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) Output: a + b = 5 a - b = 1 a * b = 6 a / b = 1.5 a // b = 1 a % b = 1 a ** b = 9 위처럼 각각 계산이 된걸 알 수 있다. 정리하면 아래와 같다 연산자 내용 + 두 변수의 합을 계산 - 두 변수의 차를 계산 * 두 변수의 곱을 계산 / 두 변수로 나눈 결과를 float 형으로 반환 // 두 변수로 나눈 결과에서 정수 부분만 취함 % 두 변수로 나눈 결과에서 나머지 값만 가져옴 ** i**j일 경우, i의 j만큼 제곱하여 계산 (예: 2 ** 4 = 24 = 16) 논리형 연산자 접기 / 펼치기 논리형 연산자에는 and 와 or이 있다.and연산자는 두 조건이 모두 참일때 True가 되며 or의 경우 두 조건중 하나라도 참일때 True가 된다. and연산자1234print(True and True)print(True and False)print(False and True)print(False and False) Output: True False False False 위 결과처럼 두 조건 모두 참일때만 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False False False True False False False False or 연산자1234print(True or True)print(True or False)print(False or True)print(False or False) Output: True True True False 위 결과처럼 두 조건 중 하나만 참이라도 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False True False True True False False False 비교 연산자 접기 / 펼치기 비교 연산자에는 &gt;,&lt;,&gt;=,&lt;=이 있다.일단, 예제를 보자. 1234print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3) Output: True False True False 예제처럼 결과는 논리타입으로 출력된다. 문자열 연산 접기 / 펼치기 정수나 실수 논리타입뿐만 아니라 문자열도 연산이 가능하다.다만 문자열을 뒤에 덧붙이는+연산자, 문자열을 횟수만큼 반복해주는*연산자만 사용이 가능하다. 123str1 = &quot;Python &quot;str2 = &quot;Editor &quot;print('str1 + str2 = ', str1 + str2) Output: Python Editor +연산자의 경우 위처럼 문자열 두 개가 나란히 이어붙혀져 출력이 되며, 12greet = str1 + str2print('greet * 3 = ', greet * 3) Output: Python Editor Python Editor Python Editor *연산자의 경우 변수에 담긴 문자열이 정해준 횟수만큼 반복되어 나열된다. 문자열 인덱싱 접기 / 펼치기 문자열이 있는경우 숫자을 통해 문자열에서 특정 문자만을 출력할 수 있는데 이를 Indexing 이라고 한다.Hello world이라는 문자열이 있다고 하자 그럼 문자열의 각 인덱스는 다음과 같다. 문자열 H e l l o w o r l d 인덱스 0 1 2 3 4 5 6 7 8 9 10 이처럼 각 글자마다 인덱스가 배정되며 공백에도 인덱스가 배정된다.인덱스를 사용하면 다음과 같은 것도 가능하다. 1234text_ex = &quot;Hello world&quot;print(text_ex[2])print(text_ex[6:10])print(text_ex[2:11:2]) Output: l worl lowrd 위 예제는 문자열을 담은 변수에 인덱싱을 한 것이다첫번째 줄은 인덱스’2’의 문자를 가져오는 것인데 인덱스는 0부터 시작하므로 (2번째가아닌)3번째인’l’을 출력한것이다.두번째 줄은 인덱스’6’부터 ‘9’까지(두번째인덱스-1)의 숫자를 가져오는 것이므로 ‘worl’이 출력되었다.세번째 줄은 인덱스’2’부터 ‘10’까지를 가져오되, 한칸씩 건너뛰고(세번째 숫자가 3이므로) 가져오는것이다. 리스트(list) 접기 / 펼치기 리스트는 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.리스트의 장점은 다음과 같다. 인덱스 번호로 빠른 접근이 가능하다. 데이터의 위치에 대해 직접적인 접근(Access)가 가능하다.1fruit = [['apple', 'banana', 'cherry'], 123] 위가 리스트의 형태이다.리스트의 값은 기본적으로 인덱스가 배정된다 이때는1print(fruit[0]) Output: [‘apple’, ‘banana’, ‘cherry’]위와 같은 형태로 나타낼 수 있으며 해당 인덱스의 요소가 리스트라면 리스트 전체를 출력한다. 만약 위처럼 리스트가 중첩된 형태라면 1print(fruit[0][1]) Output: banana 위처럼 출력이 가능하며 이때 리스트의 요소중 해당 인덱스의 요소가 출력된다.물론 이 때도 출력된 문자열에서 다음과 같이 문자열의 요소를 출력하는것도 가능하다. 1print(fruit[0][1][3]) Output: a 위와같이 결과가 출력된다. 리스트값 수정, 추가, 삭제하기 접기 / 펼치기 리스트가 여러 요소들의 집합이다보니 리스트의 값에 변동이 필요할 때가 있다.리스트는 값의 수정, 추가, 삭제가 가능하므로 기능과 문법에 대해 알아둘 필요가 있다. 리스트 값 수정하기123a = [0,1,2]a[1] = &quot;b&quot;print(a) Output: [0, 'b', 2] 별다른 문법없이 리스트의 인덱스에 값을 넣어주니 수정이 되는것을 알 수 있다. 리스트 값 추가하기 append1234567a = [100, 200, 300]a.append(400)print(a)b = [500,600]a.append(b)print(a) Output: [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]]리스트명.append(값)을 통해서 리스트에 값을 추가할 수 있으며 한개의 값만 추가할 수 있다.리스트의 경우엔 한가지 값이며 추가할 경우 중첩된 리스트의 형태로 추가가 된다. extendextend는 append와 거의 같지만 다른점이 하나 있습니다.append는 인자(리스트, 튜플 등)를 주어도 인자 그대로를 리스트에 추가하지만,extend는 인자를 줄 경우 인자의 값 하나하나를 리스트에 추가한다. 1234a = [2, 9, 3]b = [1, 2, 3]a.extend(b)print(a) Output: [2, 9, 3, 1, 2, 3]결과와 같이 append와 비교했을때 extend된 인자의 값 하나하나가 추가된걸 볼 수 있다. insertinsert는 입력해준 위치의 인덱스에 값을 추가해준다. 1234a = [1,2,3]print(a)a.insert(1,'abc')print(a) Output: [1,2,3] [1,’abc’,2,3] 리스트 값 삭제하기 remove1234567a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 였던 1이 삭제a.remove(3)print(a) Output: [2, 1, 2] [2, 2]리스트명.remove()는 괄호내의 값을 삭제한다.만약 값이 리스트내에서 중복될경우 가장 앞에 있는 값을 삭제한다. del12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아준다.print(b) Output: [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9]del 리스트명[인덱스]는 리스트의 인덱스에 위치한 값을 삭제해준다.인덱스값에 범위를 주고싶다면 0:4 처럼 넣을수 있으며 이때는 0에서 3번째 값까지 삭제가 된다. pop12345a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) Output: [0, 2, 3, 4] 1리스트명.pop()은 괄호내의 값을 해당 리스트에서 끄집어낸다. 튜플(tuple) 접기 / 펼치기 튜플은 리스트와 비슷하게 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.튜플과 리스트의 가장 차이점으로는 튜플은 값에대한 수정이 불가하다는 점이다.그렇다면 튜플은 무슨 장점이 있느냐 라고 반문할 수 있는데 리스트와 비교한 튜플의 장점은 다음과 같다. 메모리 사용량이 적다. 생성 시간이 빠르다. 인덱스를 사용하여 튜플의 데이터에 접근하는 시간이 비교적 짧다. 튜플의 문법, 기본형태는 다음과 같다. 1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. Output: 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 튜플을 생성할때 튜플이 되기위해서는 콤마(,)가 필수적이다.콤마를 작성하지 않으면 타입을 출력했을때 튜플이 아닌 입력한 변수형태로 출력이 된다. 튜플역시 리스트와 같이 인덱싱및 슬라이싱이 가능하다. 튜플의 연산튜플도 연산이 가능한데, 더하거나 곱하는 +, * 연산자만 사용이 가능하다. 1234t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t3) Output: (0, 1, 2, 3, 4, 'a', 'b', 'c') 딕셔너리 접기 / 펼치기 딕셔너리는 키와 그에따른 값으로 구성되어있는 파이썬의 자료구조이다. 12345dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) Output: alice 5 [1, 2, 3] 키를 출력하면 그와 대응하는 값이 출력되는 자료구조이며 자료에 순서가 없는논시퀀스 자료형이다. 123a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys()a.values() Output: dict_keys(['name', 'job', 'age']) dict_values(['bob', 'farmer', 35]) 이렇게 키만 출력할수도, 값만 출력할수도 있다. 집합 연산자 접기 / 펼치기 파이썬에도 집합연산이 있고, 자료구조들의 합,교,차집합에 대한 연산을 할수 있다.기호는 |,&amp;,-이며, 각각의 예시는 다음과 같다. 12345a = {1,2,3,4}b = {3,4,5,6}print(a|b) print(a&amp;b)print(a-b) Output: {1, 2, 3, 4, 5, 6} {3, 4} {1, 2} if 조건문 접기 / 펼치기 조건문이란 작성자가 명시한 조건식의 결과인 boolean값이 참인지 거짓인지에 따라 달라지는 계산이나 상황을 수행하는 문장이다. 12345678910a = -5if a&gt;5: print('a는 5이상입니다')elif a &gt; 0: print(&quot;a는 0초과, 5이하입니다&quot;)else: print(&quot;a는 음수입니다&quot;) Output: a는 음수입니다. 조건식에는 기본적으로 조건식이 들어가지만 True나 False등의 직접적인 bool형 변수가 삽입될수도 있으며, and,or 등과 결합하여 여러가지의 조건식을 사용할수도 있다. 반복문 (for,while) 접기 / 펼치기 같은동작을 여러번 반복해야 할 때 같은코드를 여러번 적어넣는건 비효율적이다.그럴때 반복문을 사용하면 훨씬 적은양의 코드로도 같은효과를 낼 수 있다. for문 for문의 기본 구조123for 변수 in 리스트(또는 튜플, 문자열) : 수행할 문장1 수행할 문장2 리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.123a = ['1','2','3']for i in a : print(i) Output: 1 2 3 리스트 a의 첫번째 값인 1이 i에 대입되고 print(i)가 출력된다.다음엔 두번째 값인 2가 대입되고 출력된다.이것을 마지막 값까지 반복한다. while문 while문의 기본 구조12345while &lt;조건문&gt;: &lt;수행할 문장1&gt; &lt;수행할 문장2&gt; &lt;수행할 문장3&gt; ... while문은 for보다는 간단하다. while, 조건문, 실행문 이 세개면 완성되기 때문이다.이러한 특성때문에 while문은 조건문을 거짓으로 만들어주는 문장이 없다면 무한실행된다. 프로그램 뻗는다간단한 예제를 보면 다음과 같다.1234i = 0while i &lt;= 5 : print(&quot;{}번째 반복입니다.&quot;.format(i)) i += 1 Output: 0번째 반복입니다. 1번째 반복입니다. 2번째 반복입니다. 3번째 반복입니다. 4번째 반복입니다. 5번째 반복입니다.변수 i로 인해 자동으로 조건식이 False가 되면서 while문이 종료되는 모습이다.이렇듯 while문은 조건문을 거짓으로 만들어주는 무엇인가가 없다면 종료되지않는다.","link":"/2021/11/01/Python_Basic_Grammar_1/"}],"tags":[],"categories":[]}