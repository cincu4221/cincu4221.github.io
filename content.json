{"pages":[],"posts":[{"title":"Hexo로 깃허브 블로그 만들기","text":"Hexo란?Hexo는 Node.js기반의 정적 블로그 프레임워크 입니다. Markdown으로 문서를 작성하고 빌드시 정적 HTML이 생기고이것을 GitHub pages에 배포 하여 블로그를 관리 합니다. 설치환경 Git Node.js 파이참(PyCharm) GitHub 계정 설치환경 확인 아래 코드로 Node.js 설치를 확인해봅니다.1$ node -v 아래 코드로 Git 설치를 확인합니다.1$ git --version npm을 통해 hexo를 전역으로 설치합니다.1$ npm install -g hexo-cli GitHub 블로그 만들기먼저 원하는 디렉토리로 이동하여 헥소 블로그 디렉토리를 만들어줍니다.(이 포스팅에서는 myblog)1$ hexo init myblog 생성된 디렉토리를 우클릭 한 뒤‘Open Folder as PyCharm Community Edition Project‘를 클릭해 파이참으로 열어줍니다. 실행된 파이참의 좌측 아래에서 터미널 메뉴를 선택하고 사진과같이 Git Bash를 클릭해주면파이참에서 Git을 사용할 수 있게 됩니다. 이후 Git에서 다음 명령어들을 입력해줍니다 123$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save 이제 GitHub 접속하고 우측 상단의 아이콘 클릭 후 ‘Your repositories‘에 들어갑니다.Repository name 란에 만들었던 디렉토리와 같은 이름인 ‘myblog’를 넣은 후 아무것도 건드리지 않고 아래의 ‘Create repository’ 버튼을 눌러줍니다. 다시 파이참으로 돌아와서 아래의 Git 명령어들을 입력해줍니다. 1234567echo &quot;# myblog&quot; &gt;&gt; README.mdgit initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/cincu4221/myblog.gitgit push -u origin main GitHub에서 ‘myblog‘ 리포지토리를 만들때와 이름만 다르게 ‘사용자계정명.github.it‘ 으로 바꾸어서 리포지토리를 하나 더 생성해 줍니다. 파이참의 작업영역에서 _config.yml 파일을 열어서 수정해줍니다. 블로그 정보 설정1234title: blog titlesubtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그의 URL정보 설정1234url: https://Username.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 설정12345# Deploymentdeploy: type: git repo: https://github.com/Username/Username.github.io.git branch: main 위의 코드에서 Username으로 되어있는것은 꼭 사용자의 GitHub계정명으로 바꿔주셔야 합니다. 파이참의 Git Bash(Terminal)에 다음 코드들을 입력합니다. 12$ hexo generate$ hexo server 이후 나오는 localhost:4000에서 화면이 뜨는지 확인합니다. 다음 코드를 입력해 최종적으로 배포를 진행합니다. 1$ hexo deploy 배포가 완료되면 브라우저에서 [USERNAME.github.io]로 접속해 정상적으로 배포되었는지 확인합니다. * 참고 : https://dschloe.github.io/settings/hexo_blog/","link":"/2021/10/28/make_github_blog/"},{"title":"윈도우에서 Git 설치하기","text":"다운로드 먼저 Git홈페이지에서 Download for Windows을 클릭해 자신의 윈도우 버전에 맞는 Git을 다운로드 해준다. Git 홈페이지 윈도우 버전에 맞는 Git이 알아서 다운로드된다. 설치 설치파일을 실행시키면 항상 보는 약관페이지가 나온다. Next를 눌러 넘어간다. 설치경로를 정해주고 Next 설치할 Component 들을 선택하는 창이다. 기본으로 선택되어 있는것만 선택하고 Next를 눌러 넘어간다. 시작메뉴에 폴더를 생성하는 창이다. 폴더를 추가하고 싶지 않다면 아래에 있는 Don't create a Start Menu folder 체크박스를 클릭하고 Next를 눌러준다. Git의 기본 에디터를 설정하는 창이다. 이번에도 기본으로 선택되어있는 항목을 고르고 Next를 눌러 넘어간다. 선택되어있는 Let Git decide를 고르고 Next를 누른다. 환경변수 옵션 설정이다. Git from the Command line and also from 3rd-party software를 선택하고 Next Use bundled OpenSSH를 선택한채로 Next를 누른다. https 전송시 인증서 선택. Use the OpenSSL library을 선택 후 Next Checkout Windows style, commit Unix-style line endings을 선택하고 Next Git Bash 터미널의 형식. Use MinTTY를 선택하고 넘어갑니다. Git pull 작업방식. Default로 설정해주고 Next를 누른다. Credential Helper 사용에 대한 선택. Git Credential Manager Core선택 후 Next 기타 실행옵션. 필자는 Enable file system caching만 체크 후 넘어갔다. 모든 옵션에 체크를 완료하고 설치가 진행되는 모습. 설치가 완료되면 위와 같은 창이 뜬다. 설치 확인 자 이제 설치가 잘 되었는지 확인할 차례이다.윈도우에 cmd를 검색해 명령 프롬프트를 실행한다.아무것도 하지않은채로 git 을 입력한다. 입력하면 위 사진처럼 Git의 명령어가 나오면서 설치가 완료된걸 확인 할 수 있다.","link":"/2021/10/29/setting_Git/"},{"title":"파이썬(Python) 기본 문법 - 1","text":"이 포스트는 필자의 정확한 파이썬 문법을 익히고 필요할때 찾아보기 위해 서술한 것이다. Hello World 어떤 프로그래밍언어든 배우기 시작하면 출력하고 보는 Hello world, 파이썬에서는 다음과 같이 출력한다. 1print(&quot;Hello, world!&quot;) Output: Hello, world! 당연하게도 Hello, world 이외의 다른 문장이 들어가면 그대로 출력되며print() 에서 괄호 내부에 출력을 해주고싶은 변수나 문장을 입력하면 된다, 문장의 경우는 따옴표로 묶어줘야 출력이 된다. 주석처리 접기 / 펼치기 프로그래밍 언어마다 주석처리해주는 방법이 다르다, 파이썬 역시 그러하며 다음과 같이 주석처리한다. 1234567# 한줄을 주석처리하는 방법입니다.&quot;&quot;&quot;여러줄을한번에 주석처리하는방법입니다.&quot;&quot;&quot;print(&quot;Hello, world!&quot;) Output: Hello, world! 위처럼 작성하고 실행시키면 나머지 줄은 모두 주석처리되고 가장 아랫줄인 Hello, world만 출력이 되는걸 볼 수 있다. 변수의 종류 접기 / 펼치기 변수(Variable)는 (문자나 숫자 같은) 값을 담는 컨테이너로 값을 유지할 필요가 있을 때 사용한다. 여기에 담겨진 값은 다른 값으로 바꿀 수 있다. 변수는 마치 (사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다. 출처 : 생활코딩 - 변수 다른 프로그래밍언어와 같이 파이썬 역시 다양한 변수의 종류(타입)가 있는데 이번 단락에서는 그것에 대해 알아보겠다. int타입 (정수형)12num_int = 1print(type(num_int)) 변수에 값을 정수로 주고 그 변수의 타입을 알아본 예제, 출력을 하게되면 &lt;class 'int'&gt;가 줄력된다. float타입 (실수형)12num_float = 0.2print(type(num_float)) 변수에 값을 실수로 주고 그 변수의 타입을 출력한 예제, 출력을 하게되면 &lt;class 'float'&gt;가 출력된다. bool타입 (논리형)12bool_true = Trueprint(type(bool_true)) 변수에 값을 논리타입(True or False)으로 주고 그 변수의 타입을 출력한 예제, 출력하면 &lt;class 'bool&gt;이 출력된다. None타입12none_x = Noneprint(type(none_x)) Null을 나타내는 자료형이다, None라는 한가지 값만 가질 수 있다. (왜 필요한지는 아직 모르겠다) 사칙연산 접기 / 펼치기 파이썬에서의 사칙연산은 일반적인 사칙연산과 같다.그리고 나눈후 정수의값만 구하는 //, 나머지를 구하는 %, 거듭제곱을 뜻하는 ** 등의 연산자가 있다. 123456789a = 3b = 2print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) Output: a + b = 5 a - b = 1 a * b = 6 a / b = 1.5 a // b = 1 a % b = 1 a ** b = 9 위처럼 각각 계산이 된걸 알 수 있다. 정리하면 아래와 같다 연산자 내용 + 두 변수의 합을 계산 - 두 변수의 차를 계산 * 두 변수의 곱을 계산 / 두 변수로 나눈 결과를 float 형으로 반환 // 두 변수로 나눈 결과에서 정수 부분만 취함 % 두 변수로 나눈 결과에서 나머지 값만 가져옴 ** i**j일 경우, i의 j만큼 제곱하여 계산 (예: 2 ** 4 = 24 = 16) 논리형 연산자 접기 / 펼치기 논리형 연산자에는 and 와 or이 있다.and연산자는 두 조건이 모두 참일때 True가 되며 or의 경우 두 조건중 하나라도 참일때 True가 된다. and연산자1234print(True and True)print(True and False)print(False and True)print(False and False) Output: True False False False 위 결과처럼 두 조건 모두 참일때만 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False False False True False False False False or 연산자1234print(True or True)print(True or False)print(False or True)print(False or False) Output: True True True False 위 결과처럼 두 조건 중 하나만 참이라도 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False True False True True False False False 비교 연산자 접기 / 펼치기 비교 연산자에는 &gt;,&lt;,&gt;=,&lt;=이 있다.일단, 예제를 보자. 1234print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3) Output: True False True False 예제처럼 결과는 논리타입으로 출력된다. 문자열 연산 접기 / 펼치기 정수나 실수 논리타입뿐만 아니라 문자열도 연산이 가능하다.다만 문자열을 뒤에 덧붙이는+연산자, 문자열을 횟수만큼 반복해주는*연산자만 사용이 가능하다. 123str1 = &quot;Python &quot;str2 = &quot;Editor &quot;print('str1 + str2 = ', str1 + str2) Output: Python Editor +연산자의 경우 위처럼 문자열 두 개가 나란히 이어붙혀져 출력이 되며, 12greet = str1 + str2print('greet * 3 = ', greet * 3) Output: Python Editor Python Editor Python Editor *연산자의 경우 변수에 담긴 문자열이 정해준 횟수만큼 반복되어 나열된다. 문자열 인덱싱 접기 / 펼치기 문자열이 있는경우 숫자을 통해 문자열에서 특정 문자만을 출력할 수 있는데 이를 Indexing 이라고 한다.Hello world이라는 문자열이 있다고 하자 그럼 문자열의 각 인덱스는 다음과 같다. 문자열 H e l l o w o r l d 인덱스 0 1 2 3 4 5 6 7 8 9 10 이처럼 각 글자마다 인덱스가 배정되며 공백에도 인덱스가 배정된다.인덱스를 사용하면 다음과 같은 것도 가능하다. 1234text_ex = &quot;Hello world&quot;print(text_ex[2])print(text_ex[6:10])print(text_ex[2:11:2]) Output: l worl lowrd 위 예제는 문자열을 담은 변수에 인덱싱을 한 것이다첫번째 줄은 인덱스’2’의 문자를 가져오는 것인데 인덱스는 0부터 시작하므로 (2번째가아닌)3번째인’l’을 출력한것이다.두번째 줄은 인덱스’6’부터 ‘9’까지(두번째인덱스-1)의 숫자를 가져오는 것이므로 ‘worl’이 출력되었다.세번째 줄은 인덱스’2’부터 ‘10’까지를 가져오되, 한칸씩 건너뛰고(세번째 숫자가 3이므로) 가져오는것이다. 리스트(list) 접기 / 펼치기 리스트는 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.리스트의 장점은 다음과 같다. 인덱스 번호로 빠른 접근이 가능하다. 데이터의 위치에 대해 직접적인 접근(Access)가 가능하다.1fruit = [['apple', 'banana', 'cherry'], 123] 위가 리스트의 형태이다.리스트의 값은 기본적으로 인덱스가 배정된다 이때는1print(fruit[0]) Output: [‘apple’, ‘banana’, ‘cherry’]위와 같은 형태로 나타낼 수 있으며 해당 인덱스의 요소가 리스트라면 리스트 전체를 출력한다. 만약 위처럼 리스트가 중첩된 형태라면 1print(fruit[0][1]) Output: banana 위처럼 출력이 가능하며 이때 리스트의 요소중 해당 인덱스의 요소가 출력된다.물론 이 때도 출력된 문자열에서 다음과 같이 문자열의 요소를 출력하는것도 가능하다. 1print(fruit[0][1][3]) Output: a 위와같이 결과가 출력된다. 리스트값 수정, 추가, 삭제하기 접기 / 펼치기 리스트가 여러 요소들의 집합이다보니 리스트의 값에 변동이 필요할 때가 있다.리스트는 값의 수정, 추가, 삭제가 가능하므로 기능과 문법에 대해 알아둘 필요가 있다. 리스트 값 수정하기123a = [0,1,2]a[1] = &quot;b&quot;print(a) Output: [0, 'b', 2] 별다른 문법없이 리스트의 인덱스에 값을 넣어주니 수정이 되는것을 알 수 있다. 리스트 값 추가하기 append1234567a = [100, 200, 300]a.append(400)print(a)b = [500,600]a.append(b)print(a) Output: [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]]리스트명.append(값)을 통해서 리스트에 값을 추가할 수 있으며 한개의 값만 추가할 수 있다.리스트의 경우엔 한가지 값이며 추가할 경우 중첩된 리스트의 형태로 추가가 된다. extendextend는 append와 거의 같지만 다른점이 하나 있습니다.append는 인자(리스트, 튜플 등)를 주어도 인자 그대로를 리스트에 추가하지만,extend는 인자를 줄 경우 인자의 값 하나하나를 리스트에 추가한다. 1234a = [2, 9, 3]b = [1, 2, 3]a.extend(b)print(a) Output: [2, 9, 3, 1, 2, 3]결과와 같이 append와 비교했을때 extend된 인자의 값 하나하나가 추가된걸 볼 수 있다. insertinsert는 입력해준 위치의 인덱스에 값을 추가해준다. 1234a = [1,2,3]print(a)a.insert(1,'abc')print(a) Output: [1,2,3] [1,’abc’,2,3] 리스트 값 삭제하기 remove1234567a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 였던 1이 삭제a.remove(3)print(a) Output: [2, 1, 2] [2, 2]리스트명.remove()는 괄호내의 값을 삭제한다.만약 값이 리스트내에서 중복될경우 가장 앞에 있는 값을 삭제한다. del12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아준다.print(b) Output: [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9]del 리스트명[인덱스]는 리스트의 인덱스에 위치한 값을 삭제해준다.인덱스값에 범위를 주고싶다면 0:4 처럼 넣을수 있으며 이때는 0에서 3번째 값까지 삭제가 된다. pop12345a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) Output: [0, 2, 3, 4] 1리스트명.pop()은 괄호내의 값을 해당 리스트에서 끄집어낸다. 튜플(tuple) 접기 / 펼치기 튜플은 리스트와 비슷하게 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.튜플과 리스트의 가장 차이점으로는 튜플은 값에대한 수정이 불가하다는 점이다.그렇다면 튜플은 무슨 장점이 있느냐 라고 반문할 수 있는데 리스트와 비교한 튜플의 장점은 다음과 같다. 메모리 사용량이 적다. 생성 시간이 빠르다. 인덱스를 사용하여 튜플의 데이터에 접근하는 시간이 비교적 짧다. 튜플의 문법, 기본형태는 다음과 같다. 1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. Output: 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 튜플을 생성할때 튜플이 되기위해서는 콤마(,)가 필수적이다.콤마를 작성하지 않으면 타입을 출력했을때 튜플이 아닌 입력한 변수형태로 출력이 된다. 튜플역시 리스트와 같이 인덱싱및 슬라이싱이 가능하다. 튜플의 연산튜플도 연산이 가능한데, 더하거나 곱하는 +, * 연산자만 사용이 가능하다. 1234t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t3) Output: (0, 1, 2, 3, 4, 'a', 'b', 'c') 딕셔너리 접기 / 펼치기 딕셔너리는 키와 그에따른 값으로 구성되어있는 파이썬의 자료구조이다. 12345dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) Output: alice 5 [1, 2, 3] 키를 출력하면 그와 대응하는 값이 출력되는 자료구조이며 자료에 순서가 없는논시퀀스 자료형이다. 123a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys()a.values() Output: dict_keys(['name', 'job', 'age']) dict_values(['bob', 'farmer', 35]) 이렇게 키만 출력할수도, 값만 출력할수도 있다. 집합 연산자 접기 / 펼치기 파이썬에도 집합연산이 있고, 자료구조들의 합,교,차집합에 대한 연산을 할수 있다.기호는 |,&amp;,-이며, 각각의 예시는 다음과 같다. 12345a = {1,2,3,4}b = {3,4,5,6}print(a|b) print(a&amp;b)print(a-b) Output: {1, 2, 3, 4, 5, 6} {3, 4} {1, 2} if 조건문 접기 / 펼치기 조건문이란 작성자가 명시한 조건식의 결과인 boolean값이 참인지 거짓인지에 따라 달라지는 계산이나 상황을 수행하는 문장이다. 12345678910a = -5if a&gt;5: print('a는 5이상입니다')elif a &gt; 0: print(&quot;a는 0초과, 5이하입니다&quot;)else: print(&quot;a는 음수입니다&quot;) Output: a는 음수입니다. 조건식에는 기본적으로 조건식이 들어가지만 True나 False등의 직접적인 bool형 변수가 삽입될수도 있으며, and,or 등과 결합하여 여러가지의 조건식을 사용할수도 있다. 반복문 (for,while) 접기 / 펼치기 같은동작을 여러번 반복해야 할 때 같은코드를 여러번 적어넣는건 비효율적이다.그럴때 반복문을 사용하면 훨씬 적은양의 코드로도 같은효과를 낼 수 있다. for문 for문의 기본 구조123for 변수 in 리스트(또는 튜플, 문자열) : 수행할 문장1 수행할 문장2 리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.123a = ['1','2','3']for i in a : print(i) Output: 1 2 3 리스트 a의 첫번째 값인 1이 i에 대입되고 print(i)가 출력된다.다음엔 두번째 값인 2가 대입되고 출력된다.이것을 마지막 값까지 반복한다. while문 while문의 기본 구조12345while &lt;조건문&gt;: &lt;수행할 문장1&gt; &lt;수행할 문장2&gt; &lt;수행할 문장3&gt; ... while문은 for보다는 간단하다. while, 조건문, 실행문 이 세개면 완성되기 때문이다.이러한 특성때문에 while문은 조건문을 거짓으로 만들어주는 문장이 없다면 무한실행된다. 프로그램 뻗는다간단한 예제를 보면 다음과 같다.1234i = 0while i &lt;= 5 : print(&quot;{}번째 반복입니다.&quot;.format(i)) i += 1 Output: 0번째 반복입니다. 1번째 반복입니다. 2번째 반복입니다. 3번째 반복입니다. 4번째 반복입니다. 5번째 반복입니다.변수 i로 인해 자동으로 조건식이 False가 되면서 while문이 종료되는 모습이다.이렇듯 while문은 조건문을 거짓으로 만들어주는 무엇인가가 없다면 종료되지않는다.","link":"/2021/11/01/Python_Basic_Grammar_1/"},{"title":"pandas 기본 문법","text":"DataFrame 생성 방법 list이용12345import pandas as pdframe = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 1 2 3 1 4 5 6 2 7 8 9 Dictionary 이용1234567891011import pandas as pddata = { 'age' : [20,39,41], 'height' : [176, 182, 180], 'weight' : [73, 78, 69]}indexName = ['사람1', '사람2', '사람3']frame = pd.DataFrame(data, index = indexName)frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight 사람1 20 176 73 사람2 39 182 78 사람3 41 180 69 Sample Dataset 가져오기 위처럼 직접 DataFrame을 만드는 것이 아닌 제공하는 Dataset을 직접 가져오는 방법도 있다.Dataset을 가져오는 방법은 다음과 같다. Dataset Github에 접속하고 가져오고싶은 데이터셋을 고른다. 예를들어 flights.csv 를 가져오고 싶다면1234import seaborn as snsflights = sns.load_dataset(&quot;flights&quot;) #여기까지가 가져오기flights.head(5) # 다섯번째 행의 데이터까지만 출력flights[&quot;year&quot;] # 'year'열만 출력 위와 같이 제공되는 데이터셋을 가져올 수 있다. DataFrame 조회 방법 기본적인 조회 방법DataFrame의 기본적인 조회 방법은 다음과 같다. .head() 12# 위에서 가져온 데이터셋 flights를 사용flights.head() # 데이터프레임의 가장 첫부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 이 때 .head()의 괄호 안에 숫자가 있다면 그 수의 개수만큼 데이터가 출력된다. .tail() 1flights.tail() #데이터프레임의 가장 뒷부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 .tail()역시 마찬가지로 괄호안에 숫자가 있다면 수의 개수만큼 데이터가 출력된다. .index 데이터프레임의 인덱스를 표시하는 방법도 있다. 1flights.index RangeIndex(start=0, stop=144, step=1) 열(Column) 조회 방법12345678910#열(Column) 조회print (&quot;* 열 조회 - 1&quot;)print (frame['age'])print (&quot;* 열 조회 - 2&quot;)print(frame.age)#특정 열의 특정 값을 조회하고 싶을때print(&quot;* 특정 열 의 특정 값 조회&quot;)print(frame['age'][1])print(frame.height[2]) 출력 * 열 조회 - 1 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 열 조회 - 2 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 특정 열 의 특정 값 조회 39 180 행(Row) 조회행 조회는 열 조회와 조금 다르게 loc와 iloc를 사용해서 조회 할 수 있다.여기서 loc는 사람이 읽을 수 있는 라벨 값으로 특정 값들을 골라오는 방법이고,iloc는 행이나 칼럼의 순서를 나타내는 정수로 특정 값을 추출하는 방법이다. 12345#행(Row) 조회 (loc)print(&quot;* loc 특정 행 조회&quot;)print(frame.loc['사람1'])# print(frame.loc[0]) - 조건이 정수이므로 조회 불가 출력 * 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 loc를 Seq로 조회할 경우 12345#행(Row) 조회 (iloc)print(&quot;* iloc 특정 행 조회&quot;)print(frame.iloc[0])# print(frame.iloc['사람1']) - 조건이 정수가 아니므로 조회 불가 출력 * iloc 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 DataFrame 수정 방법 열(Column) 추가하기gender 라는 컬럼을 추가합니다. 12frame_add_col = pd .DataFrame(frame,columns= ['age','height','weight','gender'])frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 NaN 사람2 39 182 78 NaN 사람3 41 180 69 NaN 컬럼이 추가되었고 어떠한 값도 넣어주지 않았으므로 NaN 값이 출력되고있다.이제 데이터를 입력해준다. 12frame_add_col['gender'] = ['male', 'male', 'female']frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 행(Row) 추가하기123frame_add_index = frame_add_col.copy()frame_add_index.loc['사람4'] = [31, 158, 48, 'female']frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 사람4 31 158 48 female 행, 열 삭제하기drop 메소드를 사용하면 행 또는 열을 삭제할 수 있다.axis 값은 행이면’0’, 열이면 ‘1’로 지정해주면 된다. 12print('remove age column')frame_add_col.drop(&quot;height&quot;, axis=1) 출력 remove age column .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age weight gender 사람1 20 73 male 사람2 39 78 male 사람3 41 69 female 그러나 이 경우 기존에 있던 frame_add_col에서 삭제되는게 아니라 삭제된 상태의 프레임을 리턴해준 것이다.그러므로 기존 프레임에 적용하기 위해서 inplace = True 옵션을 추가로 주어야 한다. 12frame_add_index.drop('사람2', axis=0, inplace = True)frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람3 41 180 69 female 사람4 31 158 48 female References https://hong-sam.tistory.com/100","link":"/2021/11/02/pandas_Basic_Grammar_1/"},{"title":"결정 나무(Decision Tree) 간단 설명","text":"결정 나무란? 결정 나무 Decision Tree 는 분류와 회귀 문제에 널리 사용하는 데이터마이닝 기법이다. 결정 나무는 결정을 하기위해 예/아니오 질문을 연속해가며 학습한다. 결정나무 간단설명영상결정나무 사이킷런 튜토리얼 결정나무의 의사결정 과정 결정 나무가 행하는 이 과정은 ‘스무고개’를 할때의 그것과 비슷하다.사과, 포도, 멜론, 녹차를 구분한다고 생각해보자. 사과와 포도는 과일이고 멜론과 녹차는 과일이 아니다.‘과일인가요?’라는 질문을 통해 사과, 포도 / 멜론, 녹차를 나눌 수 있고, 사과와 포도는 ‘(과실 전체의)모양이 둥근가요?’, 멜론과 녹차는 ‘넝쿨에서 자라나요?’ 라는 질문을 통해 분류해 낼 수 있다.위의 결정나무를 도식화하면 아래와 같다. 이렇게 질문에 따라 데이터를 구분짓는 모델을 결정나무모델이라고 한다. 한번의 질문에 True 혹은 False를 통해 변수영역을 두 개로 분기한다. 위의 그림에서 각각의 네모상자를 노드Node라고 하며, 가장 처음의 분기점을 Root Node라고 하고, 가장 마지막 노드를 Leaf Node또는 Terminal Node라고 한다. 결정나무분류기 = DecisionTreeClassifier DecisionTreeClassifier()는 결정나무의 기능을 바꿀수 있는 파라미터인데 파라미터 내부의 특성 하나하나를 하이퍼파라미터라고 한다.DecisionTreeClassifier()파라미터의 괄호 안에 각각의 값을 입력할 수 있는데 다음과 같은 항목들이 있다. 하이퍼파라미터 기능 criterion 분할 품질을 측정하는 기능 (default : gini) splitter 각 노드에서 분할을 선택하는 데 사용되는 전략 (default : best) max_depth 트리의 최대 깊이 (값이 클수록 모델의 복잡도가 올라간다.) min_samples_split 자식 노드를 분할하는데 필요한 최소 샘플 수 (default : 2) min_samples_leaf 리프 노드에 있어야 할 최소 샘플 수 (default : 1) min_weight_fraction_leaf min_sample_leaf와 같지만 가중치가 부여된 샘플 수에서의 비율 max_features 각 노드에서 분할에 사용할 특징의 최대 수 random_state 난수 seed 설정 max_leaf_nodes 리프 노드의 최대수 min_impurity_decrease 최소 불순도 min_impurity_split 나무 성장을 멈추기 위한 임계치 class_weight 클래스 가중치 presort 데이터 정렬 필요 여부 괄호 내부에 아무것도 입력하지않으면 기본값으로 결정나무가 출력된다. References https://inuplace.tistory.com/548 https://scikit-learn.org/stable/modules/tree.html#classification","link":"/2021/11/04/Decision_Tree/"},{"title":"마크다운(Markdown) 문법","text":"지금 당장만 해도 이 글을 마크다운으로 작성하고 있는 나는 HTML를 접해보긴 했지만 자유자재로 쓸 수 있는정도는 아니였기에 깃허브 블로그를 시작하면서 마크다운의 문법에 대해 알아야 할 필요가 생겼다. 다른 포스트들도 마찬가지지만 더욱 이 포스트는 자주 찾아 봐야 할 것 같기에 문법만을 기록하며, 접기를 최대한 지양한다. 마크다운 문법 제목 작성1234# 이러면 큰제목 &lt;h1&gt;태그## 이러면 중간제목 &lt;h2&gt;태그### 이러면 작은제목 &lt;h3&gt;태그#### 도 되긴 하지만 굵게한 글자와 차이가 없음. &lt;h4&gt;태그로 사용된다 이러면 큰제목 &lt;h1&gt;태그이러면 중간제목 &lt;h2&gt;태그이러면 작은제목 &lt;h3&gt;태그도 되긴 하지만 굵게한 글자와 차이가 없는 &lt;h4&gt;태그로 사용된다 줄바꿈12줄바꿈은 행의 끝에서 공백 두칸을 주고 다음행에 작성하면 된다 줄바꿈은 행의 끝에서 공백 두칸을 주고다음행에 작성하면 된다 코드블럭123```과 ~~~는 마크다운의 내용을 코드블럭을 씌운다.```(언어명) 내용 ``` 의 형태로 작성하며이것도 코드블럭으로 씌워진 것이다. 인라인코드1이것은 `인라인코드`이다. 이것은 인라인코드이다. 링크 걸기www.naver.com그냥 주소를 써도 링크로 클릭이 되지만 1[WJ 블로그](cincu4221.github.io) WJ 블로그위처럼 작성하면 주소를 숨기고 텍스트에 링크를 걸 수 있다. 텍스트1**강조된 텍스트** 강조된 텍스트 12*기울인텍스트****기울임,강조를적용한텍스트*** 기울인텍스트기울임,강조를적용한텍스트 1~~취소선입니다~~ 취소선입니다 글자색 12345678&lt;span style=&quot;color:orange&quot;&gt;주황색 글씨&lt;/span&gt; &lt;span style=&quot;color:yellow&quot;&gt;노란색 글씨&lt;/span&gt; &lt;span style=&quot;color:#FF0000&quot;&gt;빨간색 글씨&lt;/span&gt; &lt;span style=&quot;color:blue&quot;&gt;파란색 글씨&lt;/span&gt; &lt;span style=&quot;color:green&quot;&gt;초록색 글씨&lt;/span&gt; &lt;span style=&quot;color:pink&quot;&gt;분홍색 글씨&lt;/span&gt; &lt;span style=&quot;color:#00FFFF&quot;&gt;헥스코드 적용 글씨&lt;/span&gt; 주황색 글씨노란색 글씨빨간색 글씨파란색 글씨초록색 글씨분홍색 글씨 헥스코드 적용 글씨 검색하기 애매한 색도 여기 에서 찾을 수 있다. 구분선123***-- ----- 표만들기1234|제목|제목||:---:|:---:||내용|내용|||| 제목 제목 내용 내용 내용 내용 앞으로 계속 추가","link":"/2021/11/04/Markdown-Grammar/"},{"title":"NumPy 기본 다지기","text":"Numpy란 무엇인가?Numpy는 상당부분 C언어로 작성된 파이썬 라이브러리이다. 기본적으로 array라는 자료를 생성하고 이를 바탕으로 색인, 처리, 연산 등을 하는 기능을 수행한다. 물론 C언어로 작성되었기 때문에 속도도 꽤나 빠른편이다. Numpy의 기본Numpy 불러오기 Numpy를 사용하기 위해서는 먼저 임포트시켜줘야 한다. 1import numpy as np 위처럼 입력하면 Numpy의 임포트가 된다. 뒤의 as np를 빼고 나머지만 입력해도 되지만, 앞으로 사용할 코드에서 조금 더 편히 사용하기 위하여(그리고 관례적으로) as np를 작성해 준다. Numpy배열 생성 및 둘러보기 Numpy는 기본적으로 array라는 자료구조를 사용하기때문에 배열을 생성하는 방법에 대해 먼저 알아두어야 한다. 1234arr1 = [1,2,3]my_array1 = np.array(arr1)print(my_array1)print(my_array1.shape) Output: [1 2 3] (3,) 위의 출력 중 첫째줄은 arr1의 배열을 그대로 my_arrary1로 가져와 출력한 것이고, 둘째 줄은 가져온 배열의 길이를 튜플로 나타낸 것이다. 값 뒤에 콤마(,)가 붙어있는 이유는 값이 하나만 존재할 때, 튜플은 값 뒤에 콤마가 있어야 하기 때문이다. 다음은 2차원 배열일떄의 예제이다. 1234my_array3 = np.array([[2,4,6],[8,10,12],[14,16,18],[20,22,24]])print(my_array3)print(my_array3.shape)print(my_array3.dtype) Output: [[ 2 4 6] [ 8 10 12] [14 16 18] [20 22 24]] (4, 3) int64 먼저 세개의 출력 중 첫번째로 my_array3의 값인 리스트들이 차례로 나열되며, 그 다음으로는 배열의 (행, 열)의 수, 마지막으로 배열내의 요소의 데이터타입을 출력한다. 마지막으로 3차원 배열일때의 예제이다. 12my_array5 = np.array([[[1, 2], [3, 4],[5, 6]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3, 2) 세려는 양(또는 각각) 배열의 수가 대칭일때의 예제이다, 가장 바깥쪽의 배열부터 순서대로 배열의 수를 출력한다.그렇다면 대칭이 아니라면 어떻게 출력될까? 다음을 살펴보자 12my_array5 = np.array([[[1, 2], [3, 4], [5, 6, 7]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3) 출력과 동시에 에러(위 출력창에서는 삭제함)가 뜨는데 추측하기론 양쪽 배열이 대칭이 아니기에 양 배열의 길이가 같은 두번째 항목까지는 출력되나 2와 3으로 갈리는 마지막 항목에서 출력이 안되는것 같다.확실하지않으니 참고만… Numpy의 기본 함수들 Numpy는 여러 함수들을 사용할수 있다, 하지만 함수의 종류가 너무 많기 때문에 이 챕터에서는 기본적인 함수들만 알아보도록 한다. arange arange는 배열을 만들어주는 함수이다.arange([시작],끝,[만큼 건너뜀])으로 작성 할 수 있으며 []안의 항목은 생략 할 수 있다. 12arrange_array = np.arange(3, 13, 2)arrange_array Output: array([ 3, 5, 7, 9, 11]) 3부터 시작해서 12(13-1)까지 출력하며 2씩 건너뛰는 배열을 생성하는 arange예제이다. zeros, ones zeros와 ones는 0또는 1로 초기화된 shape* 차원의 ndarray** 배열 객체를 반환한다.두 함수 모두 객체 생성시 데이터 타입은 float64형식이다.*shape : 행열의 차원**ndarray : N차원의 배열객체. 기존파이썬과는 다르게 ndarray는 오직 같은 종류의 데이터만을 배열에 담을 수 있다. 1234zeros_array = np.zeros((3,2))print(zeros_array)print(&quot;Data Type is:&quot;, zeros_array.dtype)print(&quot;Data Shape is:&quot;, zeros_array.shape) Output: [[0. 0.] [0. 0.] [0. 0.]] Data Type is: float64 Data Shape is: (3, 2) 순서대로 배열, 데이터 타입, 데이터의 차원을 출력한다. 1234ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is:&quot;, ones_array.dtype)print(&quot;Data Shape is:&quot;, ones_array.shape) Output: [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is: int32 Data Shape is: (3, 4) 같은 순서로 항목들을 출력했고 배열생성시 데이터 타입을 바꿀수 있음을 보여주는 예제이다. reshape reshape는 구조를 재배열해주는 함수이다. 배열명.reshape(차원, 차원)으로 사용할 수 있다. 1234# 위에서 만들어진 3 x 4 배열의 ones_array를 reshape하여 2 x 6로 재배열after_reshape = ones_array.reshape(2,6)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] Data Shape is: (2, 6) reshape를 통해서 3x4 배열을 2x6으로 재배열 해준 가장 기본적인 예제이다. 재배열하려는 배열이 3x4 라면 3x4를 곱해서 나오는 값인 12의 인수들로 12의 결과가 나오는 배열((1,12), (2,6), (4,3))들로 바꿀 수 있으며, (2,2,3)등과 같은 3차원배열로도 재배열이 가능하다. reshape의 값에 -1을 넣는다면? 그렇다면 reshape의 괄호 차원값에 -1을 넣는다면 어떻게될까?다음 결과를 보자. 12after_reshape2= ones_array.reshape(-1,6)print(after_reshape2) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] -1을 작성한 곳에 12에서 나머지(두번째 값인 6)값을 보고 첫번째 값은 알아서 2로 지정이 된 것이다.다음은 값이 -1 하나일 때의 예제이다. 12after_reshape2= ones_array.reshape(-1)print(after_reshape2) Output: [1 1 1 1 1 1 1 1 1 1 1 1] 결과와 같이 1차원 배열로 바뀐다. 하지만 (12)일뿐, 2차원 배열인 (1,12)과는 같지 않다. Numpy 인덱싱과 슬라이딩 Numpy의 배열에도 값을 추출 할 수 있게 인덱싱과 슬라이딩이 가능하다. 1234my_array2 = np.arange(start=3,stop=30,step=3)my_array2 = my_array2.reshape(3,3)my_array2[1:3,:] Output: array([[12, 15, 18], [21, 24, 27]]) 출력에서 첫번째 인자는 1에서 2(3-1)번째 까지의 배열을 출력하고, 두번째 인자인 :은 첫번째 인자에서 지목된 배열의 항목을 모두 출력하는 것이다. Numpy 정렬 여러 값이 모여있는 array인 만큼 정렬도 가능하다. 이 챕터에서는 오름,내림차순으로 정렬해주는 sort(), 값이 낮은 순서대로 인덱스를 배정해 배열을 출력해주는 argsort()가 있다. sort() 12345height_arr = np.array([174, 165, 180, 182, 168])sorted_height_arr = np.sort(height_arr)print('Height Matrix: ', height_arr)print('np.sort() Matrix: ', sorted_height_arr) Output: Height Matrix: [174 165 180 182 168] np.sort() Matrix: [165 168 174 180 182] 결과에서 보이다시피 sort()함수는 배열내의 값을 오름차순으로 정렬해준다. 내림차순으로 정렬을 하고 싶다면 다음과 같이 하면 된다. 12desc_sorted_height_arr = np.sort(height_arr)[::-1]print('np.sort()[::-1] : ', desc_sorted_height_arr) Output: np.sort()[::-1] : [182 180 174 168 165] 위처럼 정렬을 할 때 sort()의 뒷부분에 [::-1]을 붙여주면 된다. argsort() 123456fives = np.array([10, 5, 15, 20])fives_order = fives.argsort()print(&quot;The original data&quot;, fives)print(&quot;The argsort(): &quot;, fives_order)print(&quot;The asending:&quot;, fives[fives_order]) Output: The original data [10 5 15 20] The argsort(): [1 0 2 3] The asending: [ 5 10 15 20] 출력의 첫번째 줄은 가장 처음 입력했던 일반적인 배열이다.두번째 줄은 오름차순으로 인덱스를 매긴 배열이며,마지막은 두번째줄의 배열에 따라 첫번째줄의 결과인 배열을 정렬한 것이다.","link":"/2021/11/06/NumPy-Basic-Grammar-1/"},{"title":"캐글 데이터 시각화 해석-1","text":"임포트 및 데이터프레임 추가 1234567891011121314151617# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only &quot;../input/&quot; directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using &quot;Save &amp; Run All&quot; # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session 12from plotly.offline import plot, iplot, init_notebook_modeinit_notebook_mode(connected=True) 123456789101112import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport plotly.express as pximport plotly.graph_objects as gofrom warnings import filterwarningsfilterwarnings('ignore')colors = ['#B1EDED','#B1B2ED','#1DE7ED','#1DA5ED','#1D50ED','#16548E']df = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv')df.head() 원 그래프 해석 1234567891011fig = go.Figure( data=[ # 그래프의 형태를 나타내는 함수 go.Pie( # 원그래프 labels = df['Q2'][1:].value_counts().index, # 값에 붙일 이름 - df['Q2'][1:].value_counts()의 인덱스 values = df['Q2'][1:].value_counts().values, # 나타낼 값 - df['Q2'][1:].value_counts()의 값 textinfo = 'label+percent')]) # 그래프 항목당 나타낼 텍스트 (여기서는 항목명, 비율)fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인지fig.update_layout( # 그래프의 레이아웃 설정 title_text='Gender Distribution', # 그래프의 제목 showlegend=False) # 범례표시여부fig.show() 그래프 코드 해석 123456fig = go.Figure(data=[ go.Pie( labels = df['Q2'][1:].value_counts().index, values = df['Q2'][1:].value_counts().values, textinfo = 'label+percent' )]) fig = go.Figure(data=[-&gt; 그래프의 기본적인 틀을 설정하는 함수이고, fig에 데이터를 부여해준다. go.Pie(-&gt; 그래프의 형태가 파이모양(원그래프)임을 의미한다. labels = df['Q2'][1:].value_counts().index-&gt; 그래프로 표현될 값에 붙일 이름이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스(질문열을 제외하기 위함) 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 인덱스열 인 것이다. values = df['Q2'][1:].value_counts().values-&gt; 그래프로 표현될 값이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 값(각 값을 카운트한 값) 이다. textinfo = 'label+percent'-&gt; 그래프에 표시된 항목에 나타낼 텍스트를 설정한다. 이 코드에서는 항목명(label)과 비율(percent)을 나타낸다. 123456fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인가를 설정fig.update_layout( # 그래프의 부가정보 설정 title_text='Gender Distribution', # 그래프 제목 showlegend=False) # 범례표시여부fig.show() fig.update_traces(-&gt; 추가바람 marker=dict(colors=colors[2:]))-&gt; 그래프의 색상을 설정한다. 이 코드에서는 위에서 설정된 colors 리스트에서 2번 인덱스부터 순서대로 사용한다. fig.update_layout(-&gt; 그래프의 부가정보를 설정한다. title_text='Gender Distribution'-&gt; 그래프의 제목을 설정한다. showlegend=False)-&gt; 범례의 표기여부를 결정한다. 이 코드에서는 False이므로 범례가 표기되지 않는다. fig.show()-&gt; 화면에 그래프를 표시하는 기능을한다. 몇몇에디터에서는 자동으로 표시되기때문에 호출할 필요가 없는 경우가 있다. 막대그래프 해석 12345678910111213141516171819202122232425262728293031man = df[df['Q2'] == 'Man']['Q1'].value_counts() # 성별이 남성[df['Q2'] == 'Man']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.woman = df[df['Q2'] == 'Woman']['Q1'].value_counts() # 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.textonbar_man = [ # list comprehension = [(변수를 활용한 값) for (사용할 변수 이름) in (순회 할 수 있는 값)] round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] # for문을 사용하여 round함수의 계산을 하고 textonbar_man에 저장textonbar_woman = [ # list comprehension round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]# go = graph_objectsfig = go.Figure(data=[ go.Bar( # 막대그래프 name='Man', # 그래프로 나타낼 항목 x=man.index, # x축에 man의 인덱스 y=man.values, # y축에 man의 값 text=textonbar_man, # 막대의 값을 작성해줄 텍스트 marker_color=colors[2]), #막대 색 go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3])])fig.update_traces( texttemplate='%{text:.3s}%', # fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside') # 그래프상에서 값의 위치fig.update_layout( barmode='stack', # 막대의 형태 title_text='Age distribution by gender', # 그래프 제목 xaxis_title='Age', # x축 제목 yaxis_title='Counts') # y축 제목fig.show() 그래프 코드 해석 1234man = df[df['Q2'] == 'Man']['Q1'].value_counts()woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()textonbar_man = [ round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]textonbar_woman = [ round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] man = df[df['Q2'] == 'Man']['Q1'].value_counts()-&gt; 성별이 남성[df['Q2'] == 'Man]인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()-&gt; 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. textonbar_man = [round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_man에 저장한다. textonbar_woman = [round((uw/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_woman에 저장한다. 12345678910fig = go.Figure(data=[ go.Bar( name='Man', x=man.index, y=man.values, text=textonbar_man, marker_color=colors[2] ), go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3] )]) go.Bar(-&gt; 그래프의 모양이 막대모양임을 의미한다. name='Man', x=man.index, y=man.values,-&gt; 순서대로 막대의 이름, x축에는 man의 인덱스, y축에는 man의 값을 나타내라는 의미이다. text=textonbar_man, marker_color=colors[2]),-&gt; 각각 막대의 값을 작성해줄 텍스트, 막대의 색을 의미한다. 123456789fig.update_traces( texttemplate='%{text:.3s}%', textposition='inside')fig.update_layout( barmode='stack', title_text='Age distribution by gender', xaxis_title='Age', yaxis_title='Counts')fig.show()) texttemplate='%{text:.3s}%',-&gt; fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside'-&gt; 그래프상에서의 값의 위치를 설정한다. barmode='stack'-&gt; 막대의 형태를 표현한다. title_text='Age distribution by gender'-&gt; 그래프의 제목을 설정한다. xaxis_title='Age', yaxis_title='Counts'-&gt; 그래프의 x축 제목, y축 제목 몇몇 요소 확인법 print(type(데이터))-&gt; 데이터의 타입을 출력한다 데이터.head(),데이터.tail()-&gt; 데이터를 인덱스 순으로 출력한다. head는 처음부터 끝까지, tail은 반대로 출력하며 괄호안에 숫자를 입력하면 숫자만큼 출력한다. Referencesgo.Figure() propertiesupdate_traces() propertiesupdate_layout() propertiesshow() propertiesgo.Bar() properties","link":"/2021/11/08/Kaggle_Data_Visualization-1/"},{"title":"파이썬 시각화 기본","text":"파이썬 시각화의 기본 형태들 선 그래프로 시각화하기1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, ax = plt.subplots()ax.plot(dates, min_temperature, label = &quot;Min Temp&quot;)ax.plot(dates, max_temperature, label = &quot;Max Temp&quot;)ax.legend()plt.show() Output 위의 그래프에서 크기의 변화를 준 그래프1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))axes.plot(dates, min_temperature, label = 'Min Temperature')axes.plot(dates, max_temperature, label = 'Max Temperature')axes.legend()plt.show() Output fig와 axes 출력12print(fig)print(axes) Output Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) Matplotlib 선 그래프먼저 yfinance라이브러리를 사용하기 위해 설치를 한다. 1!pip install yfinance --upgrade --no-cache-dir 실행시 Collecting yfinance Downloading yfinance-0.1.64.tar.gz (26 kB) Requirement already satisfied: pandas&gt;=0.24 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.1.5) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.19.5) Requirement already satisfied: requests&gt;=2.20 in /usr/local/lib/python3.7/dist-packages (from yfinance) (2.23.0) Requirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.9) Collecting lxml&gt;=4.5.1 Downloading lxml-4.6.4-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl (6.3 MB) \u001b[K |████████████████████████████████| 6.3 MB 5.3 MB/s \u001b[?25hRequirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2.8.2) Requirement already satisfied: pytz&gt;=2017.2 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2018.9) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24-&gt;yfinance) (1.15.0) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (1.24.3) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2021.5.30) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (3.0.4) Building wheels for collected packages: yfinance Building wheel for yfinance (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for yfinance: filename=yfinance-0.1.64-py2.py3-none-any.whl size=24109 sha256=da9039df457bcaed01c34fcce5bc8ee52dcf33151b9275684543166937fa1286 Stored in directory: /tmp/pip-ephem-wheel-cache-qozcsm2m/wheels/86/fe/9b/a4d3d78796b699e37065e5b6c27b75cff448ddb8b24943c288 Successfully built yfinance Installing collected packages: lxml, yfinance Attempting uninstall: lxml Found existing installation: lxml 4.2.6 Uninstalling lxml-4.2.6: Successfully uninstalled lxml-4.2.6 Successfully installed lxml-4.6.4 yfinance-0.1.64 다음과 같이 출력되며 yfinace를 설치한다. yfinance를 임포트해주고 그로부터 데이터를 받아와 출력을 할수 있다. 123import yfinance as yfdata = yf.download('AAPL', '2019-08-01', '2020-08-01')data.info() Output [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB 다음과 같이 애플의 1년동안의 주가를 볼 수 있다. 데이터의 컬럼을 지목해서 열람하는것 역시 가능하다. 12ts = data['Open']print(ts.head()) Output Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 data에 담겨있는 애플의 주가정보 중 ‘Open’에 해당하는 전일 종가를 가장 앞쪽(.head())부터 출력한 것이다.애플주식이 이렇게 쌌었나 검색해보니 이게 맞다…. 방법 1. Pyplot API 12345678910111213# import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-11-01', '2021-11-01')ts = data['Open']plt.figure(figsize=(10,6))plt.plot(ts)plt.legend(labels=['Price'], loc='best')plt.title('Stock Market fluctuation of AAPL') plt.xlabel('Date') plt.ylabel('Stock Market Open Price') plt.show() Output [*********************100%***********************] 1 of 1 completed 이처럼 결과가 출력되지만 이 문법은 시각화를 처음배우는 초심자에게는 적합하지 않다고 한다.후술할 문법과 위 문법 모두 출력은 되나 이 문법은 객체지향이 아니기도 하고 상대적으로 복잡하기때문에 초심자의 경우에 헷갈릴수 있어 사용하지 않는다.구글링 했을때 객체.이 아닌 plt.으로 시작하는 애들이 있다면 그 코드는 스킵하는게 좋다. 방법 2. 객체지향 API 123456789101112131415from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figureimport matplotlib.pyplot as pltfig = Figure()import numpy as npnp.random.seed(6)x = np.random.randn(20000)ax = fig.add_subplot(111)ax.hist(x, 100)ax.set_title('Artist Layer Histogram')# fig.savefig('Matplotlib_histogram.png')plt.show() 이 방법에 대해서는 따로 언급이 없었기 때문에 바로 방법 3으로 넘어간다. 방법 3. Pyplot API + 객체지향 API 12345678910111213import yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-08-01', '2020-08-01')ts = data['Open']fig, ax = plt.subplots(figsize=(10, 6))ax.plot(ts)ax.set_title('Stock Market fluctuation of AAPL')ax.legend(labels=['Price'], loc='best')ax.set_xlabel('Date')ax.set_ylabel('Stock Market Open Price')plt.show() Output [*********************100%***********************] 1 of 1 completed 드디어 꼭 외우라고 하셨던 pyplot + 객체지향 API 방법이다.특히 7번째 행 부터 마지막까지가 중요한데 그에대한 설명은 아래에 표로 적겠다.중요하다 몇번을 강조하셨으니 위 코드는 변형을 해가며 여러번 작성해보자. 설명 표 코드 설명 fig, ax = plt.subplots() 데이터 전체적 외형을 설정하는 부분 ax.plot(ts) 데이터를 표현해주는 행 ax.set_title() 데이터 시각화의 제목 ax.legend() 범례 ax.set_xlabel() x축 데이터의 제목 ax.set_ylabel() y축 데이터의 제목 plt.show() 안해도 상관없으나 ‘완료후 게시’ 라는 뜻으로 작성 앞으로 나올 표의 내용도 표의 위에 있는 코드들과 적절히 섞어서 이해하길 바란다. 막대 그래프 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npimport calendarmonth_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]sold_list = [300, 400, 550, 900, 600, 960, 900, 910, 800, 700, 550, 450]fig, ax = plt.subplots(figsize=(10,6))plt.xticks(month_list, calendar.month_name[1:13], rotation=90)plot = ax.bar(month_list, sold_list)for rect in plot: print(&quot;graph:&quot;, rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.002*height,'%d' % int(height), ha='center', va='bottom')plt.show() Output graph: Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) graph: Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) graph: Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) graph: Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) graph: Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) graph: Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) graph: Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) graph: Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 메소드 설명 .xticks()는 x축의 눈금을 나타내는 메소드인데 기본적으로는 list자료형 한개을 사용한다.하지만 메소드에 인자가 ‘list’ 두 개로 받아졌을 경우,첫번째 list는 x축 눈금의 갯수가 된다.두번째 list는 x축 눈금의 이름이 된다.이 코드에서는 rotation 옵션도 들어가 있는데 이것은 그냥 이름을 몇도정도 기울일지 나타낸다.plot = ax.bar()는 그래프를 막대로 만든다.첫번째 리스트 인자의 수 만큼 막대가 생성되고,두번째 리스트 인자의 값 만큼 막대가 길어진다.이렇다보니 첫번째 리스트와 두번째 리스트의 인자의 수가 일치해야 에러가 나지 않는다.for문 내부의 ax.text()는 Seaborn-막대그래프-표현할 값이 한 개인 막대 그래프 챕터에 서술했으니 참고하길 바란다. 산점도 그래프 두개의 연속형 변수 (키, 몸무게 등) 상관관계 != 인과관계 나타내는 값이 한가지인 산점도 그래프 123456789101112131415import matplotlib.pyplot as pltimport seaborn as sns# 내장 데이터tips = sns.load_dataset(&quot;tips&quot;)x = tips['total_bill']y = tips['tip']fig, ax = plt.subplots(figsize=(10, 6))ax.scatter(x, y) # 각각의 값을 선으로 표현해주는 scatter()ax.set_xlabel('Total Bill')ax.set_ylabel('Tip')ax.set_title('Tip ~ Total Bill')fig.show() Output 나타내는 값이 두 가지인 산점도 그래프 12345678910111213label, data = tips.groupby('sex')tips['sex_color'] = tips['sex'].map({&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot;})fig, ax = plt.subplots(figsize=(10, 6))for label, data in tips.groupby('sex'): ax.scatter(data['total_bill'], data['tip'], label=label, color=data['sex_color'], alpha=0.5) ax.set_xlabel('Total Bill') ax.set_ylabel('Tip') ax.set_title('Tip ~ Total Bill by Gender')ax.legend()fig.show() Output 히스토그램 수치형 변수 1개 12345678910111213141516import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터 titanic = sns.load_dataset('titanic')age = titanic['age']nbins = 21fig, ax = plt.subplots(figsize=(10, 6))ax.hist(age, bins = nbins) # 여기서 bins = nbins는 히스토그램을 더 세밀하게 나누어 준다.ax.set_xlabel(&quot;Age&quot;)ax.set_ylabel(&quot;Frequency&quot;)ax.set_title(&quot;Distribution of Aae in Titanic&quot;)ax.axvline(x = age.mean(), linewidth = 2, color = 'r')fig.show() Output 코드 설명 .hist() 데이터를 히스토그램으로 표현해주는 메소드 .axvline() 데이터의 평균을 선으로 나타내주는 메소드 박스플롯 x축 변수: 범주형 변수, 그룹과 관련있는 변수, 문자열 y축 변수: 수치형 변수 12345678910111213import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset('iris')data = [iris[iris['species']==&quot;setosa&quot;]['petal_width'], iris[iris['species']==&quot;versicolor&quot;]['petal_width'], iris[iris['species']==&quot;virginica&quot;]['petal_width']]fig, ax = plt.subplots(figsize=(10, 6))ax.boxplot(data, labels=['setosa', 'versicolor', 'virginica'])fig.show() Output 수정바람) 정확히 어떻게 이 그래프가 출력되는지 모르기에 좀 더 공부후 수정할 것 히트맵 123456789101112131415import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터flights = sns.load_dataset(&quot;flights&quot;)flights = flights.pivot(&quot;month&quot;, &quot;year&quot;, &quot;passengers&quot;)fig, ax = plt.subplots(figsize=(12, 6))im = ax.imshow(flights, cmap = 'YlGnBu')ax.set_xticklabels(flights.columns, rotation = 20)ax.set_yticklabels(flights.index, rotation = 10)fig.colorbar(im)fig.show() Output year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 .. ... ... ... 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 [144 rows x 3 columns] 제목 제목 fig.colorbar() 값의 빈도 수에 대한 컬러바생성 Seaborn 산점도와 회귀선이 있는 산점도 산점도 12345678%matplotlib inline import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)sns.scatterplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips)plt.show() Output 회귀선이 있는 산점도 1234567891011121314fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(15, 5))sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[0], fit_reg = True)sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[1], fit_reg = False)plt.show() Output 위의 코드처럼 fit_reg = True로 해줄 경우 회귀선이 나타나는것을 알 수 있다.그리고 ax = ax[num]의 경우에는 그래프의 인덱스로 보인다. 히스토그램/커널 밀도 그래프 12345678910import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)plt.figure(figsize=(10, 6))sns.displot(x = &quot;tip&quot;, data = tips)sns.displot(x=&quot;tip&quot;, kind=&quot;kde&quot;, data=tips) # 종류 = 커널밀도 그래프(kde)sns.displot(x=&quot;tip&quot;, kde=True, data=tips) # 히스토그램에 kde를 넣을건가 = Trueplt.show() Output &lt;Figure size 720x432 with 0 Axes&gt; 박스플롯12345678#import matplotlib.pyplot as plt # 주석처리된 부분은 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. #import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.boxplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips)sns.swarmplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips, alpha = .25)plt.show() Output 막대 그래프1234567#import matplotlib.pyplot as plt # 이 주석 역시 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. 이하 기본주석이라 하고 생략한다.#import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.countplot(x = &quot;day&quot;, data = tips)plt.show() Output 'tips'Data의 'day'값, 인덱스별 정렬, 'tips'의 내림차순 재배치 123print(tips['day'].value_counts())print(&quot;index: &quot;, tips['day'].value_counts().index)print(&quot;values: &quot;, tips['day'].value_counts().values) Sat 87 Sun 76 Thur 62 Fri 19 Name: day, dtype: int64 index: CategoricalIndex(['Sat', 'Sun', 'Thur', 'Fri'], categories=['Thur', 'Fri', 'Sat', 'Sun'], ordered=False, dtype='category') values: [87 76 62 19] 'tips'Data의 'day'값에 대한 오름차순(ascending) 정렬 1print(tips['day'].value_counts(ascending=True)) Fri 19 Thur 62 Sun 76 Sat 87 Name: day, dtype: int64 표현할 값이 한 개인 막대 그래프 1234567# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, order = tips['day'].value_counts().index) # x축을 'day'로 지정, data는 'tips'로 채워넣음, 'day'의 값이 높은 순서대로 막대그래프 정렬 for p in ax.patches: # ax.patches = p height = p.get_height() # 아래행을 실행하기위해 막대그래프의 높이 가져옴 ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9) # 막대그래프 위 수치 작성ax.set_ylim(-5, 100) # y축 최소, 최대범위plt.show() Output 나중에 다시 본다면 조금 설명이 필요할 것 같다.특히 ax.text행의 인자가 조금 많은데 설명이 필요한 듯하다.직접 colab에서 이것저것 만져본 결과 추측하기로는 다음 표과 같은듯 하다. 코드 설명 p.get_x() + p.get_width()/2. 수치가 들어갈 x축 위지 height+3 y축 위치(현재 +3) height 수치의 값을 조절할 것인지(현재 +0) ha = ‘center’ 수치를 (x,y)축의 가운데로 정렬 size=9 폰트의 크기이다 여기서 혹시나 ha = 'center'부분이 잘 이해가 안될수 있다.내가그랬다ha =는 (x,y)축의 기준이 될 곳을 정하는 인자인듯 하다.center말고도 left,right등을 사용할수 있는데 막대의 기준에서 왼쪽,오른쪽이 아닌 텍스트의 기준에서 왼쪽,오른쪽이라 방향을 선택하면 오히려 반대로 배치되는것을 알 수 있다. 표현할 값이 두 개인 막대 그래프 123456789# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, hue = &quot;sex&quot;, dodge = True, order = tips['day'].value_counts().index)for p in ax.patches: height = p.get_height() ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9)ax.set_ylim(-5, 100)plt.show() Output 이 코드에서 첫째줄의 인자를 표로 나타내면 코드 설명 x = “day” x축이 나타낼 자료 data = tips 표현할 데이터셋 hue = “sex” 그래프로 표현할 항목 dodge = True 항목끼리 나눠서 표현할 것인지 order = tips[‘day’].value_counts().index ‘day’의 값이 높은 순서대로 그래프 정렬 sns.countplot() x축이 나타낼 자료, 나타낼 데이터셋, 그래프로 나타낼 항목, 항목끼리 나눠서 표현할것인지, ‘day’의 값이 높은 순서대로 막대그래프 정렬 상관관계 그래프 데이터 불러오기 및 행, 열 갯수 표시하기 12345678910import pandas as pd import numpy as np import seaborn as snsimport matplotlib.pyplot as pltmpg = sns.load_dataset(&quot;mpg&quot;)print(mpg.shape) # 398 행, 9개 열num_mpg = mpg.select_dtypes(include = np.number) # num_mpg에 'mpg' 데이터셋의 데이터타입 총갯수를 입력한다(숫자형 데이터타입만 포함)print(num_mpg.shape) # 398 행, 7개 열 (두개가 사라진 이유는 number타입이 아닌 Object타입이기 때문) (398, 9) (398, 7) 데이터셋의 컬럼 표시 1num_mpg.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 398 entries, 0 to 397 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 mpg 398 non-null float64 1 cylinders 398 non-null int64 2 displacement 398 non-null float64 3 horsepower 392 non-null float64 4 weight 398 non-null int64 5 acceleration 398 non-null float64 6 model_year 398 non-null int64 dtypes: float64(4), int64(3) memory usage: 21.9 KB 데이터셋 컬럼간의 상관관계 표시 1num_mpg.corr() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mpg cylinders displacement horsepower weight acceleration model_year mpg 1.000000 -0.775396 -0.804203 -0.778427 -0.831741 0.420289 0.579267 cylinders -0.775396 1.000000 0.950721 0.842983 0.896017 -0.505419 -0.348746 displacement -0.804203 0.950721 1.000000 0.897257 0.932824 -0.543684 -0.370164 horsepower -0.778427 0.842983 0.897257 1.000000 0.864538 -0.689196 -0.416361 weight -0.831741 0.896017 0.932824 0.864538 1.000000 -0.417457 -0.306564 acceleration 0.420289 -0.505419 -0.543684 -0.689196 -0.417457 1.000000 0.288137 model_year 0.579267 -0.348746 -0.370164 -0.416361 -0.306564 0.288137 1.000000 상관관계 히트맵 1234567891011fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]sns.heatmap(num_mpg.corr(), ax=ax[0])ax[0].set_title('Basic Correlation Heatmap', pad = 12) # 상관관계 수치 그래프 [Correlation Heatmap with Number]sns.heatmap(num_mpg.corr(), vmin=-1, vmax=1, annot=True, ax=ax[1])ax[1].set_title('Correlation Heatmap with Number', pad = 12)plt.show() Output 위의 코드에서 pad는 히트맵과 타이틀의 간격설정이며,set_title의 인자를 설명하면 (히트맵을 만들 ‘데이터셋.corr()’, 히트맵의 최소값, 최대값, 수치표현(bool값), 마지막인자는 확실하지는 않지만 앞의 히트맵 설정을 어떤 히트맵에 적용시킬지 묻는것 같다.) 상관관계 배열 만들기 1234# import numpy as np# 윗단 코드에서 만들어진 num_mpg 사용print(int(True))np.triu(np.ones_like(num_mpg.corr())) 1 array([[1., 1., 1., 1., 1., 1., 1.], [0., 1., 1., 1., 1., 1., 1.], [0., 0., 1., 1., 1., 1., 1.], [0., 0., 0., 1., 1., 1., 1.], [0., 0., 0., 0., 1., 1., 1.], [0., 0., 0., 0., 0., 1., 1.], [0., 0., 0., 0., 0., 0., 1.]]) np.triu(배열, k=0)는 위 결과처럼 우하향 대각선이 있고 위 아래로 삼각형이 있다 생각했을때 아래쪽의 삼각형이 모두 0이 되는 함수이다.k의 숫자가 낮아질수록 삼각형은 한칸씩 작아진다.위 결과에서 행과 열이 7칸이 된 이유는 np.ones_like(num_mpg.corr())의 행이 7개 이기때문인듯 하다.확실히 모르겠음 질문 필수 12mask = np.triu(np.ones_like(num_mpg.corr(), dtype=np.bool))print(mask) [[ True True True True True True True] [False True True True True True True] [False False True True True True True] [False False False True True True True] [False False False False True True True] [False False False False False True True] [False False False False False False True]] k 값을 바꿔 True와 False로 값을 준 경우. 12345678910# 기본주석 생략fig, ax = plt.subplots(figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]ax = sns.heatmap(num_mpg.corr(), mask=mask, vmin=-1, vmax = 1, annot=True, cmap=&quot;BrBG&quot;, cbar = True)ax.set_title('Triangle Correlation Heatmap', pad = 16, size = 16)fig.show() Output 위의 글들을 모두 읽었음에도 단 하나 모르는 요소가 있다면 바로 cmap일 것이다.cmap은 colormap을 줄인것으로 cmap의 종류는 상당히 많다.이곳에 가면 상당히 잘 정리되어 있으니 cmap옵션을 사용할 때마다 요긴하게 쓸 수 있을것이다. Intermediate페가블로그 코드 https://jehyunlee.github.io/2020/08/27/Python-DS-28-mpl_spines_grids/ 이 챕터의 내용은 코드가 너무 긺으로 시각화 결과물을 접지않고 코드를 접는형식으로 서술하겠음. 필수 코드이므로 생략을 생략 1234import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as np Code 12345678910111213141516171819202122232425262728def plot_example(ax, zorder=0): ax.bar(tips_day[&quot;day&quot;], tips_day[&quot;tip&quot;], color=&quot;lightgray&quot;, zorder=zorder) ax.set_title(&quot;tip (mean)&quot;, fontsize=16, pad=12) # Values h_pad = 0.1 for i in range(4): fontweight = &quot;normal&quot; color = &quot;k&quot; if i == 3: fontweight = &quot;bold&quot; color = &quot;darkred&quot; ax.text(i, tips_day[&quot;tip&quot;].loc[i] + h_pad, f&quot;{tips_day['tip'].loc[i]:0.2f}&quot;, horizontalalignment='center', fontsize=12, fontweight=fontweight, color=color) # Sunday ax.patches[3].set_facecolor(&quot;darkred&quot;) ax.patches[3].set_edgecolor(&quot;black&quot;) # set_range ax.set_ylim(0, 4) return axdef major_formatter(x, pos): return &quot;{%.2f}&quot; % xformatter = FuncFormatter(major_formatter) 123tips = sns.load_dataset(&quot;tips&quot;)tips_day = tips.groupby(&quot;day&quot;).mean().reset_index()print(tips_day) day total_bill tip size 0 Thur 17.682742 2.771452 2.451613 1 Fri 17.151579 2.734737 2.105263 2 Sat 20.441379 2.993103 2.517241 3 Sun 21.410000 3.255132 2.842105 Code 12fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2) Code 123456fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False) Code 12345678910fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) Code 12345678910111213fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) ax.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;) 책 코드 Code 12345678910111213141516import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0]) Code 12345group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)print(&quot;The Best Day:&quot;, h_day)print(&quot;The Highest Avg. Total Biil:&quot;, h_mean) The Best Day: Sun The Highest Avg. Total Biil: 21.41 Code 1234567891011121314151617181920212223tips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)fig.show() Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)fig.show() Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)ax0.set_xlabel(&quot;Weekday&quot;, fontsize=14)for xtick in ax0.get_xticklabels(): print(xtick) if xtick.get_text() == h_day: xtick.set_color(&quot;darkred&quot;) xtick.set_fontweight(&quot;demibold&quot;)ax0.set_xticklabels(['Thursday', 'Friday', 'Saturday', 'Sunday'], size=12)ax1 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, alpha=0.85, ax=ax[1])for p in ax1.patches: height = np.round(p.get_height(), 2) ax1.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12)ax1.set_ylim(-3, 30)ax1.set_title(&quot;Just Bar Graph&quot;)plt.show() Text(0, 0, 'Thur') Text(0, 0, 'Fri') Text(0, 0, 'Sat') Text(0, 0, 'Sun')","link":"/2021/11/03/python_visualization_basic_/"},{"title":"파이썬(Python) 사용자 지정 함수","text":"사용자 지정 함수란? 파이썬에서(다른프로그래밍 언어, 스크립트 언어에서도) 함수란, 소프르웨어에서 특정 동작을 수행하는 일정 코드부분을 의미한다. 하나의 큰 프로그램을 여러부분으로 나누어주기 때문에 같은 함수를 여러 상황에서 여러차례 호출할 수 있고, 일부분을 수정하기 쉽다는 장점을 지닌다. 파이썬에서는 미리 정의 되어있는 built in 함수(내장함수)가 있고. 또, 사용자가 필요에 의해 정의를 한 사용자 지정 함수가 존재한다. 파이썬에서의 함수 모형 파이썬 함수의 기본 모형1234def 함수명() : 실행문 실행문 ... 이와 같은 구조인데 함수를 정의하는 def뒤에 함수명이 오고 소괄호()를 붙인 다음 콜론:을 붙여주고, 다음줄에 원하는 실행문을 들여쓰기하여 사용하면 된다. 12def func() : print('python function') 위는 기본 모형을 응용하여 함수를 정의한 것이다. 이는 입력값도, 반환값도 없는 함수이며 값이 있는 함수에 대해서는 후술하겠다. 그러나 위 코드는 함수를 정의한 것이지 사용을 한 것이 아니다. 그렇기 때문에 함수를 사용하기 위해서는 함수의 사용법을 알아야 한다. 12345def func() : print('python function')#함수 호출func() Output 1python function func()함수는 입력값이 없기때문에 호출시에 입력값을 넣어주지 않고 괄호만 입력해 준다. 입력값만 있는 함수 123456def func2(a) : print('입력한 문자는 ' + a + ' 입니다.')func2(&quot;비행기&quot;)func2(&quot;자동차&quot;)func2(&quot;파이썬&quot;) Output 123입력한 문자는 비행기 입니다.입력한 문자는 자동차 입니다.입력한 문자는 파이썬 입니다. func2()함수의 입력값이 a 에 입력되어 출력 된 것을 볼 수 있다. 리턴값만 있는 함수 1234def func3() : return &quot;12345&quot;print(func3()) Output 112345 func3()의 값이 리턴되어 print()를 통해 출력된 것을 알 수 있다. 입력,리턴값이 모두 있는 함수 1234def func4(a, b) : return a + bprint(func4(10,20)) Output 130 a,b의 입력값을 더하는 함수에 10,20의 값을 주었더니 예상대로 30이 출력 되었다. 기본 인자 값 입력이 있는 함수를 여러 곳에 사용할 때 반복되는 값에 대해서는 기본적인 값을 지정할 수 있다.기본값은 입력 = 값의 형태로 작성된다. 12345def func_b(a,b,c=5) : return a*b+cprint(func_b(2,3,10))print(func_b(2,3)) Output 121611 출력에서처럼 기본값이 주어진 c 인자에 별다른 값을 넣지 않으면 기본값 5로 계산되어 10이들어간 결과보다 5가 낮아지게 된다. 이렇게 기본 인자를 줄 때는 주의 할 점이 한 가지 있는데 바로 인자의 순서에 맞게 넣어주어야 한다는 것과, 기본값과 입력값이 없으면 에러가 난다는 것이다.다음 예시를 보자. 1234def func_b2(a,b=5,c) : return a*b+cprint(func_b2(2,3)) 위와 같이 값을 주게 된다면 어떨까?b에 기본값이 있으니 a와 c에 각각 2와 3이 입력된다고 생각한 사람도 있을 것이다.그러나 이 생각은 적어도 사용자 지정 함수에서는 옳지 않다. 이 코드가 불가능한 데에는 두 가지 이유가 있다. 첫 번째로는 a에는 2가 들어가는 것이 맞겠지만, b에 기본값이 있더라도 두 번째 입력값 자리에 3을 넣게 되는 순간 그 숫자는 b에 입력되기 때문에 결국엔 기본값이 없는 c는 어떠한 값도 입력받지 못하게 되기 때문이고, 두 번째 이유로는 c의 인자에 기본값이 없음에도 앞에 있는 b의 인자에 기본값이 있으므로 아예 성립할 수 없는 코드이다.그러므로 기본값을 부여받은 인자는 항상 뒤에 배치해야 한다. 키워드 인자 키워드 인자는 함수를 정의할때 인자에 키워드를 부여하고 함수를 호출할 때 키워드=값의 형태로 넣어줄 수 있는 인자이다.그냥 인자에 값을 넣어주는것과 뭐가 다르냐?라는 의문이 들 수도 있다.다음 예시를 보자. 1234def score(kim=100, lee=100, park=100, choi=100) : print('score = kim :', kim, 'lee :',lee, 'park :',park, 'choi :',choi)score(park= 50) Output 1score = kim : 100 lee : 100 park : 50 choi : 100 이렇게 중간의 인자만 키워드=값의 형태로 입력해 값을 변경해 줄 수 있다.예제처럼 여러 기본값이 있고 그중 몇 가지의 기본값만 바꿔 주어야 할 때 용이하게 쓸 수 있다. Arbitrary Argument Lists (임의 인자 리스트) Arbitrary Argument Lists는, 여러인자를 함수에 잔달하는 방법들중 하나이다. 함수내부에서 이 인자들은 튜플로 감싸져있으며 이는*argsarguments 생성자를 사용하여 정의 된다. 12345678910def avg_score(*numbers) : s = 0 count = 0 for i in numbers: s += i count += 1 return s / countprint('국어와 수학점수의 평균은{}점 입니다'.format(avg_score(95, 87)))print('입력된 숫자들의 평균은{} 입니다.'.format(avg_score(42,63,45,32,48))) Output 12국어와 수학점수의 평균은91.0점 입니다입력된 숫자들의 평균은46.0 입니다. 위 코드에서는 *args를 *numbers로 대체했다.이처럼 함수를 호출 할 때에 숫자를 몇가지를 넣어도 사용이 가능하다. Lambda 함수 우리가 앞에서 배웠던 대로 사용자 지정 함수를 정의하고 사용하여 평균을 구하라고 한다면 아마 다음과 같을것이다. 12345def avg(x,y): return(x + y) / 2print(avg(5,13))&gt;&gt; 9.0 그러나 파이썬은 Lambda함수를 통해서 이 코드를 더욱 짧게 줄일수 있다. 123print((lambda x,y: (x + y)/2)(5,13))&gt;&gt; 9.0 그러나 배우는 입장인 내 눈으로 단점을 찾아보자면 함수인데 정의를 하는 부분이 따로 없다 보니, 출력할 일이 여러 번 생긴다면 번거로워 질 것 같다.그러니 앞으로 호출 횟수에 따라 적다면 람다 함수를, 많다면 기본적인 사용자 지정 함수를 사용하는 방식이 좋을 듯하다. References https://djangojeng-e.github.io","link":"/2021/11/10/Python-UserDefinedFunctions/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"pandas","slug":"pandas","link":"/tags/pandas/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Install","slug":"Install","link":"/tags/Install/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/tags/Data-Visualization/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"Kaggle","slug":"Kaggle","link":"/tags/Kaggle/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Grammar","slug":"Grammar","link":"/tags/Grammar/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"pandas","slug":"pandas","link":"/categories/pandas/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/categories/Data-Visualization/"}]}