{"pages":[],"posts":[{"title":"Hexo로 깃허브 블로그 만들기","text":"Hexo란?Hexo는 Node.js기반의 정적 블로그 프레임워크 입니다. Markdown으로 문서를 작성하고 빌드시 정적 HTML이 생기고이것을 GitHub pages에 배포 하여 블로그를 관리 합니다. 설치환경 Git Node.js 파이참(PyCharm) GitHub 계정 설치환경 확인 아래 코드로 Node.js 설치를 확인해봅니다.1$ node -v 아래 코드로 Git 설치를 확인합니다.1$ git --version npm을 통해 hexo를 전역으로 설치합니다.1$ npm install -g hexo-cli GitHub 블로그 만들기먼저 원하는 디렉토리로 이동하여 헥소 블로그 디렉토리를 만들어줍니다.(이 포스팅에서는 myblog)1$ hexo init myblog 생성된 디렉토리를 우클릭 한 뒤‘Open Folder as PyCharm Community Edition Project‘를 클릭해 파이참으로 열어줍니다. 실행된 파이참의 좌측 아래에서 터미널 메뉴를 선택하고 사진과같이 Git Bash를 클릭해주면파이참에서 Git을 사용할 수 있게 됩니다. 이후 Git에서 다음 명령어들을 입력해줍니다 123$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save 이제 GitHub 접속하고 우측 상단의 아이콘 클릭 후 ‘Your repositories‘에 들어갑니다.Repository name 란에 만들었던 디렉토리와 같은 이름인 ‘myblog’를 넣은 후 아무것도 건드리지 않고 아래의 ‘Create repository’ 버튼을 눌러줍니다. 다시 파이참으로 돌아와서 아래의 Git 명령어들을 입력해줍니다. 1234567echo &quot;# myblog&quot; &gt;&gt; README.mdgit initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/cincu4221/myblog.gitgit push -u origin main GitHub에서 ‘myblog‘ 리포지토리를 만들때와 이름만 다르게 ‘사용자계정명.github.it‘ 으로 바꾸어서 리포지토리를 하나 더 생성해 줍니다. 파이참의 작업영역에서 _config.yml 파일을 열어서 수정해줍니다. 블로그 정보 설정1234title: blog titlesubtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그의 URL정보 설정1234url: https://Username.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 설정12345# Deploymentdeploy: type: git repo: https://github.com/Username/Username.github.io.git branch: main 위의 코드에서 Username으로 되어있는것은 꼭 사용자의 GitHub계정명으로 바꿔주셔야 합니다. 파이참의 Git Bash(Terminal)에 다음 코드들을 입력합니다. 12$ hexo generate$ hexo server 이후 나오는 localhost:4000에서 화면이 뜨는지 확인합니다. 다음 코드를 입력해 최종적으로 배포를 진행합니다. 1$ hexo deploy 배포가 완료되면 브라우저에서 [USERNAME.github.io]로 접속해 정상적으로 배포되었는지 확인합니다. * 참고 : https://dschloe.github.io/settings/hexo_blog/","link":"/2021/10/28/make_github_blog/"},{"title":"윈도우에서 Git 설치하기","text":"다운로드 먼저 Git홈페이지에서 Download for Windows을 클릭해 자신의 윈도우 버전에 맞는 Git을 다운로드 해준다. Git 홈페이지 윈도우 버전에 맞는 Git이 알아서 다운로드된다. 설치 설치파일을 실행시키면 항상 보는 약관페이지가 나온다. Next를 눌러 넘어간다. 설치경로를 정해주고 Next 설치할 Component 들을 선택하는 창이다. 기본으로 선택되어 있는것만 선택하고 Next를 눌러 넘어간다. 시작메뉴에 폴더를 생성하는 창이다. 폴더를 추가하고 싶지 않다면 아래에 있는 Don't create a Start Menu folder 체크박스를 클릭하고 Next를 눌러준다. Git의 기본 에디터를 설정하는 창이다. 이번에도 기본으로 선택되어있는 항목을 고르고 Next를 눌러 넘어간다. 선택되어있는 Let Git decide를 고르고 Next를 누른다. 환경변수 옵션 설정이다. Git from the Command line and also from 3rd-party software를 선택하고 Next Use bundled OpenSSH를 선택한채로 Next를 누른다. https 전송시 인증서 선택. Use the OpenSSL library을 선택 후 Next Checkout Windows style, commit Unix-style line endings을 선택하고 Next Git Bash 터미널의 형식. Use MinTTY를 선택하고 넘어갑니다. Git pull 작업방식. Default로 설정해주고 Next를 누른다. Credential Helper 사용에 대한 선택. Git Credential Manager Core선택 후 Next 기타 실행옵션. 필자는 Enable file system caching만 체크 후 넘어갔다. 모든 옵션에 체크를 완료하고 설치가 진행되는 모습. 설치가 완료되면 위와 같은 창이 뜬다. 설치 확인 자 이제 설치가 잘 되었는지 확인할 차례이다.윈도우에 cmd를 검색해 명령 프롬프트를 실행한다.아무것도 하지않은채로 git 을 입력한다. 입력하면 위 사진처럼 Git의 명령어가 나오면서 설치가 완료된걸 확인 할 수 있다.","link":"/2021/10/29/setting_Git/"},{"title":"파이썬(Python) 기본 문법 - 1","text":"이 포스트는 필자의 정확한 파이썬 문법을 익히고 필요할때 찾아보기 위해 서술한 것이다. Hello World 어떤 프로그래밍언어든 배우기 시작하면 출력하고 보는 Hello world, 파이썬에서는 다음과 같이 출력한다. 1print(&quot;Hello, world!&quot;) Output: Hello, world! 당연하게도 Hello, world 이외의 다른 문장이 들어가면 그대로 출력되며print() 에서 괄호 내부에 출력을 해주고싶은 변수나 문장을 입력하면 된다, 문장의 경우는 따옴표로 묶어줘야 출력이 된다. 주석처리 접기 / 펼치기 프로그래밍 언어마다 주석처리를 해주는 방법이 다르다, 파이썬의 경우에는 다음과 같이 주석처리한다. 1234567# 한줄을 주석처리하는 방법입니다.&quot;&quot;&quot;여러줄을한번에 주석처리하는방법입니다.&quot;&quot;&quot;print(&quot;Hello, world!&quot;) Output: Hello, world! 위처럼 작성하고 실행시키면 나머지 줄은 모두 주석처리되고 가장 아랫줄인 Hello, world만 출력이 되는걸 볼 수 있다. 변수의 종류 접기 / 펼치기 변수(Variable)는 (문자나 숫자 같은) 값을 담는 컨테이너로 값을 유지할 필요가 있을 때 사용한다. 여기에 담겨진 값은 다른 값으로 바꿀 수 있다. 변수는 마치 (사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다. 출처 : 생활코딩 - 변수 다른 프로그래밍언어와 같이 파이썬 역시 다양한 변수의 종류(타입)가 있는데 이번 단락에서는 그것에 대해 알아보겠다. int타입 (정수형)12num_int = 1print(type(num_int)) 변수에 값을 정수로 주고 그 변수의 타입을 알아본 예제, 출력을 하게되면 &lt;class 'int'&gt;가 줄력된다. float타입 (실수형)12num_float = 0.2print(type(num_float)) 변수에 값을 실수로 주고 그 변수의 타입을 출력한 예제, 출력을 하게되면 &lt;class 'float'&gt;가 출력된다. bool타입 (논리형)12bool_true = Trueprint(type(bool_true)) 변수에 값을 논리타입(True or False)으로 주고 그 변수의 타입을 출력한 예제, 출력하면 &lt;class 'bool&gt;이 출력된다. None타입12none_x = Noneprint(type(none_x)) Null을 나타내는 자료형이다, None라는 한가지 값만 가질 수 있다. (왜 필요한지는 아직 모르겠다) 사칙연산 접기 / 펼치기 파이썬에서의 사칙연산은 일반적인 사칙연산과 같다.그리고 나눈후 정수의값만 구하는 //, 나머지를 구하는 %, 거듭제곱을 뜻하는 ** 등의 연산자가 있다. 123456789a = 3b = 2print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) Output: a + b = 5 a - b = 1 a * b = 6 a / b = 1.5 a // b = 1 a % b = 1 a ** b = 9 위처럼 각각 계산이 된걸 알 수 있다. 정리하면 아래와 같다 연산자 내용 + 두 변수의 합을 계산 - 두 변수의 차를 계산 * 두 변수의 곱을 계산 / 두 변수로 나눈 결과를 float 형으로 반환 // 두 변수로 나눈 결과에서 정수 부분만 취함 % 두 변수로 나눈 결과에서 나머지 값만 가져옴 ** i**j일 경우, i의 j만큼 제곱하여 계산 (예: 2 ** 4 = 24 = 16) 논리형 연산자 접기 / 펼치기 논리형 연산자에는 and 와 or이 있다.and연산자는 두 조건이 모두 참일때 True가 되며 or의 경우 두 조건중 하나라도 참일때 True가 된다. and연산자1234print(True and True)print(True and False)print(False and True)print(False and False) Output: True False False False 위 결과처럼 두 조건 모두 참일때만 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False False False True False False False False or 연산자1234print(True or True)print(True or False)print(False or True)print(False or False) Output: True True True False 위 결과처럼 두 조건 중 하나만 참이라도 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False True False True True False False False 비교 연산자 접기 / 펼치기 비교 연산자에는 &gt;,&lt;,&gt;=,&lt;=이 있다.일단, 예제를 보자. 1234print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3) Output: True False True False 예제처럼 결과는 논리타입으로 출력된다. 문자열 연산 접기 / 펼치기 정수나 실수 논리타입뿐만 아니라 문자열도 연산이 가능하다.다만 문자열을 뒤에 덧붙이는+연산자, 문자열을 횟수만큼 반복해주는*연산자만 사용이 가능하다. 123str1 = &quot;Python &quot;str2 = &quot;Editor &quot;print('str1 + str2 = ', str1 + str2) Output: Python Editor +연산자의 경우 위처럼 문자열 두 개가 나란히 이어붙혀져 출력이 되며, 12greet = str1 + str2print('greet * 3 = ', greet * 3) Output: Python Editor Python Editor Python Editor *연산자의 경우 변수에 담긴 문자열이 정해준 횟수만큼 반복되어 나열된다. 문자열 인덱싱 접기 / 펼치기 문자열이 있는경우 숫자을 통해 문자열에서 특정 문자만을 출력할 수 있는데 이를 Indexing 이라고 한다.Hello world이라는 문자열이 있다고 하자 그럼 문자열의 각 인덱스는 다음과 같다. 문자열 H e l l o w o r l d 인덱스 0 1 2 3 4 5 6 7 8 9 10 이처럼 각 글자마다 인덱스가 배정되며 공백에도 인덱스가 배정된다.인덱스를 사용하면 다음과 같은 것도 가능하다. 1234text_ex = &quot;Hello world&quot;print(text_ex[2])print(text_ex[6:10])print(text_ex[2:11:2]) Output: l worl lowrd 위 예제는 문자열을 담은 변수에 인덱싱을 한 것이다첫번째 줄은 인덱스’2’의 문자를 가져오는 것인데 인덱스는 0부터 시작하므로 (2번째가아닌)3번째인’l’을 출력한것이다.두번째 줄은 인덱스’6’부터 ‘9’까지(두번째인덱스-1)의 숫자를 가져오는 것이므로 ‘worl’이 출력되었다.세번째 줄은 인덱스’2’부터 ‘10’까지를 가져오되, 한칸씩 건너뛰고(세번째 숫자가 3이므로) 가져오는것이다. 리스트(list) 접기 / 펼치기 리스트는 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.리스트의 장점은 다음과 같다. 인덱스 번호로 빠른 접근이 가능하다. 데이터의 위치에 대해 직접적인 접근(Access)가 가능하다.1fruit = [['apple', 'banana', 'cherry'], 123] 위가 리스트의 형태이다.리스트의 값은 기본적으로 인덱스가 배정된다 이때는1print(fruit[0]) Output: [‘apple’, ‘banana’, ‘cherry’]위와 같은 형태로 나타낼 수 있으며 해당 인덱스의 요소가 리스트라면 리스트 전체를 출력한다. 만약 위처럼 리스트가 중첩된 형태라면 1print(fruit[0][1]) Output: banana 위처럼 출력이 가능하며 이때 리스트의 요소중 해당 인덱스의 요소가 출력된다.물론 이 때도 출력된 문자열에서 다음과 같이 문자열의 요소를 출력하는것도 가능하다. 1print(fruit[0][1][3]) Output: a 위와같이 결과가 출력된다. 리스트값 수정, 추가, 삭제하기 접기 / 펼치기 리스트가 여러 요소들의 집합이다보니 리스트의 값에 변동이 필요할 때가 있다.리스트는 값의 수정, 추가, 삭제가 가능하므로 기능과 문법에 대해 알아둘 필요가 있다. 리스트 값 수정하기123a = [0,1,2]a[1] = &quot;b&quot;print(a) Output: [0, 'b', 2] 별다른 문법없이 리스트의 인덱스에 값을 넣어주니 수정이 되는것을 알 수 있다. 리스트 값 추가하기 append1234567a = [100, 200, 300]a.append(400)print(a)b = [500,600]a.append(b)print(a) Output: [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]]리스트명.append(값)을 통해서 리스트에 값을 추가할 수 있으며 한개의 값만 추가할 수 있다.리스트의 경우엔 한가지 값이며 추가할 경우 중첩된 리스트의 형태로 추가가 된다. extendextend는 append와 거의 같지만 다른점이 하나 있습니다.append는 인자(리스트, 튜플 등)를 주어도 인자 그대로를 리스트에 추가하지만,extend는 인자를 줄 경우 인자의 값 하나하나를 리스트에 추가한다. 1234a = [2, 9, 3]b = [1, 2, 3]a.extend(b)print(a) Output: [2, 9, 3, 1, 2, 3]결과와 같이 append와 비교했을때 extend된 인자의 값 하나하나가 추가된걸 볼 수 있다. insertinsert는 입력해준 위치의 인덱스에 값을 추가해준다. 1234a = [1,2,3]print(a)a.insert(1,'abc')print(a) Output: [1,2,3] [1,’abc’,2,3] 리스트 값 삭제하기 remove1234567a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 였던 1이 삭제a.remove(3)print(a) Output: [2, 1, 2] [2, 2]리스트명.remove()는 괄호내의 값을 삭제한다.만약 값이 리스트내에서 중복될경우 가장 앞에 있는 값을 삭제한다. del12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아준다.print(b) Output: [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9]del 리스트명[인덱스]는 리스트의 인덱스에 위치한 값을 삭제해준다.인덱스값에 범위를 주고싶다면 0:4 처럼 넣을수 있으며 이때는 0에서 3번째 값까지 삭제가 된다. pop12345a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) Output: [0, 2, 3, 4] 1리스트명.pop()은 괄호내의 값을 해당 리스트에서 끄집어낸다. 튜플(tuple) 접기 / 펼치기 튜플은 리스트와 비슷하게 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.튜플과 리스트의 가장 차이점으로는 튜플은 값에대한 수정이 불가하다는 점이다.그렇다면 튜플은 무슨 장점이 있느냐 라고 반문할 수 있는데 리스트와 비교한 튜플의 장점은 다음과 같다. 메모리 사용량이 적다. 생성 시간이 빠르다. 인덱스를 사용하여 튜플의 데이터에 접근하는 시간이 비교적 짧다. 튜플의 문법, 기본형태는 다음과 같다. 1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. Output: 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 튜플을 생성할때 튜플이 되기위해서는 콤마(,)가 필수적이다.콤마를 작성하지 않으면 타입을 출력했을때 튜플이 아닌 입력한 변수형태로 출력이 된다. 튜플역시 리스트와 같이 인덱싱및 슬라이싱이 가능하다. 튜플의 연산튜플도 연산이 가능한데, 더하거나 곱하는 +, * 연산자만 사용이 가능하다. 1234t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t3) Output: (0, 1, 2, 3, 4, 'a', 'b', 'c') 딕셔너리 접기 / 펼치기 딕셔너리는 키와 그에따른 값으로 구성되어있는 파이썬의 자료구조이다. 12345dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) Output: alice 5 [1, 2, 3] 키를 출력하면 그와 대응하는 값이 출력되는 자료구조이며 자료에 순서가 없는논시퀀스 자료형이다. 123a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys()a.values() Output: dict_keys(['name', 'job', 'age']) dict_values(['bob', 'farmer', 35]) 이렇게 키만 출력할수도, 값만 출력할수도 있다. 집합 연산자 접기 / 펼치기 파이썬에도 집합연산이 있고, 자료구조들의 합,교,차집합에 대한 연산을 할수 있다.기호는 |,&amp;,-이며, 각각의 예시는 다음과 같다. 12345a = {1,2,3,4}b = {3,4,5,6}print(a|b) print(a&amp;b)print(a-b) Output: {1, 2, 3, 4, 5, 6} {3, 4} {1, 2} if 조건문 접기 / 펼치기 조건문이란 작성자가 명시한 조건식의 결과인 boolean값이 참인지 거짓인지에 따라 달라지는 계산이나 상황을 수행하는 문장이다. 12345678910a = -5if a&gt;5: print('a는 5이상입니다')elif a &gt; 0: print(&quot;a는 0초과, 5이하입니다&quot;)else: print(&quot;a는 음수입니다&quot;) Output: a는 음수입니다. 조건식에는 기본적으로 조건식이 들어가지만 True나 False등의 직접적인 bool형 변수가 삽입될수도 있으며, and,or 등과 결합하여 여러가지의 조건식을 사용할수도 있다. 반복문 (for,while) 접기 / 펼치기 같은동작을 여러번 반복해야 할 때 같은코드를 여러번 적어넣는건 비효율적이다.그럴때 반복문을 사용하면 훨씬 적은양의 코드로도 같은효과를 낼 수 있다. for문 for문의 기본 구조123for 변수 in 리스트(또는 튜플, 문자열) : 수행할 문장1 수행할 문장2 리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.123a = ['1','2','3']for i in a : print(i) Output: 1 2 3 리스트 a의 첫번째 값인 1이 i에 대입되고 print(i)가 출력된다.다음엔 두번째 값인 2가 대입되고 출력된다.이것을 마지막 값까지 반복한다. while문 while문의 기본 구조12345while &lt;조건문&gt;: &lt;수행할 문장1&gt; &lt;수행할 문장2&gt; &lt;수행할 문장3&gt; ... while문은 for보다는 간단하다. while, 조건문, 실행문 이 세개면 완성되기 때문이다.이러한 특성때문에 while문은 조건문을 거짓으로 만들어주는 문장이 없다면 무한실행된다. 프로그램 뻗는다간단한 예제를 보면 다음과 같다.1234i = 0while i &lt;= 5 : print(&quot;{}번째 반복입니다.&quot;.format(i)) i += 1 Output: 0번째 반복입니다. 1번째 반복입니다. 2번째 반복입니다. 3번째 반복입니다. 4번째 반복입니다. 5번째 반복입니다.변수 i로 인해 자동으로 조건식이 False가 되면서 while문이 종료되는 모습이다.이렇듯 while문은 조건문을 거짓으로 만들어주는 무엇인가가 없다면 종료되지않는다.","link":"/2021/11/01/Python_Basic_Grammar_1/"},{"title":"pandas 기본 문법","text":"DataFrame 생성 방법 list이용12345import pandas as pdframe = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 1 2 3 1 4 5 6 2 7 8 9 Dictionary 이용1234567891011import pandas as pddata = { 'age' : [20,39,41], 'height' : [176, 182, 180], 'weight' : [73, 78, 69]}indexName = ['사람1', '사람2', '사람3']frame = pd.DataFrame(data, index = indexName)frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight 사람1 20 176 73 사람2 39 182 78 사람3 41 180 69 Sample Dataset 가져오기 위처럼 직접 DataFrame을 만드는 것이 아닌 제공하는 Dataset을 직접 가져오는 방법도 있다.Dataset을 가져오는 방법은 다음과 같다. Dataset Github에 접속하고 가져오고싶은 데이터셋을 고른다. 예를들어 flights.csv 를 가져오고 싶다면1234import seaborn as snsflights = sns.load_dataset(&quot;flights&quot;) #여기까지가 가져오기flights.head(5) # 다섯번째 행의 데이터까지만 출력flights[&quot;year&quot;] # 'year'열만 출력 위와 같이 제공되는 데이터셋을 가져올 수 있다. DataFrame 조회 방법 기본적인 조회 방법DataFrame의 기본적인 조회 방법은 다음과 같다. .head() 12# 위에서 가져온 데이터셋 flights를 사용flights.head() # 데이터프레임의 가장 첫부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 이 때 .head()의 괄호 안에 숫자가 있다면 그 수의 개수만큼 데이터가 출력된다. .tail() 1flights.tail() #데이터프레임의 가장 뒷부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 .tail()역시 마찬가지로 괄호안에 숫자가 있다면 수의 개수만큼 데이터가 출력된다. .index 데이터프레임의 인덱스를 표시하는 방법도 있다. 1flights.index RangeIndex(start=0, stop=144, step=1) 열(Column) 조회 방법12345678910#열(Column) 조회print (&quot;* 열 조회 - 1&quot;)print (frame['age'])print (&quot;* 열 조회 - 2&quot;)print(frame.age)#특정 열의 특정 값을 조회하고 싶을때print(&quot;* 특정 열 의 특정 값 조회&quot;)print(frame['age'][1])print(frame.height[2]) 출력 * 열 조회 - 1 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 열 조회 - 2 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 특정 열 의 특정 값 조회 39 180 행(Row) 조회행 조회는 열 조회와 조금 다르게 loc와 iloc를 사용해서 조회 할 수 있다.여기서 loc는 사람이 읽을 수 있는 라벨 값으로 특정 값들을 골라오는 방법이고,iloc는 행이나 칼럼의 순서를 나타내는 정수로 특정 값을 추출하는 방법이다. 12345#행(Row) 조회 (loc)print(&quot;* loc 특정 행 조회&quot;)print(frame.loc['사람1'])# print(frame.loc[0]) - 조건이 정수이므로 조회 불가 출력 * 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 loc를 Seq로 조회할 경우 12345#행(Row) 조회 (iloc)print(&quot;* iloc 특정 행 조회&quot;)print(frame.iloc[0])# print(frame.iloc['사람1']) - 조건이 정수가 아니므로 조회 불가 출력 * iloc 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 DataFrame 수정 방법 열(Column) 추가하기gender 라는 컬럼을 추가합니다. 12frame_add_col = pd .DataFrame(frame,columns= ['age','height','weight','gender'])frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 NaN 사람2 39 182 78 NaN 사람3 41 180 69 NaN 컬럼이 추가되었고 어떠한 값도 넣어주지 않았으므로 NaN 값이 출력되고있다.이제 데이터를 입력해준다. 12frame_add_col['gender'] = ['male', 'male', 'female']frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 행(Row) 추가하기123frame_add_index = frame_add_col.copy()frame_add_index.loc['사람4'] = [31, 158, 48, 'female']frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 사람4 31 158 48 female 행, 열 삭제하기drop 메소드를 사용하면 행 또는 열을 삭제할 수 있다.axis 값은 행이면’0’, 열이면 ‘1’로 지정해주면 된다. 12print('remove age column')frame_add_col.drop(&quot;height&quot;, axis=1) 출력 remove age column .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age weight gender 사람1 20 73 male 사람2 39 78 male 사람3 41 69 female 그러나 이 경우 기존에 있던 frame_add_col에서 삭제되는게 아니라 삭제된 상태의 프레임을 리턴해준 것이다.그러므로 기존 프레임에 적용하기 위해서 inplace = True 옵션을 추가로 주어야 한다. 12frame_add_index.drop('사람2', axis=0, inplace = True)frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람3 41 180 69 female 사람4 31 158 48 female References https://hong-sam.tistory.com/100","link":"/2021/11/02/pandas_Basic_Grammar_1/"},{"title":"결정 나무(Decision Tree) 간단 설명","text":"결정 나무란? 결정 나무 Decision Tree 는 분류와 회귀 문제에 널리 사용하는 데이터마이닝 기법이다. 결정 나무는 결정을 하기위해 예/아니오 질문을 연속해가며 학습한다. 결정나무 간단설명영상결정나무 사이킷런 튜토리얼 결정나무의 의사결정 과정 결정 나무가 행하는 이 과정은 ‘스무고개’를 할때의 그것과 비슷하다.사과, 포도, 멜론, 녹차를 구분한다고 생각해보자. 사과와 포도는 과일이고 멜론과 녹차는 과일이 아니다.‘과일인가요?’라는 질문을 통해 사과, 포도 / 멜론, 녹차를 나눌 수 있고, 사과와 포도는 ‘(과실 전체의)모양이 둥근가요?’, 멜론과 녹차는 ‘넝쿨에서 자라나요?’ 라는 질문을 통해 분류해 낼 수 있다.위의 결정나무를 도식화하면 아래와 같다. 이렇게 질문에 따라 데이터를 구분짓는 모델을 결정나무모델이라고 한다. 한번의 질문에 True 혹은 False를 통해 변수영역을 두 개로 분기한다. 위의 그림에서 각각의 네모상자를 노드Node라고 하며, 가장 처음의 분기점을 Root Node라고 하고, 가장 마지막 노드를 Leaf Node또는 Terminal Node라고 한다. 결정나무분류기 = DecisionTreeClassifier DecisionTreeClassifier()는 결정나무의 기능을 바꿀수 있는 파라미터인데 파라미터 내부의 특성 하나하나를 하이퍼파라미터라고 한다.DecisionTreeClassifier()파라미터의 괄호 안에 각각의 값을 입력할 수 있는데 다음과 같은 항목들이 있다. 하이퍼파라미터 기능 criterion 분할 품질을 측정하는 기능 (default : gini) splitter 각 노드에서 분할을 선택하는 데 사용되는 전략 (default : best) max_depth 트리의 최대 깊이 (값이 클수록 모델의 복잡도가 올라간다.) min_samples_split 자식 노드를 분할하는데 필요한 최소 샘플 수 (default : 2) min_samples_leaf 리프 노드에 있어야 할 최소 샘플 수 (default : 1) min_weight_fraction_leaf min_sample_leaf와 같지만 가중치가 부여된 샘플 수에서의 비율 max_features 각 노드에서 분할에 사용할 특징의 최대 수 random_state 난수 seed 설정 max_leaf_nodes 리프 노드의 최대수 min_impurity_decrease 최소 불순도 min_impurity_split 나무 성장을 멈추기 위한 임계치 class_weight 클래스 가중치 presort 데이터 정렬 필요 여부 괄호 내부에 아무것도 입력하지않으면 기본값으로 결정나무가 출력된다. References https://inuplace.tistory.com/548 https://scikit-learn.org/stable/modules/tree.html#classification","link":"/2021/11/04/Decision_Tree/"},{"title":"마크다운(Markdown) 문법","text":"지금 당장만 해도 이 글을 마크다운으로 작성하고 있는 나는 HTML를 접해보긴 했지만 자유자재로 쓸 수 있는정도는 아니였기에 깃허브 블로그를 시작하면서 마크다운의 문법에 대해 알아야 할 필요가 생겼다. 다른 포스트들도 마찬가지지만 더욱 이 포스트는 자주 찾아 봐야 할 것 같기에 문법만을 기록하며, 접기를 최대한 지양한다. 각 챕터의 위쪽은 코드 그 아래는 출력이다. 마크다운 문법 제목 작성1234# 이러면 큰제목 &lt;h1&gt;태그## 이러면 중간제목 &lt;h2&gt;태그### 이러면 작은제목 &lt;h3&gt;태그#### 이것도 되긴 하지만 굵게한 글자와 차이가 없음. &lt;h4&gt;태그로 사용된다 이러면 큰제목 &lt;h1&gt;태그이러면 중간제목 &lt;h2&gt;태그이러면 작은제목 &lt;h3&gt;태그이것도 되긴 하지만 굵게한 글자와 차이가 없는 &lt;h4&gt;태그로 사용된다 줄바꿈12줄바꿈은 행의 끝에서 공백 두칸을 주고 다음행에 작성하면 된다. 줄바꿈은 행의 끝에서 공백 두칸을 주고다음행에 작성하면 된다. 코드블럭123```과 ~~~는 마크다운의 내용을 코드블럭을 씌운다.```(언어명) 내용 ``` 의 형태로 작성하며이것도 코드블럭으로 씌워진 것이다. 인라인코드1이것은 `인라인코드`이다. 이것은 인라인코드이다. 링크 걸기www.naver.com그냥 주소를 써도 링크로 클릭이 되지만 , 1[WJ 블로그](cincu4221.github.io) WJ 블로그위처럼 작성하면 주소를 숨기고 텍스트에 링크를 걸 수 있다. 텍스트1**강조된 텍스트** 강조된 텍스트 12*기울인텍스트****기울임,강조를적용한텍스트*** 기울인텍스트기울임,강조를적용한텍스트 1~~취소선입니다~~ 취소선입니다 글자색 12345678&lt;span style=&quot;color:orange&quot;&gt;주황색 글씨&lt;/span&gt; &lt;span style=&quot;color:yellow&quot;&gt;노란색 글씨&lt;/span&gt; &lt;span style=&quot;color:#FF0000&quot;&gt;빨간색 글씨&lt;/span&gt; &lt;span style=&quot;color:blue&quot;&gt;파란색 글씨&lt;/span&gt; &lt;span style=&quot;color:green&quot;&gt;초록색 글씨&lt;/span&gt; &lt;span style=&quot;color:pink&quot;&gt;분홍색 글씨&lt;/span&gt; &lt;span style=&quot;color:#00FFFF&quot;&gt;헥스코드 적용 글씨&lt;/span&gt; 주황색 글씨노란색 글씨빨간색 글씨파란색 글씨초록색 글씨분홍색 글씨 헥스코드 적용 글씨 검색하기 애매한 색도 여기 에서 찾을 수 있다. 구분선123***-- ----- 표만들기1234|제목|제목||:---:|:---:||내용|내용|||| 제목 제목 내용 내용 내용 내용 리스트1234567891011121. 순서 있는 리스트2. 순서 있는 리스트345. 순서 있는 리스트 (순서가 틀려도 상관 없다)* 순서 없는 리스트* 순서 없는 리스트+ 순서 없는 리스트+ 순서 없는 리스트- 순서 없는 리스트- 순서 없는 리스트 순서 있는 리스트 순서 있는 리스트 순서 있는 리스트 (순서가 틀려도 상관 없다) 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 앞으로 계속 추가할것","link":"/2021/11/04/Markdown-Grammar/"},{"title":"NumPy 기본 다지기","text":"Numpy란 무엇인가?Numpy는 상당부분 C언어로 작성된 파이썬 라이브러리이다. 기본적으로 array라는 자료를 생성하고 이를 바탕으로 색인, 처리, 연산 등을 하는 기능을 수행한다. 물론 C언어로 작성되었기 때문에 속도도 꽤나 빠른편이다. Numpy의 기본Numpy 불러오기 Numpy를 사용하기 위해서는 먼저 임포트시켜줘야 한다. 1import numpy as np 위처럼 입력하면 Numpy의 임포트가 된다. 뒤의 as np를 빼고 나머지만 입력해도 되지만, 앞으로 사용할 코드에서 조금 더 편히 사용하기 위하여(그리고 관례적으로) as np를 작성해 준다. Numpy배열 생성 및 둘러보기 Numpy는 기본적으로 array라는 자료구조를 사용하기때문에 배열을 생성하는 방법에 대해 먼저 알아두어야 한다. 1234arr1 = [1,2,3]my_array1 = np.array(arr1)print(my_array1)print(my_array1.shape) Output: [1 2 3] (3,) 위의 출력 중 첫째줄은 arr1의 배열을 그대로 my_arrary1로 가져와 출력한 것이고, 둘째 줄은 가져온 배열의 길이를 튜플로 나타낸 것이다. 값 뒤에 콤마(,)가 붙어있는 이유는 값이 하나만 존재할 때, 튜플은 값 뒤에 콤마가 있어야 하기 때문이다. 다음은 2차원 배열일떄의 예제이다. 1234my_array3 = np.array([[2,4,6],[8,10,12],[14,16,18],[20,22,24]])print(my_array3)print(my_array3.shape)print(my_array3.dtype) Output: [[ 2 4 6] [ 8 10 12] [14 16 18] [20 22 24]] (4, 3) int64 먼저 세개의 출력 중 첫번째로 my_array3의 값인 리스트들이 차례로 나열되며, 그 다음으로는 배열의 (행, 열)의 수, 마지막으로 배열내의 요소의 데이터타입을 출력한다. 마지막으로 3차원 배열일때의 예제이다. 12my_array5 = np.array([[[1, 2], [3, 4],[5, 6]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3, 2) 세려는 양(또는 각각) 배열의 수가 대칭일때의 예제이다, 가장 바깥쪽의 배열부터 순서대로 배열의 수를 출력한다.그렇다면 대칭이 아니라면 어떻게 출력될까? 다음을 살펴보자 12my_array5 = np.array([[[1, 2], [3, 4], [5, 6, 7]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3) 출력과 동시에 에러(위 출력창에서는 삭제함)가 뜨는데 추측하기론 양쪽 배열이 대칭이 아니기에 양 배열의 길이가 같은 두번째 항목까지는 출력되나 2와 3으로 갈리는 마지막 항목에서 출력이 안되는것 같다.확실하지않으니 참고만… Numpy의 기본 함수들 Numpy는 여러 함수들을 사용할수 있다, 하지만 함수의 종류가 너무 많기 때문에 이 챕터에서는 기본적인 함수들만 알아보도록 한다. arange arange는 배열을 만들어주는 함수이다.arange([시작],끝,[만큼 건너뜀])으로 작성 할 수 있으며 []안의 항목은 생략 할 수 있다. 12arrange_array = np.arange(3, 13, 2)arrange_array Output: array([ 3, 5, 7, 9, 11]) 3부터 시작해서 12(13-1)까지 출력하며 2씩 건너뛰는 배열을 생성하는 arange예제이다. zeros, ones zeros와 ones는 0또는 1로 초기화된 shape* 차원의 ndarray** 배열 객체를 반환한다.두 함수 모두 객체 생성시 데이터 타입은 float64형식이다.*shape : 행열의 차원**ndarray : N차원의 배열객체. 기존파이썬과는 다르게 ndarray는 오직 같은 종류의 데이터만을 배열에 담을 수 있다. 1234zeros_array = np.zeros((3,2))print(zeros_array)print(&quot;Data Type is:&quot;, zeros_array.dtype)print(&quot;Data Shape is:&quot;, zeros_array.shape) Output: [[0. 0.] [0. 0.] [0. 0.]] Data Type is: float64 Data Shape is: (3, 2) 순서대로 배열, 데이터 타입, 데이터의 차원을 출력한다. 1234ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is:&quot;, ones_array.dtype)print(&quot;Data Shape is:&quot;, ones_array.shape) Output: [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is: int32 Data Shape is: (3, 4) 같은 순서로 항목들을 출력했고 배열생성시 데이터 타입을 바꿀수 있음을 보여주는 예제이다. reshape reshape는 구조를 재배열해주는 함수이다. 배열명.reshape(차원, 차원)으로 사용할 수 있다. 1234# 위에서 만들어진 3 x 4 배열의 ones_array를 reshape하여 2 x 6로 재배열after_reshape = ones_array.reshape(2,6)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] Data Shape is: (2, 6) reshape를 통해서 3x4 배열을 2x6으로 재배열 해준 가장 기본적인 예제이다. 재배열하려는 배열이 3x4 라면 3x4를 곱해서 나오는 값인 12의 인수들로 12의 결과가 나오는 배열((1,12), (2,6), (4,3))들로 바꿀 수 있으며, (2,2,3)등과 같은 3차원배열로도 재배열이 가능하다. reshape의 값에 -1을 넣는다면? 그렇다면 reshape의 괄호 차원값에 -1을 넣는다면 어떻게될까?다음 결과를 보자. 12after_reshape2= ones_array.reshape(-1,6)print(after_reshape2) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] -1을 작성한 곳에 12에서 나머지(두번째 값인 6)값을 보고 첫번째 값은 알아서 2로 지정이 된 것이다.다음은 값이 -1 하나일 때의 예제이다. 12after_reshape2= ones_array.reshape(-1)print(after_reshape2) Output: [1 1 1 1 1 1 1 1 1 1 1 1] 결과와 같이 1차원 배열로 바뀐다. 하지만 (12)일뿐, 2차원 배열인 (1,12)과는 같지 않다. Numpy 인덱싱과 슬라이딩 Numpy의 배열에도 값을 추출 할 수 있게 인덱싱과 슬라이딩이 가능하다. 1234my_array2 = np.arange(start=3,stop=30,step=3)my_array2 = my_array2.reshape(3,3)my_array2[1:3,:] Output: array([[12, 15, 18], [21, 24, 27]]) 출력에서 첫번째 인자는 1에서 2(3-1)번째 까지의 배열을 출력하고, 두번째 인자인 :은 첫번째 인자에서 지목된 배열의 항목을 모두 출력하는 것이다. Numpy 정렬 여러 값이 모여있는 array인 만큼 정렬도 가능하다. 이 챕터에서는 오름,내림차순으로 정렬해주는 sort(), 값이 낮은 순서대로 인덱스를 배정해 배열을 출력해주는 argsort()가 있다. sort() 12345height_arr = np.array([174, 165, 180, 182, 168])sorted_height_arr = np.sort(height_arr)print('Height Matrix: ', height_arr)print('np.sort() Matrix: ', sorted_height_arr) Output: Height Matrix: [174 165 180 182 168] np.sort() Matrix: [165 168 174 180 182] 결과에서 보이다시피 sort()함수는 배열내의 값을 오름차순으로 정렬해준다. 내림차순으로 정렬을 하고 싶다면 다음과 같이 하면 된다. 12desc_sorted_height_arr = np.sort(height_arr)[::-1]print('np.sort()[::-1] : ', desc_sorted_height_arr) Output: np.sort()[::-1] : [182 180 174 168 165] 위처럼 정렬을 할 때 sort()의 뒷부분에 [::-1]을 붙여주면 된다. argsort() 123456fives = np.array([10, 5, 15, 20])fives_order = fives.argsort()print(&quot;The original data&quot;, fives)print(&quot;The argsort(): &quot;, fives_order)print(&quot;The asending:&quot;, fives[fives_order]) Output: The original data [10 5 15 20] The argsort(): [1 0 2 3] The asending: [ 5 10 15 20] 출력의 첫번째 줄은 가장 처음 입력했던 일반적인 배열이다.두번째 줄은 오름차순으로 인덱스를 매긴 배열이며,마지막은 두번째줄의 배열에 따라 첫번째줄의 결과인 배열을 정렬한 것이다.","link":"/2021/11/06/NumPy-Basic-Grammar-1/"},{"title":"캐글 데이터 시각화 해석-1","text":"임포트 및 데이터프레임 추가 1234567891011121314151617# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only &quot;../input/&quot; directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using &quot;Save &amp; Run All&quot; # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session 12from plotly.offline import plot, iplot, init_notebook_modeinit_notebook_mode(connected=True) 123456789101112import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport plotly.express as pximport plotly.graph_objects as gofrom warnings import filterwarningsfilterwarnings('ignore')colors = ['#B1EDED','#B1B2ED','#1DE7ED','#1DA5ED','#1D50ED','#16548E']df = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv')df.head() 원 그래프 해석 1234567891011fig = go.Figure( data=[ # 그래프의 형태를 나타내는 함수 go.Pie( # 원그래프 labels = df['Q2'][1:].value_counts().index, # 값에 붙일 이름 - df['Q2'][1:].value_counts()의 인덱스 values = df['Q2'][1:].value_counts().values, # 나타낼 값 - df['Q2'][1:].value_counts()의 값 textinfo = 'label+percent')]) # 그래프 항목당 나타낼 텍스트 (여기서는 항목명, 비율)fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인지fig.update_layout( # 그래프의 레이아웃 설정 title_text='Gender Distribution', # 그래프의 제목 showlegend=False) # 범례표시여부fig.show() 그래프 코드 해석 123456fig = go.Figure(data=[ go.Pie( labels = df['Q2'][1:].value_counts().index, values = df['Q2'][1:].value_counts().values, textinfo = 'label+percent' )]) fig = go.Figure(data=[-&gt; 그래프의 기본적인 틀을 설정하는 함수이고, fig에 데이터를 부여해준다. go.Pie(-&gt; 그래프의 형태가 파이모양(원그래프)임을 의미한다. labels = df['Q2'][1:].value_counts().index-&gt; 그래프로 표현될 값에 붙일 이름이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스(질문열을 제외하기 위함) 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 인덱스열 인 것이다. values = df['Q2'][1:].value_counts().values-&gt; 그래프로 표현될 값이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 값(각 값을 카운트한 값) 이다. textinfo = 'label+percent'-&gt; 그래프에 표시된 항목에 나타낼 텍스트를 설정한다. 이 코드에서는 항목명(label)과 비율(percent)을 나타낸다. 123456fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인가를 설정fig.update_layout( # 그래프의 부가정보 설정 title_text='Gender Distribution', # 그래프 제목 showlegend=False) # 범례표시여부fig.show() fig.update_traces(-&gt; 추가바람 marker=dict(colors=colors[2:]))-&gt; 그래프의 색상을 설정한다. 이 코드에서는 위에서 설정된 colors 리스트에서 2번 인덱스부터 순서대로 사용한다. fig.update_layout(-&gt; 그래프의 부가정보를 설정한다. title_text='Gender Distribution'-&gt; 그래프의 제목을 설정한다. showlegend=False)-&gt; 범례의 표기여부를 결정한다. 이 코드에서는 False이므로 범례가 표기되지 않는다. fig.show()-&gt; 화면에 그래프를 표시하는 기능을한다. 몇몇에디터에서는 자동으로 표시되기때문에 호출할 필요가 없는 경우가 있다. 막대그래프 해석 12345678910111213141516171819202122232425262728293031man = df[df['Q2'] == 'Man']['Q1'].value_counts() # 성별이 남성[df['Q2'] == 'Man']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.woman = df[df['Q2'] == 'Woman']['Q1'].value_counts() # 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.textonbar_man = [ # list comprehension = [(변수를 활용한 값) for (사용할 변수 이름) in (순회 할 수 있는 값)] round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] # for문을 사용하여 round함수의 계산을 하고 textonbar_man에 저장textonbar_woman = [ # list comprehension round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]# go = graph_objectsfig = go.Figure(data=[ go.Bar( # 막대그래프 name='Man', # 그래프로 나타낼 항목 x=man.index, # x축에 man의 인덱스 y=man.values, # y축에 man의 값 text=textonbar_man, # 막대의 값을 작성해줄 텍스트 marker_color=colors[2]), #막대 색 go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3])])fig.update_traces( texttemplate='%{text:.3s}%', # fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside') # 그래프상에서 값의 위치fig.update_layout( barmode='stack', # 막대의 형태 title_text='Age distribution by gender', # 그래프 제목 xaxis_title='Age', # x축 제목 yaxis_title='Counts') # y축 제목fig.show() 그래프 코드 해석 1234man = df[df['Q2'] == 'Man']['Q1'].value_counts()woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()textonbar_man = [ round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]textonbar_woman = [ round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] man = df[df['Q2'] == 'Man']['Q1'].value_counts()-&gt; 성별이 남성[df['Q2'] == 'Man]인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()-&gt; 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. textonbar_man = [round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_man에 저장한다. textonbar_woman = [round((uw/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_woman에 저장한다. 12345678910fig = go.Figure(data=[ go.Bar( name='Man', x=man.index, y=man.values, text=textonbar_man, marker_color=colors[2] ), go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3] )]) go.Bar(-&gt; 그래프의 모양이 막대모양임을 의미한다. name='Man', x=man.index, y=man.values,-&gt; 순서대로 막대의 이름, x축에는 man의 인덱스, y축에는 man의 값을 나타내라는 의미이다. text=textonbar_man, marker_color=colors[2]),-&gt; 각각 막대의 값을 작성해줄 텍스트, 막대의 색을 의미한다. 123456789fig.update_traces( texttemplate='%{text:.3s}%', textposition='inside')fig.update_layout( barmode='stack', title_text='Age distribution by gender', xaxis_title='Age', yaxis_title='Counts')fig.show()) texttemplate='%{text:.3s}%',-&gt; fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside'-&gt; 그래프상에서의 값의 위치를 설정한다. barmode='stack'-&gt; 막대의 형태를 표현한다. title_text='Age distribution by gender'-&gt; 그래프의 제목을 설정한다. xaxis_title='Age', yaxis_title='Counts'-&gt; 그래프의 x축 제목, y축 제목 몇몇 요소 확인법 print(type(데이터))-&gt; 데이터의 타입을 출력한다 데이터.head(),데이터.tail()-&gt; 데이터를 인덱스 순으로 출력한다. head는 처음부터 끝까지, tail은 반대로 출력하며 괄호안에 숫자를 입력하면 숫자만큼 출력한다. Referencesgo.Figure() propertiesupdate_traces() propertiesupdate_layout() propertiesshow() propertiesgo.Bar() properties","link":"/2021/11/08/Kaggle_Data_Visualization-1/"},{"title":"파이썬 시각화 기본","text":"파이썬 시각화의 기본 형태들 선 그래프로 시각화하기1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, ax = plt.subplots()ax.plot(dates, min_temperature, label = &quot;Min Temp&quot;)ax.plot(dates, max_temperature, label = &quot;Max Temp&quot;)ax.legend()plt.show() Output 위의 그래프에서 크기의 변화를 준 그래프1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))axes.plot(dates, min_temperature, label = 'Min Temperature')axes.plot(dates, max_temperature, label = 'Max Temperature')axes.legend()plt.show() Output fig와 axes 출력12print(fig)print(axes) Output Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) Matplotlib 선 그래프먼저 yfinance라이브러리를 사용하기 위해 설치를 한다. 1!pip install yfinance --upgrade --no-cache-dir 실행시 Collecting yfinance Downloading yfinance-0.1.64.tar.gz (26 kB) Requirement already satisfied: pandas&gt;=0.24 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.1.5) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.19.5) Requirement already satisfied: requests&gt;=2.20 in /usr/local/lib/python3.7/dist-packages (from yfinance) (2.23.0) Requirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.9) Collecting lxml&gt;=4.5.1 Downloading lxml-4.6.4-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl (6.3 MB) \u001b[K |████████████████████████████████| 6.3 MB 5.3 MB/s \u001b[?25hRequirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2.8.2) Requirement already satisfied: pytz&gt;=2017.2 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2018.9) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24-&gt;yfinance) (1.15.0) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (1.24.3) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2021.5.30) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (3.0.4) Building wheels for collected packages: yfinance Building wheel for yfinance (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for yfinance: filename=yfinance-0.1.64-py2.py3-none-any.whl size=24109 sha256=da9039df457bcaed01c34fcce5bc8ee52dcf33151b9275684543166937fa1286 Stored in directory: /tmp/pip-ephem-wheel-cache-qozcsm2m/wheels/86/fe/9b/a4d3d78796b699e37065e5b6c27b75cff448ddb8b24943c288 Successfully built yfinance Installing collected packages: lxml, yfinance Attempting uninstall: lxml Found existing installation: lxml 4.2.6 Uninstalling lxml-4.2.6: Successfully uninstalled lxml-4.2.6 Successfully installed lxml-4.6.4 yfinance-0.1.64 다음과 같이 출력되며 yfinace를 설치한다. yfinance를 임포트해주고 그로부터 데이터를 받아와 출력을 할수 있다. 123import yfinance as yfdata = yf.download('AAPL', '2019-08-01', '2020-08-01')data.info() Output [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB 다음과 같이 애플의 1년동안의 주가를 볼 수 있다. 데이터의 컬럼을 지목해서 열람하는것 역시 가능하다. 12ts = data['Open']print(ts.head()) Output Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 data에 담겨있는 애플의 주가정보 중 ‘Open’에 해당하는 전일 종가를 가장 앞쪽(.head())부터 출력한 것이다.애플주식이 이렇게 쌌었나 검색해보니 이게 맞다…. 방법 1. Pyplot API 12345678910111213# import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-11-01', '2021-11-01')ts = data['Open']plt.figure(figsize=(10,6))plt.plot(ts)plt.legend(labels=['Price'], loc='best')plt.title('Stock Market fluctuation of AAPL') plt.xlabel('Date') plt.ylabel('Stock Market Open Price') plt.show() Output [*********************100%***********************] 1 of 1 completed 이처럼 결과가 출력되지만 이 문법은 시각화를 처음배우는 초심자에게는 적합하지 않다고 한다.후술할 문법과 위 문법 모두 출력은 되나 이 문법은 객체지향이 아니기도 하고 상대적으로 복잡하기때문에 초심자의 경우에 헷갈릴수 있어 사용하지 않는다.구글링 했을때 객체.이 아닌 plt.으로 시작하는 애들이 있다면 그 코드는 스킵하는게 좋다. 방법 2. 객체지향 API 123456789101112131415from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figureimport matplotlib.pyplot as pltfig = Figure()import numpy as npnp.random.seed(6)x = np.random.randn(20000)ax = fig.add_subplot(111)ax.hist(x, 100)ax.set_title('Artist Layer Histogram')# fig.savefig('Matplotlib_histogram.png')plt.show() 이 방법에 대해서는 따로 언급이 없었기 때문에 바로 방법 3으로 넘어간다. 방법 3. Pyplot API + 객체지향 API 12345678910111213import yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-08-01', '2020-08-01')ts = data['Open']fig, ax = plt.subplots(figsize=(10, 6))ax.plot(ts)ax.set_title('Stock Market fluctuation of AAPL')ax.legend(labels=['Price'], loc='best')ax.set_xlabel('Date')ax.set_ylabel('Stock Market Open Price')plt.show() Output [*********************100%***********************] 1 of 1 completed 드디어 꼭 외우라고 하셨던 pyplot + 객체지향 API 방법이다.특히 7번째 행 부터 마지막까지가 중요한데 그에대한 설명은 아래에 표로 적겠다.중요하다 몇번을 강조하셨으니 위 코드는 변형을 해가며 여러번 작성해보자. 설명 표 코드 설명 fig, ax = plt.subplots() 데이터 전체적 외형을 설정하는 부분 ax.plot(ts) 데이터를 표현해주는 행 ax.set_title() 데이터 시각화의 제목 ax.legend() 범례 ax.set_xlabel() x축 데이터의 제목 ax.set_ylabel() y축 데이터의 제목 plt.show() 안해도 상관없으나 ‘완료후 게시’ 라는 뜻으로 작성 앞으로 나올 표의 내용도 표의 위에 있는 코드들과 적절히 섞어서 이해하길 바란다. 막대 그래프 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npimport calendarmonth_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]sold_list = [300, 400, 550, 900, 600, 960, 900, 910, 800, 700, 550, 450]fig, ax = plt.subplots(figsize=(10,6))plt.xticks(month_list, calendar.month_name[1:13], rotation=90)plot = ax.bar(month_list, sold_list)for rect in plot: print(&quot;graph:&quot;, rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.002*height,'%d' % int(height), ha='center', va='bottom')plt.show() Output graph: Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) graph: Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) graph: Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) graph: Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) graph: Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) graph: Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) graph: Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) graph: Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 메소드 설명 .xticks()는 x축의 눈금을 나타내는 메소드인데 기본적으로는 list자료형 한개을 사용한다.하지만 메소드에 인자가 ‘list’ 두 개로 받아졌을 경우,첫번째 list는 x축 눈금의 갯수가 된다.두번째 list는 x축 눈금의 이름이 된다.이 코드에서는 rotation 옵션도 들어가 있는데 이것은 그냥 이름을 몇도정도 기울일지 나타낸다.plot = ax.bar()는 그래프를 막대로 만든다.첫번째 리스트 인자의 수 만큼 막대가 생성되고,두번째 리스트 인자의 값 만큼 막대가 길어진다.이렇다보니 첫번째 리스트와 두번째 리스트의 인자의 수가 일치해야 에러가 나지 않는다.for문 내부의 ax.text()는 Seaborn-막대그래프-표현할 값이 한 개인 막대 그래프 챕터에 서술했으니 참고하길 바란다. 산점도 그래프 두개의 연속형 변수 (키, 몸무게 등) 상관관계 != 인과관계 나타내는 값이 한가지인 산점도 그래프 123456789101112131415import matplotlib.pyplot as pltimport seaborn as sns# 내장 데이터tips = sns.load_dataset(&quot;tips&quot;)x = tips['total_bill']y = tips['tip']fig, ax = plt.subplots(figsize=(10, 6))ax.scatter(x, y) # 각각의 값을 선으로 표현해주는 scatter()ax.set_xlabel('Total Bill')ax.set_ylabel('Tip')ax.set_title('Tip ~ Total Bill')fig.show() Output 나타내는 값이 두 가지인 산점도 그래프 12345678910111213label, data = tips.groupby('sex')tips['sex_color'] = tips['sex'].map({&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot;})fig, ax = plt.subplots(figsize=(10, 6))for label, data in tips.groupby('sex'): ax.scatter(data['total_bill'], data['tip'], label=label, color=data['sex_color'], alpha=0.5) ax.set_xlabel('Total Bill') ax.set_ylabel('Tip') ax.set_title('Tip ~ Total Bill by Gender')ax.legend()fig.show() Output 히스토그램 수치형 변수 1개 12345678910111213141516import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터 titanic = sns.load_dataset('titanic')age = titanic['age']nbins = 21fig, ax = plt.subplots(figsize=(10, 6))ax.hist(age, bins = nbins) # 여기서 bins = nbins는 히스토그램을 더 세밀하게 나누어 준다.ax.set_xlabel(&quot;Age&quot;)ax.set_ylabel(&quot;Frequency&quot;)ax.set_title(&quot;Distribution of Aae in Titanic&quot;)ax.axvline(x = age.mean(), linewidth = 2, color = 'r')fig.show() Output 코드 설명 .hist() 데이터를 히스토그램으로 표현해주는 메소드 .axvline() 데이터의 평균을 선으로 나타내주는 메소드 박스플롯 x축 변수: 범주형 변수, 그룹과 관련있는 변수, 문자열 y축 변수: 수치형 변수 12345678910111213import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset('iris')data = [iris[iris['species']==&quot;setosa&quot;]['petal_width'], iris[iris['species']==&quot;versicolor&quot;]['petal_width'], iris[iris['species']==&quot;virginica&quot;]['petal_width']]fig, ax = plt.subplots(figsize=(10, 6))ax.boxplot(data, labels=['setosa', 'versicolor', 'virginica'])fig.show() Output 수정바람) 정확히 어떻게 이 그래프가 출력되는지 모르기에 좀 더 공부후 수정할 것 히트맵 123456789101112131415import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터flights = sns.load_dataset(&quot;flights&quot;)flights = flights.pivot(&quot;month&quot;, &quot;year&quot;, &quot;passengers&quot;)fig, ax = plt.subplots(figsize=(12, 6))im = ax.imshow(flights, cmap = 'YlGnBu')ax.set_xticklabels(flights.columns, rotation = 20)ax.set_yticklabels(flights.index, rotation = 10)fig.colorbar(im)fig.show() Output year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 .. ... ... ... 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 [144 rows x 3 columns] 제목 제목 fig.colorbar() 값의 빈도 수에 대한 컬러바생성 Seaborn 산점도와 회귀선이 있는 산점도 산점도 12345678%matplotlib inline import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)sns.scatterplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips)plt.show() Output 회귀선이 있는 산점도 1234567891011121314fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(15, 5))sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[0], fit_reg = True)sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[1], fit_reg = False)plt.show() Output 위의 코드처럼 fit_reg = True로 해줄 경우 회귀선이 나타나는것을 알 수 있다.그리고 ax = ax[num]의 경우에는 그래프의 인덱스로 보인다. 히스토그램/커널 밀도 그래프 12345678910import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)plt.figure(figsize=(10, 6))sns.displot(x = &quot;tip&quot;, data = tips)sns.displot(x=&quot;tip&quot;, kind=&quot;kde&quot;, data=tips) # 종류 = 커널밀도 그래프(kde)sns.displot(x=&quot;tip&quot;, kde=True, data=tips) # 히스토그램에 kde를 넣을건가 = Trueplt.show() Output &lt;Figure size 720x432 with 0 Axes&gt; 박스플롯12345678#import matplotlib.pyplot as plt # 주석처리된 부분은 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. #import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.boxplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips)sns.swarmplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips, alpha = .25)plt.show() Output 막대 그래프1234567#import matplotlib.pyplot as plt # 이 주석 역시 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. 이하 기본주석이라 하고 생략한다.#import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.countplot(x = &quot;day&quot;, data = tips)plt.show() Output 'tips'Data의 'day'값, 인덱스별 정렬, 'tips'의 내림차순 재배치 123print(tips['day'].value_counts())print(&quot;index: &quot;, tips['day'].value_counts().index)print(&quot;values: &quot;, tips['day'].value_counts().values) Sat 87 Sun 76 Thur 62 Fri 19 Name: day, dtype: int64 index: CategoricalIndex(['Sat', 'Sun', 'Thur', 'Fri'], categories=['Thur', 'Fri', 'Sat', 'Sun'], ordered=False, dtype='category') values: [87 76 62 19] 'tips'Data의 'day'값에 대한 오름차순(ascending) 정렬 1print(tips['day'].value_counts(ascending=True)) Fri 19 Thur 62 Sun 76 Sat 87 Name: day, dtype: int64 표현할 값이 한 개인 막대 그래프 1234567# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, order = tips['day'].value_counts().index) # x축을 'day'로 지정, data는 'tips'로 채워넣음, 'day'의 값이 높은 순서대로 막대그래프 정렬 for p in ax.patches: # ax.patches = p height = p.get_height() # 아래행을 실행하기위해 막대그래프의 높이 가져옴 ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9) # 막대그래프 위 수치 작성ax.set_ylim(-5, 100) # y축 최소, 최대범위plt.show() Output 나중에 다시 본다면 조금 설명이 필요할 것 같다.특히 ax.text행의 인자가 조금 많은데 설명이 필요한 듯하다.직접 colab에서 이것저것 만져본 결과 추측하기로는 다음 표과 같은듯 하다. 코드 설명 p.get_x() + p.get_width()/2. 수치가 들어갈 x축 위지 height+3 y축 위치(현재 +3) height 수치의 값을 조절할 것인지(현재 +0) ha = ‘center’ 수치를 (x,y)축의 가운데로 정렬 size=9 폰트의 크기이다 여기서 혹시나 ha = 'center'부분이 잘 이해가 안될수 있다.내가그랬다ha =는 (x,y)축의 기준이 될 곳을 정하는 인자인듯 하다.center말고도 left,right등을 사용할수 있는데 막대의 기준에서 왼쪽,오른쪽이 아닌 텍스트의 기준에서 왼쪽,오른쪽이라 방향을 선택하면 오히려 반대로 배치되는것을 알 수 있다. 표현할 값이 두 개인 막대 그래프 123456789# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, hue = &quot;sex&quot;, dodge = True, order = tips['day'].value_counts().index)for p in ax.patches: height = p.get_height() ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9)ax.set_ylim(-5, 100)plt.show() Output 이 코드에서 첫째줄의 인자를 표로 나타내면 코드 설명 x = “day” x축이 나타낼 자료 data = tips 표현할 데이터셋 hue = “sex” 그래프로 표현할 항목 dodge = True 항목끼리 나눠서 표현할 것인지 order = tips[‘day’].value_counts().index ‘day’의 값이 높은 순서대로 그래프 정렬 sns.countplot() x축이 나타낼 자료, 나타낼 데이터셋, 그래프로 나타낼 항목, 항목끼리 나눠서 표현할것인지, ‘day’의 값이 높은 순서대로 막대그래프 정렬 상관관계 그래프 데이터 불러오기 및 행, 열 갯수 표시하기 12345678910import pandas as pd import numpy as np import seaborn as snsimport matplotlib.pyplot as pltmpg = sns.load_dataset(&quot;mpg&quot;)print(mpg.shape) # 398 행, 9개 열num_mpg = mpg.select_dtypes(include = np.number) # num_mpg에 'mpg' 데이터셋의 데이터타입 총갯수를 입력한다(숫자형 데이터타입만 포함)print(num_mpg.shape) # 398 행, 7개 열 (두개가 사라진 이유는 number타입이 아닌 Object타입이기 때문) (398, 9) (398, 7) 데이터셋의 컬럼 표시 1num_mpg.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 398 entries, 0 to 397 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 mpg 398 non-null float64 1 cylinders 398 non-null int64 2 displacement 398 non-null float64 3 horsepower 392 non-null float64 4 weight 398 non-null int64 5 acceleration 398 non-null float64 6 model_year 398 non-null int64 dtypes: float64(4), int64(3) memory usage: 21.9 KB 데이터셋 컬럼간의 상관관계 표시 1num_mpg.corr() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mpg cylinders displacement horsepower weight acceleration model_year mpg 1.000000 -0.775396 -0.804203 -0.778427 -0.831741 0.420289 0.579267 cylinders -0.775396 1.000000 0.950721 0.842983 0.896017 -0.505419 -0.348746 displacement -0.804203 0.950721 1.000000 0.897257 0.932824 -0.543684 -0.370164 horsepower -0.778427 0.842983 0.897257 1.000000 0.864538 -0.689196 -0.416361 weight -0.831741 0.896017 0.932824 0.864538 1.000000 -0.417457 -0.306564 acceleration 0.420289 -0.505419 -0.543684 -0.689196 -0.417457 1.000000 0.288137 model_year 0.579267 -0.348746 -0.370164 -0.416361 -0.306564 0.288137 1.000000 상관관계 히트맵 1234567891011fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]sns.heatmap(num_mpg.corr(), ax=ax[0])ax[0].set_title('Basic Correlation Heatmap', pad = 12) # 상관관계 수치 그래프 [Correlation Heatmap with Number]sns.heatmap(num_mpg.corr(), vmin=-1, vmax=1, annot=True, ax=ax[1])ax[1].set_title('Correlation Heatmap with Number', pad = 12)plt.show() Output 위의 코드에서 pad는 히트맵과 타이틀의 간격설정이며,set_title의 인자를 설명하면 (히트맵을 만들 ‘데이터셋.corr()’, 히트맵의 최소값, 최대값, 수치표현(bool값), 마지막인자는 확실하지는 않지만 앞의 히트맵 설정을 어떤 히트맵에 적용시킬지 묻는것 같다.) 상관관계 배열 만들기 1234# import numpy as np# 윗단 코드에서 만들어진 num_mpg 사용print(int(True))np.triu(np.ones_like(num_mpg.corr())) 1 array([[1., 1., 1., 1., 1., 1., 1.], [0., 1., 1., 1., 1., 1., 1.], [0., 0., 1., 1., 1., 1., 1.], [0., 0., 0., 1., 1., 1., 1.], [0., 0., 0., 0., 1., 1., 1.], [0., 0., 0., 0., 0., 1., 1.], [0., 0., 0., 0., 0., 0., 1.]]) np.triu(배열, k=0)는 위 결과처럼 우하향 대각선이 있고 위 아래로 삼각형이 있다 생각했을때 아래쪽의 삼각형이 모두 0이 되는 함수이다.k의 숫자가 낮아질수록 삼각형은 한칸씩 작아진다.위 결과에서 행과 열이 7칸이 된 이유는 np.ones_like(num_mpg.corr())의 행이 7개 이기때문인듯 하다.확실히 모르겠음 질문 필수 12mask = np.triu(np.ones_like(num_mpg.corr(), dtype=np.bool))print(mask) [[ True True True True True True True] [False True True True True True True] [False False True True True True True] [False False False True True True True] [False False False False True True True] [False False False False False True True] [False False False False False False True]] k 값을 바꿔 True와 False로 값을 준 경우. 12345678910# 기본주석 생략fig, ax = plt.subplots(figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]ax = sns.heatmap(num_mpg.corr(), mask=mask, vmin=-1, vmax = 1, annot=True, cmap=&quot;BrBG&quot;, cbar = True)ax.set_title('Triangle Correlation Heatmap', pad = 16, size = 16)fig.show() Output 위의 글들을 모두 읽었음에도 단 하나 모르는 요소가 있다면 바로 cmap일 것이다.cmap은 colormap을 줄인것으로 cmap의 종류는 상당히 많다.이곳에 가면 상당히 잘 정리되어 있으니 cmap옵션을 사용할 때마다 요긴하게 쓸 수 있을것이다. Intermediate페가블로그 코드 https://jehyunlee.github.io/2020/08/27/Python-DS-28-mpl_spines_grids/ 이 챕터의 내용은 코드가 너무 긺으로 시각화 결과물을 접지않고 코드를 접는형식으로 서술하겠음. 필수 코드이므로 생략을 생략 1234import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as np Code 12345678910111213141516171819202122232425262728def plot_example(ax, zorder=0): ax.bar(tips_day[&quot;day&quot;], tips_day[&quot;tip&quot;], color=&quot;lightgray&quot;, zorder=zorder) ax.set_title(&quot;tip (mean)&quot;, fontsize=16, pad=12) # Values h_pad = 0.1 for i in range(4): fontweight = &quot;normal&quot; color = &quot;k&quot; if i == 3: fontweight = &quot;bold&quot; color = &quot;darkred&quot; ax.text(i, tips_day[&quot;tip&quot;].loc[i] + h_pad, f&quot;{tips_day['tip'].loc[i]:0.2f}&quot;, horizontalalignment='center', fontsize=12, fontweight=fontweight, color=color) # Sunday ax.patches[3].set_facecolor(&quot;darkred&quot;) ax.patches[3].set_edgecolor(&quot;black&quot;) # set_range ax.set_ylim(0, 4) return axdef major_formatter(x, pos): return &quot;{%.2f}&quot; % xformatter = FuncFormatter(major_formatter) 123tips = sns.load_dataset(&quot;tips&quot;)tips_day = tips.groupby(&quot;day&quot;).mean().reset_index()print(tips_day) day total_bill tip size 0 Thur 17.682742 2.771452 2.451613 1 Fri 17.151579 2.734737 2.105263 2 Sat 20.441379 2.993103 2.517241 3 Sun 21.410000 3.255132 2.842105 Code 12fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2) Code 123456fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False) Code 12345678910fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) Code 12345678910111213fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) ax.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;) 책 코드 Code 12345678910111213141516import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0]) Code 12345group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)print(&quot;The Best Day:&quot;, h_day)print(&quot;The Highest Avg. Total Biil:&quot;, h_mean) The Best Day: Sun The Highest Avg. Total Biil: 21.41 Code 1234567891011121314151617181920212223tips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)fig.show() Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)fig.show() Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)ax0.set_xlabel(&quot;Weekday&quot;, fontsize=14)for xtick in ax0.get_xticklabels(): print(xtick) if xtick.get_text() == h_day: xtick.set_color(&quot;darkred&quot;) xtick.set_fontweight(&quot;demibold&quot;)ax0.set_xticklabels(['Thursday', 'Friday', 'Saturday', 'Sunday'], size=12)ax1 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, alpha=0.85, ax=ax[1])for p in ax1.patches: height = np.round(p.get_height(), 2) ax1.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12)ax1.set_ylim(-3, 30)ax1.set_title(&quot;Just Bar Graph&quot;)plt.show() Text(0, 0, 'Thur') Text(0, 0, 'Fri') Text(0, 0, 'Sat') Text(0, 0, 'Sun')","link":"/2021/11/03/python_visualization_basic_/"},{"title":"파이썬(Python) 사용자 지정 함수","text":"사용자 지정 함수란? 파이썬에서(다른프로그래밍 언어, 스크립트 언어에서도) 함수란, 소프르웨어에서 특정 동작을 수행하는 일정 코드부분을 의미한다. 하나의 큰 프로그램을 여러부분으로 나누어주기 때문에 같은 함수를 여러 상황에서 여러차례 호출할 수 있고, 일부분을 수정하기 쉽다는 장점을 지닌다. 파이썬에서는 미리 정의 되어있는 built in 함수(내장함수)가 있고. 또, 사용자가 필요에 의해 정의를 한 사용자 지정 함수가 존재한다. 파이썬에서의 함수 모형 파이썬 함수의 기본 모형1234def 함수명() : 실행문 실행문 ... 이와 같은 구조인데 함수를 정의하는 def뒤에 함수명이 오고 소괄호()를 붙인 다음 콜론:을 붙여주고, 다음줄에 원하는 실행문을 들여쓰기하여 사용하면 된다. 12def func() : print('python function') 위는 기본 모형을 응용하여 함수를 정의한 것이다. 이는 입력값도, 반환값도 없는 함수이며 값이 있는 함수에 대해서는 후술하겠다. 그러나 위 코드는 함수를 정의한 것이지 사용을 한 것이 아니다. 그렇기 때문에 함수를 사용하기 위해서는 함수의 사용법을 알아야 한다. 12345def func() : print('python function')#함수 호출func() Output 1python function func()함수는 입력값이 없기때문에 호출시에 입력값을 넣어주지 않고 괄호만 입력해 준다. 입력값만 있는 함수 123456def func2(a) : print('입력한 문자는 ' + a + ' 입니다.')func2(&quot;비행기&quot;)func2(&quot;자동차&quot;)func2(&quot;파이썬&quot;) Output 123입력한 문자는 비행기 입니다.입력한 문자는 자동차 입니다.입력한 문자는 파이썬 입니다. func2()함수의 입력값이 a 에 입력되어 출력 된 것을 볼 수 있다. 리턴값만 있는 함수 1234def func3() : return &quot;12345&quot;print(func3()) Output 112345 func3()의 값이 리턴되어 print()를 통해 출력된 것을 알 수 있다. 입력,리턴값이 모두 있는 함수 1234def func4(a, b) : return a + bprint(func4(10,20)) Output 130 a,b의 입력값을 더하는 함수에 10,20의 값을 주었더니 예상대로 30이 출력 되었다. 기본 인자 값 입력이 있는 함수를 여러 곳에 사용할 때 반복되는 값에 대해서는 기본적인 값을 지정할 수 있다.기본값은 입력 = 값의 형태로 작성된다. 12345def func_b(a,b,c=5) : return a*b+cprint(func_b(2,3,10))print(func_b(2,3)) Output 121611 출력에서처럼 기본값이 주어진 c 인자에 별다른 값을 넣지 않으면 기본값 5로 계산되어 10이들어간 결과보다 5가 낮아지게 된다. 이렇게 기본 인자를 줄 때는 주의 할 점이 한 가지 있는데 바로 인자의 순서에 맞게 넣어주어야 한다는 것과, 기본값과 입력값이 없으면 에러가 난다는 것이다.다음 예시를 보자. 1234def func_b2(a,b=5,c) : return a*b+cprint(func_b2(2,3)) 위와 같이 값을 주게 된다면 어떨까?b에 기본값이 있으니 a와 c에 각각 2와 3이 입력된다고 생각한 사람도 있을 것이다.그러나 이 생각은 적어도 사용자 지정 함수에서는 옳지 않다. 이 코드가 불가능한 데에는 두 가지 이유가 있다. 첫 번째로는 a에는 2가 들어가는 것이 맞겠지만, b에 기본값이 있더라도 두 번째 입력값 자리에 3을 넣게 되는 순간 그 숫자는 b에 입력되기 때문에 결국엔 기본값이 없는 c는 어떠한 값도 입력받지 못하게 되기 때문이고, 두 번째 이유로는 c의 인자에 기본값이 없음에도 앞에 있는 b의 인자에 기본값이 있으므로 아예 성립할 수 없는 코드이다.그러므로 기본값을 부여받은 인자는 항상 뒤에 배치해야 한다. 키워드 인자 키워드 인자는 함수를 정의할때 인자에 키워드를 부여하고 함수를 호출할 때 키워드=값의 형태로 넣어줄 수 있는 인자이다.그냥 인자에 값을 넣어주는것과 뭐가 다르냐?라는 의문이 들 수도 있다.다음 예시를 보자. 1234def score(kim=100, lee=100, park=100, choi=100) : print('score = kim :', kim, 'lee :',lee, 'park :',park, 'choi :',choi)score(park= 50) Output 1score = kim : 100 lee : 100 park : 50 choi : 100 이렇게 중간의 인자만 키워드=값의 형태로 입력해 값을 변경해 줄 수 있다.예제처럼 여러 기본값이 있고 그중 몇 가지의 기본값만 바꿔 주어야 할 때 용이하게 쓸 수 있다. Arbitrary Argument Lists (임의 인자 리스트) Arbitrary Argument Lists는, 여러인자를 함수에 잔달하는 방법들중 하나이다. 함수내부에서 이 인자들은 튜플로 감싸져있으며 이는*argsarguments 생성자를 사용하여 정의 된다. 12345678910def avg_score(*numbers) : s = 0 count = 0 for i in numbers: s += i count += 1 return s / countprint('국어와 수학점수의 평균은{}점 입니다'.format(avg_score(95, 87)))print('입력된 숫자들의 평균은{} 입니다.'.format(avg_score(42,63,45,32,48))) Output 12국어와 수학점수의 평균은91.0점 입니다입력된 숫자들의 평균은46.0 입니다. 위 코드에서는 *args를 *numbers로 대체했다.이처럼 함수를 호출 할 때에 숫자를 몇가지를 넣어도 사용이 가능하다. Lambda 함수 우리가 앞에서 배웠던 대로 사용자 지정 함수를 정의하고 사용하여 평균을 구하라고 한다면 아마 다음과 같을것이다. 12345def avg(x,y): return(x + y) / 2print(avg(5,13))&gt;&gt; 9.0 그러나 파이썬은 Lambda함수를 통해서 이 코드를 더욱 짧게 줄일수 있다. 123print((lambda x,y: (x + y)/2)(5,13))&gt;&gt; 9.0 그러나 배우는 입장인 내 눈으로 단점을 찾아보자면 함수인데 정의를 하는 부분이 따로 없다 보니, 출력할 일이 여러 번 생긴다면 번거로워 질 것 같다.그러니 앞으로 호출 횟수에 따라 적다면 람다 함수를, 많다면 기본적인 사용자 지정 함수를 사용하는 방식이 좋을 듯하다. References https://djangojeng-e.github.io","link":"/2021/11/10/Python-UserDefinedFunctions/"},{"title":"산점도(scatter plot)와 박스플롯(box plot)","text":"산점도(scatter plot)산점도란? 산점도, 산포도scatter plot는 직교좌표계를 이용해 좌표상의 점들을 표시함으로써 두 개 변수 간의 관계를 나타내는 그래프 방법이다.도표 위에 두 변수 X와 Y값이 만나는 지점을 표시한 그림. 이 그림을 통해 두 변수 사이의 관계를 알 수 있다. 언제 사용되는가?? 산점도는 다음의 경우에 사용된다. 두 종류의 데이터의 관계를 파악할때. 즉, 양의 상관관계, 음의 상관관계, 관계없음 등의 관계를 파악한다. 산점도의 작성으로 한 변수에 대한 결과의 영향조사를 한다. Plotly로 산점도 작성하기 데이터 임포트 및 데이터셋 생성123456789import numpy as npimport pandas as pd# plotly 라이브러리 불러오기import plotly.offline as poimport plotly.graph_objs as go# 임의의 숫자로 이루어진 2열,100행의 데이터프레임 생성df1 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B'])df2 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B']) 하나의 산점도 그리기 123trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers')data = [trace1]pyo.iplot(data) Output df1이 그대로 산점도로 출력된 모습이다. 두 개 이상의 산점도 그리기 1234trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers')trace2 = go.Scatter(x=df2['A'], y=df2['B'], mode='markers')data = [trace1, trace2]pyo.iplot(data) Output df1과 df2가 한 도표 내에 산점도로 출력된 모습이다.이렇게 다른 데이터를 표시하고 싶을때에는 출력코드에 새로운 데이터값을 넣어주기만 하면 된다. 마커 모양 변경하기 1234trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers', marker=dict(size=7, color='#D90B0B', symbol=20))trace2 = go.Scatter(x=df2['A'], y=df2['B'], mode='markers', marker=dict(size=7, color='#F24444', symbol=23))data = [trace1, trace2]pyo.iplot(data) Output 그림처럼 마커의 모양을 변경 할 수 있다.color옵션은 헥스코드와 rgb값 모두 가능하며, 모양의 경우 매우 다양하므로 포스팅 최하단에 링크를 첨부한다. 박스플롯 (box plot)박스플롯이란?? ‘박스플롯’box plot,또는 ‘상자 수염 그림’은 수치적 자료를 나타내는 그래프이다. 이 그래프는 가공하지 않은 자료 그대로를 이용하여 그린 것이 아니라, 자료로부터 얻어낸 통계량인 ‘5가지 요약 수치’five-number summary 를 가지고 그린다. 이 때 5갸지 요약 수치란 최솟값, 제 1사분위(Q1),제 2사분위(Q2), 제 3사분위(Q3), 최댓값을 일컫는 말이다. 히스토그램과는 다르게 집단이 여러개인 경우에도 한 공간에 수월하게 나타낼수 있다. 언제 사용되는가?? 박스 플롯을 사용하는 이유는 데이터가 매우 많을때 모든 데이터를 한눈에 확인하기 어려우니 그림을 이용해 데이터 집합의 범위와 중앙값을 빠르게 확인 할 수 있는 목적으로 사용한다.또한, 통계적으로 이상치outlier가 있는지도 확인이 가능하다. 박스플롯의 구성 박스플롯을 처음 접한다면 박스플롯을 어떻게 해석해야 하는지 난해할수 있다.다음 그림에서 박스플롯의 각 구성이 무엇을 의미하는지 간단하게 알아보자.각 요소들을 설명하면 다음과 같다. 요소 설명 이상치(outlier) 최소값보다 작은데이터 또는 최대값보다 큰 데이터가 이상치에 해당한다 최대값(upper whisker) ‘중앙값 + 1.5 × IQR’보다 작은 데이터 중 가장 큰 값 최소값(lower whisker) ‘중앙값 - 1.5 × IQR’보다 큰 데이터 중 가장 작은 값 IQR(Inter Quartile Range) 제3사분위수 - 제1사분위수실수 값 분포에서 1사분위수(Q1)와 3사분위수(Q3)를 뜻하고 이 3사분위수와 1사분위수의 차이(Q3 - Q1)를 IQR라고 한다. 중앙값 박스내부의 가로선, 용어 그대로 중앙값이다 whisker 상자의 상하로 뻗어있는 선 Plotly로 박스플롯 작성하기 1234567891011import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdf3 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B']) #임의로 수 생성plt.figure(figsize=(8,7)) # 크기 지정boxplot = df3.boxplot(column=['B']) # df3의 'B'컬럼을 박스플롯으로 생성plt.yticks(np.arange(0,101,step=5)) # 박스플롯이 그려질 범위 지정plt.show() Output 위처럼 임의로 생성된 데이터프레임을 이용해 박스플롯을 만들 수 있다. References산점도 그리기산점도 마커 모양위키백과 - 산점도위키백과 - 상자 수염 그림박스플롯 및 요소 설명","link":"/2021/11/12/scatterPlot-boxPlot/"},{"title":"2021 캐글 대회 코드 작성기 - 1","text":"파이썬을 배운지 며칠 되지 않아 kaggle이라는 예측모델 및 분석대회 플랫폼의 데이터 분석 대회에 참가하게 되었다.주제는 2021년 캐글러kaggler들에게 설문조사이며, 그 설문조사 데이터셋을 바탕으로 참가자가 분석을 하여 참가자만의 주제에 그래프와 수치로 답을 찾아내는 대회이다. 데이터셋에 있는 캐글러의 수는 19년 19717명, 21년 25974명, 직업은 데이터사이언스, 데이터 엔지니어부터 학생까지 다양하며, 나이, 학력, 국적, 라이브러리, 언어 등 매우 다양한 항목들이 있다. 우리 조에서 처음으로 선정하려 했던 주제는 한국, 일본, 중국의 캐글러의 트렌드변화로 하려 했으나, 중국, 일본에 비해 데이터가 턱없이 부족해 비교가 무의미한 수준이었기에 캐글러의 수가 비슷한 두 나라인 중국과 일본로 선정했다.(의외로 중국의 캐글러 절대적인 수가 인구에 비해 상당히 적어 일본보다 조금 적은편이였다.) import(Kaggle notebook) 1234567891011121314151617import numpy as np import pandas as pdimport matplotlib.pyplot as pltimport plotly.express as pximport plotly.graph_objects as gofrom warnings import filterwarningsfrom plotly.subplots import make_subplotsfilterwarnings('ignore')colors = ['#B1EDED','#B1B2ED','#1DE7ED','#1DA5ED','#1D50ED','#16548E']gen_colors = ['#4169E1','#B2182B','#81007F','#D1B2FF','#EFE4E2']JP_colors = ['#D90B0B','#F24444','#EFE4E2','#FCCE88','#64807F']CN_colors = ['#E0201B','#FFCE3F','#A63F03','#04BF33','#F2E6D8']coun_years_colors = ['#D90B0B','#FFCE3F','#FF6161','#FFDB81']df19 = pd.read_csv('../input/kaggle-survey-2019/multiple_choice_responses.csv')df21 = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv') 이처럼 후에 사용할 라이브러리를 임포트, 그래프에 사용할 색을 리스트로 만들어주고 df19에 19년의 데이터셋을, df21에 21년의 데이터셋을 넣어준다. 사용자 지정 함수 12345678910def group(data, country, question_num): return data[data['Q3'] == country][question_num].value_counts()def go_Pie(country, label_value): return go.Pie(title = country, labels = label_value.index, values = label_value.values, textinfo = 'label+percent', rotation=315, hole = .3,) 앞으로 코드에서 사용될 함수이다.사용자 지정 함수란? Q1. What`s your age? 12345678910111213141516171819202122232425262728JP_age_19 = group(df19,'Japan','Q1').sort_index()JP_age_21 = group(df21,'Japan','Q1').sort_index()CN_age_19 = group(df19,'China','Q1')CN_age_19.loc['55-59'] = 0CN_age_19.loc['60-69'] = 0CN_age_19 = CN_age_19.sort_index()CN_age_21 = group(df21,'China','Q1')CN_age_21.loc['60-69'] = 0CN_age_21 = CN_age_21.sort_index()fig_age = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]])fig_age.add_trace(go.Bar(name=coun_years[0], x=JP_age_19.index, y=JP_age_19.values, marker_color='#FDB0C0'),1,1)fig_age.add_trace(go.Bar(name=coun_years[2], x=JP_age_21.index, y=JP_age_21.values, marker_color='#FD4659'),1,1)fig_age.add_trace(go.Bar(name=coun_years[1], x=CN_age_19.index, y=CN_age_19.values, marker_color='#FFDB81'),1,2)fig_age.add_trace(go.Bar(name=coun_years[3], x=CN_age_21.index, y=CN_age_21.values, marker_color='#FFAB0F'),1,2)fig_age.update_layout(barmode='group', title_text='2019 &amp; 2021, Japan and China age distribution', showlegend=True)fig_age.update_xaxes(title_text='Japan Age distribution', row=1, col=1)fig_age.update_yaxes(title_text='Counts', row=1, col=1)fig_age.update_xaxes(title_text='China Age distribution', row=1, col=2)fig_age.update_yaxes(title_text='Counts', row=1, col=2)fig_age.show() 첫번째 주제인 What`s your age?에 대한 일본과 중국의 캐글러 나이분포를 막대그래프로 나타낸 것이다.각 그래프는 연도별로 나눈 일,중 캐글러의 나이 분포이고 그래프의 항목은 18세부터 70세 이상까지 3,4년씩을 한 항목으로 묶었다. Q2. What`s your gender? 1234567891011121314151617181920212223242526272829303132333435363738394041JP_ndarray = df19[df19['Q3'] == 'Japan']['Q2'].valuesCN_ndarray = df19[df19['Q3'] == 'China']['Q2'].valuesJP_age_list = []CN_age_list = []for item in JP_ndarray: if item == 'Male': item_mod = item.replace('Male','Man') JP_age_list.append(item_mod) elif item == 'Female': item_mod2 = item.replace('Female','Woman') JP_age_list.append(item_mod2) else : JP_age_list.append(item) for item in CN_ndarray: if item == 'Male': item_mod = item.replace('Male','Man') CN_age_list.append(item_mod) elif item == 'Female': item_mod2 = item.replace('Female','Woman') else : CN_age_list.append(item)JP_age_series = pd.Series(JP_age_list)CN_age_series = pd.Series(CN_age_list)fig = make_subplots(rows=2, cols=2, specs=[[{'type':'domain'}, {'type':'domain'}], [{'type':'domain'}, {'type':'domain'}]])fig.add_trace(go_Pie('2019_Japan', JP_age_series.value_counts()),1,1)fig.add_trace(go_Pie('2019_China', CN_age_series.value_counts()),1,2)fig.add_trace(go_Pie('2021_Japan', group(df21,'Japan','Q2')),2,1)fig.add_trace(go_Pie('2021_China', group(df21,'China','Q2')),2,2)fig.update_traces(marker=dict(colors=gen_colors[0:]))fig.update_layout(title_text='Gender Distribution', showlegend=True, autosize=True, height=700)fig.show() 두번쨰 질문에 답하기 위해 일본과 중국의 캐글러 성별분포를 도넛모양으로 나타낸 그래프이다.각각의 그래프는 국가,년도(2019, 2021)별로 각각 나누었고 그래프의 항목은ManWomanPrefer not to sayNonbinaryPrefer to self-describe이렇게 다섯가지로 나누었다. Referencesplotly bar chart tutorialplotly bar chart properties (bar traces)plotly pie chart tutorialplotly pie chart properties (pie traces)","link":"/2021/11/17/kaggle-2021survey-code-1/"},{"title":"2021 캐글 대회 코드 작성기 - 2","text":"Q3. In which country do you currently reside? 1234567891011121314151617181920years = ['2019', '2021']JP_country_count_19 = (df19[df19['Q3'] == 'Japan']['Q3']).count()CN_country_count_19 = (df19[df19['Q3'] == 'China']['Q3']).count()JP_country_count_21 = (df21[df21['Q3'] == 'Japan']['Q3']).count()CN_country_count_21 = (df21[df21['Q3'] == 'China']['Q3']).count()JP_country_count_19_21 = [JP_country_count_19, JP_country_count_21]CN_country_count_19_21 = [CN_country_count_19, CN_country_count_21]fig_country = go.Figure(data=[ go.Bar(name='Japan', x=years, y=JP_country_count_19_21, marker_color=JP_colors[0]), go.Bar(name='China', x=years, y=CN_country_count_19_21, marker_color=CN_colors[1])])fig_country.update_layout( barmode='group', title_text='2019 &amp; 2021, the number of Kaggler living in Japan and China', xaxis_title='Years', yaxis_title='Counts')fig_country.show() 2019년과 2021년 일본과 중국 캐글러의 수를 비교한 막대그래프이다.일본은 빨강 중국은 노란색 막대로 표현했으며 일본의 수치가 인구 대비 상당히 높은 걸 알 수 있다.양국 모두 캐글러의 수치가 증가했다.2년간 일본은 약 35%, 중국은 약 40%가 증가했으며 증가한 캐글러의 수는 일본이 높지만 비율은 중국이 앞섰다. Q14. What data visualization libraries or tools do you use on a regular basis? 12345678910111213141516171819202122232425262728293031323334353637383940414243df19_JP = df19[df19.Q3.isin(['Japan'])]df19_CN = df19[df19.Q3.isin(['China'])]df21_JP = df21[df21.Q3.isin(['Japan'])]df21_CN = df21[df21.Q3.isin(['China'])]df19_JP_Q14 = pd.DataFrame()df19_CN_Q14 = pd.DataFrame()df21_JP_Q14 = pd.DataFrame()df21_CN_Q14 = pd.DataFrame()df19_JP_Q14['Q20'] = [df19_JP[col][1:].value_counts().index[0] for col in df19_JP.columns[97:109]]df19_CN_Q14['Q20'] = [df19_CN[col][1:].value_counts().index[0] for col in df19_CN.columns[97:109]]df21_JP_Q14['Q14'] = [df21_JP[col][1:].value_counts().index[0] for col in df21_JP.columns[59:71]]df21_CN_Q14['Q14'] = [df21_CN[col][1:].value_counts().index[0] for col in df21_CN.columns[59:71]]df19_JP_Q14['counts'] = [df19_JP[col][1:].value_counts().values[0] for col in df19_JP.columns[97:109]]df19_CN_Q14['counts'] = [df19_CN[col][1:].value_counts().values[0] for col in df19_CN.columns[97:109]]df21_JP_Q14['counts'] = [df21_JP[col][1:].value_counts().values[0] for col in df21_JP.columns[59:71]]df21_CN_Q14['counts'] = [df21_CN[col][1:].value_counts().values[0] for col in df21_CN.columns[59:71]]df19_JP_Q14.index = [3,0,6,4,5,2,7,1,8,9,10,11]df19_CN_Q14.index = [3,0,6,4,5,2,7,1,8,9,10,11]df19_JP_Q14 = df19_JP_Q14.sort_index()df19_CN_Q14 = df19_CN_Q14.sort_index()df21_JP_Q14['Q14'].index = [0,1,2,3,4,5,6,7,8,9,10,11]df21_CN_Q14['Q14'].index = [0,1,2,3,4,5,6,7,8,9,10,11]df19_JP_Q14.replace(regex = 'D3.js', value = 'D3 js', inplace = True)df19_CN_Q14.replace(regex = 'D3.js', value = 'D3 js', inplace = True)fig_T = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]])fig_T.add_trace(go.Bar(name=coun_years[0], x=df19_JP_Q14['Q20'].values, y=df19_JP_Q14['counts'], marker_color=coun_years_colors[0]),1,1)fig_T.add_trace(go.Bar(name=coun_years[1], x=df19_CN_Q14['Q20'].values, y=df19_CN_Q14['counts'], marker_color=coun_years_colors[1]),1,1)fig_T.add_trace(go.Bar(name=coun_years[2], x=df21_JP_Q14['Q14'].values, y=df21_JP_Q14['counts'], marker_color=coun_years_colors[2]),1,2)fig_T.add_trace(go.Bar(name=coun_years[3], x=df21_CN_Q14['Q14'].values, y=df21_CN_Q14['counts'], marker_color=coun_years_colors[3]),1,2)fig_T.update_layout(title_text='2019 &amp; 2021, Visualization Library and Tools in Use', showlegend=True, autosize=True)fig_T.update_xaxes(title_text='2019 Library and Tools', row=1, col=1)fig_T.update_yaxes(title_test='Counts', row=1, col=1)fig_T.update_xaxes(title_text='2021 Library and Tools', row=1, col=2)fig_T.update_yaxes(title_text='Counts', row=1, col=2)fig_T.show() 각 그래프를 연도로 나누고 그래프에는 그에 해당하는 라이브러리,툴 사용량을 국가별로 나누어 넣은 막대그래프이다.양국 모두 전반적으로 증가하였으나 눈에띄는 부분은 중국의 None항목이 크게 늘었고, 중국은 모든 항목의 사용량이 증가한 반면에 일본은 감소세가 보이는 항목이 있었다. Q16. Which of the following machine learning frameworks do you use on a regular basis? 1234567891011121314151617fig_F = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]]) fig_F.add_trace(go.Bar(name=coun_years[0], x=df19_JP_Q16['Q28'].values, y=df19_JP_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[0]),1,1)fig_F.add_trace(go.Bar(name=coun_years[1], x=df19_CN_Q16['Q28'].values, y=df19_CN_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[1]),1,1)fig_F.add_trace(go.Bar(name=coun_years[2], x=df21_JP_Q16['Q16'].values, y=df21_JP_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[2]),1,2)fig_F.add_trace(go.Bar(name=coun_years[3], x=df21_CN_Q16['Q16'].values, y=df21_CN_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[3]),1,2) fig_F.update_layout(title_text='2019 &amp; 2021, Machine Learning Frameworks in Use', showlegend=True, autosize=True)fig_F.update_xaxes(title_text='2019 Machine Learning Frameworks', row=1, col=1)fig_F.update_yaxes(title_text='Counts', row=1, col=1)fig_F.update_xaxes(title_text='2021 Machine Learning Frameworks', row=1, col=2)fig_F.update_yaxes(title_text='Counts', row=1, col=2)fig_F.show() 이번 질문에대한 답도 비슷하다. 그래프는 연도로 나누고 각각의 x축에는 사용하는 머신러닝 프레임워크, y축에는 그 수가 표기되어 얼마나 많은 캐글러가 머신러닝 프레임워크를 사용하지는 나타낸다.각 년도의 차이점은 (프레임워크의 사용자의 수는 물론이거니와)프레임워크의 종류가 19년도에 비해 21년에 약증했다는 점이 있고, 특이점이라면 21년 일본의 사이킷런Scikit-learn 사용자의 수가 급증했다는 점이 있다.","link":"/2021/11/19/kaggle-2021survey-code-2/"},{"title":"Github Repository생성 및 로컬 저장소 연결, 업로드 명령어","text":"Github repository 생성 로그인된 깃허브 홈페이지에서 Your repositories &gt; 우상단 New 버튼을 클릭한 후 Repository name을 입력하여 리포지토리를 생성한다. Repository와 로컬 저장소를 연결 Repository와 같은 이름으로 폴더를 하나 생성해 준 후 폴더 아무곳이나 우클릭하여 Git Bash Here로 터미널을 실행해준다. 1$ cd [Directory] 디렉토리 주소를 입력하면 바탕화면에서 터미널을 실행하여 명령어로 진입 할 수도 있다. 1$ git init 명령어를 입력해 업로드할 폴더에서 깃을 init한다.(로컬 저장소 생성) 우측의 copy버튼을 클릭하여 주소를 복사한다. 1$ git remote add origin [Repository URL] 명령어를 입력해준 후 위에서 복사했던 주소를 붙여넣어준다. (Git Bash에서의 붙여넣기는 Shift + Insert) Repository URL을 잘못입력했다면 아래 명령어들을 참고하면 된다. 현재 로컬 저장소의 Repository URL 확인 : $ git remote -v 현재 로컬 저장소의 Repository URL 변경 : $ git remote set-url origin [재설정할 Repository URL] 현재 로컬 저장소의 Repository URL 삭제 : $ git remote remove origin 로컬 저장소에 있는 파일을 업로드로컬 저장소에 있는 파일을 깃허브에 업로드하기 위해서는 다음 세가지의 명령어를 차례로 입력해주어야 한다. 12$ git add .$ git add file.py 위처럼 add 명령어로 commit 될 대상에 파일을 포함시킬수 있다.add . 은 변동사항이 있는 모든파일을, 두번째줄은 해당파일만 포함시킨다. 1$ git commit -m &quot;표시할 메세지&quot; 파일을 커밋하고 그 커밋에 대해 간단한 메세지를 남기는 명령어이다. 12$ git push$ git push origin HEAD:master 커밋한 파일들을 깃허브로 올려주는 명령어이다.첫째 줄 명령어로 푸시가 안된다면 아래 명령어를 입력해보자 성공적으로 연결되어 커밋, 푸시까지 된 모습이다.","link":"/2021/11/26/Link_github_repository/"},{"title":"plotly를 사용하여 막대그래프 만들기","text":"캐글 대회에 참가하면서 파이썬 문법이나 plotly의 특성에 대해 구글링하는 시간이 훨씬 늘었다.앞으로도 대회에 참가하거나 시각화를 할 때에 이렇게나 많은 특성을 모두 외울수는 없으니 구글링을 하게 될 텐데, 자주쓰는 속성이나 기본틀에 대해서는 포스팅을 해두고 바로바로 찾아보는것이 좋겠다는 생각이 들었다. 그래서 이번 포스팅에서는 앞으로 자주 사용하게 될 차트 중 하나인 막대그래프의 기본 틀과 자주 사용되는 속성에 대해 포스팅 하려 한다. 데이터는 2021 Kaggle Machine Learning &amp; Data Science Survey 대회의 데이터를 사용한다. import 및 데이터 불러오기12345import plotly.graph_objects as goimport pandas as pdfrom plotly.subplots import make_subplotsdf21 = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv') 필요한 라이브러리를 import 해주고 데이터를 불러와 저장해준다.필자는 캐글노트북에서 작성하여 data add 기능으로 kaggle에 있는 데이터를 바로 불러왔지만 로컬이나 colab, jupyter등의 다른 노트북을 사용중이라면 데이터를 다운받은후 괄호안의 경로를 재설정해주어야 한다. 출력할 데이터 확인1df21[0:5][Q1,Q14] # Q1,Q14 항목의 값 0부터 4까지 출력 ㅤ Q1 Q3 0 What is your age (# years)? In which country do you currently reside? 1 50-54 India 2 50-54 Indonesia 3 22-24 Pakistan 4 45-49 Mexico 이렇게 출력하거나 1df21[df21['Q3'] == &quot;South Korea&quot;] # Q3 항목의 값이 &quot;South Korea&quot;인 행의 데이터프레임 출력 위 코드처럼 어느 조건에 해당하는행을 출력 할 수도 있다. 12KR_Age = df21[df21['Q3'] == 'South Korea']['Q1'].value_counts()JP_Age = df21[df21['Q3'] == 'Japan']['Q1'].value_counts() 위 코드는 Q3(국가)이 South Korea인 행과 Japan인 행의 Q1(연령)값을 뽑아내는 코드로 이를 통해 그래프를 만들어 볼 것이다. 다중 차트 틀 만들기위에서 import한 make_subplots으로 차트여러개를 출력 할 수 있다. 1fig = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]]) fig 객체를 생성해주고 차트를 1행, 2열로 만들어주는 코드이다.막대그래프의 경우엔 'type':'xy' 파이그래프의 경우엔 'type':'domain'으로 할수있다.specs에서 중괄호는 차트한개를 나타내며 내부의 중괄호가 여러개라면 각각 행을 구분하는 용도로 쓰인다. 각 속성으로 차트 그리기1234567891011fig.add_trace(go.Bar(name='Korea', x=KR_Age.index, y=KR_Age.values, marker_color='red'),1,1)fig.add_trace(go.Bar(name='Japan', x=JP_Age.index, y=JP_Age.values, marker_color='blue'),1,2)fig.update_layout(barmode='group', title_text='2021, Korea and Japan age distribution', showlegend=True)fig.update_xaxes(title_text='Korea Age distribution', row=1, col=1)fig.update_yaxes(title_text='Counts', row=1, col=1)fig.update_xaxes(title_text='Japan Age distribution', row=1, col=2)fig.update_yaxes(title_text='Counts', row=1, col=2)fig.show() add_trace, update_layout 등의 파라미터(속성)값으로 그래프를 꾸미는 코드이다. fig.add_trace(go.Bar(name='Korea', x=KR_Age.index, y=KR_Age.values, marker_color='red'),1,1)부터 살펴보면go.Bar는 막대그래프를 뜻한다, 각 파라미터를 살펴보면name는 그래프에 표현되는 항목의 이름,x는 그래프의 x축이 나타낼 항목,y는 그래프의 y축이 나타낼 값,marker_color은 그래프의 색을 표현하며가장 끝의1,1는 위 항목이 표시될 그래프의 행,열을 뜻한다.(그러니 1번째 행 1번째 열의 그래프에 Korea 항목이 들어간다.) fig.update_layout(barmode='group', title_text='2021, Korea and Japan age distribution', showlegend=True)도 뜯어보겠다.barmode는 한 그래프에 여러 항목이 들어있을 경우 어떻게 나타내는지에 대한 속성인데 대표적으로 group과stack이 있다.title_text는 제목, showlegend는 범례 표기 여부를 가리킨다. 마지막의 fig.show()는 fig객체를 출력하는 코드이다. 아래 References에 막대그래프의 파라미터가 정리되있는 링크를 걸어놓을테니 활용하여 다양하게 그래프를 만들어보자. References plotly bar chart tutorial plotly bar chart properties (bar traces)","link":"/2021/11/24/plotly-Bar-Chart-basic/"},{"title":"파이썬 데코레이터 (Python Decorator)","text":"데코레이터란? 파이썬으로된 소스코드들을 보면, 가끔 다음과 같은 구문을 볼 수 있다. 123@decoratordef func() print(&quot;How to use Python&quot;) 본적은 있는것 같으나 어디에 어떻게 사용되는지 처음보는사람은 모를 수 있다.데코레이터는 함수를 수정하지 않은 상태에서 추가기능을 구현할 때 사용한다.일단 다음의 예시를 보자 12345678def func1(): print(&quot;func1&quot;)def func2(): print(&quot;func2&quot;)func1()func2() 위 두개의 함수에 각각 시작부분과 끝부분을 표기하고싶다면 아래와 같이 함수 시작, 끝부분에 print를 따로 넣어주어야 한다. 123456789101112def func1(): print(&quot;func1 start&quot;) print(&quot;func1&quot;) print(&quot;func1 end&quot;)def func2(): print(&quot;func2 start&quot;) print(&quot;func2&quot;) print(&quot;func2 end&quot;)func1()func2() 함수가 한개, 두개라면 부담이 되지않겠지만 만약 10개, 100개, 1000개의 함수가 있고 그것을 수정해야한다면 여간 귀찮은 일이 아닐것이다. 이런 경우에 데코레이터를 사용하면 편리하다.바로 다음 예시를 보자 1234567891011121314151617181920212223def dec(func): def wrapper(func): print(func.__name__, &quot;start&quot;) func() print(func.__name__, &quot;end&quot;) return wrapperdef func1(): print(&quot;func1&quot;)def func2(): print(&quot;func2&quot;)dec_func1 = dec(func1)dec_func1()dec_func2 = dec(func2)dec_func2()'''또는dec(func1)()dec(func2)()''' 1234567&lt;Output&gt;func1 startfunc1func1 endfunc2 startfunc2func2 end 위처럼 입력하게 될 경우 먼저 만들어졌던 dec 함수에 의해 func1, func2의 함수 출력부분에 시작과 끝을 나타내는 print가 같이 출력되게 할 수 있다. 위 코드에서 start 와 end 앞에 있는 func1,func2의 경우에는 함수의 이름이 출력되는것이고, 그 사이에 있는 func1,func2은 함수의 print 열이 출력된 것이다. @가 있는 데코레이터 사용하기 그런데 처음에 예시로 보았던 @로 시작하는 데코레이터는 어디에도 보이지 않는다.@를 사용하는 데코레이터는 어떻게 만드는 것일까? @를 사용하는 데코레이터는 다음과 같이 작성한다. 123@decdef func1(): print(&quot;func1&quot;) 간결하게 적어서 이해가 어려울 수 있으니 이전 챕터의 가장 뒷부분 코드를 가져와 수정해보면 다음과 같다. 1234567891011121314151617def dec(func): def wrapper(): print(func.__name__, &quot;start&quot;) func() print(func.__name__, &quot;end&quot;) return wrapper@decdef func1(): print(&quot;func1&quot;)@decdef func2(): print(&quot;func2&quot;)func1()func2() 결과는 같지만 무엇보다 출력부분이 매우 간결해졌다. 만약 한개의 함수에 데코레이터 여러개를 사용해야한다면 다음과 같이 할 수 있다. 12345@dec1@dec2@dec3def func1(): print(&quot;func1&quot;) 코드가 위와 같을 때 여러개의 데코레이터가 지정되며 이때 데코레이터가 실행되는 순서는 위에서 아래 순으로 실행된다. 마지막으로 데코레이터를 그림으로 표현하면 다음과 같다. Referencehttps://bluese05.tistory.com/30","link":"/2021/12/07/Python-Decorator/"},{"title":"파이썬(Python) with 구문","text":"with 구문이 무엇인가? 보통 프로그램은 파일에 접근해서 파일 내용등을 읽고 쓰고 수정하는등의 일을 수행한 뒤 다시 그 파일을 마운트 해제 하는 패턴을 따른다.예시로 사용자가 워드파일 문서 작업을 하고 있을 때 그 파일을 열고있는 동안 파일관리자가 그 문서의 이름을 바꾼다던지 파일의 경로를 변경한다던지 같은 파일에 접근을 필요로하는 행동을 타 프로그램에서 할 수 없게 된다. 결론만 말하자면 파일에 접근했으면(열었으면) 해제하는(닫아주는) 일을 빼먹지 않고 해주어야 한다는 것이다.보통 close() 같은 메소드를 사용하여 파일을 닫아주지만 이는 문제점이 있다.파일 처리를 수행하는 도중에 오류가 발생하게되면 아래에있는 close() 문을 실행할 수 없고 파일을 닫을수 없게된다. with 문은 그 구문을 실행했을 때 오류가 발생하던 하지않던 마지막에 close 를 해주도록 하는 것이다. with문 사용 예시 123456789101112131415# 일반적인 코드file = open('textfile.txt', 'r')contents = file.read()file.close()# try finally를 사용한 코드try: file = open('textfile.txt', 'r') contents = file.read()finally: file.close() # with 구문을 사용한 코드with open('textfile.txt', 'r') as file: contents = file.read() 위의 세가지 코드는 모두 같은 내용이지만 첫번째 코드를 실행할때 contents = file.read() 행에서 에러가 난다면 file.close()를 실행하지 못해 파일을 닫을 수 없다.그러나 아래의 두가지 코드는 에러가 발생해도 코드를 닫을 수 있을 뿐더러 with문은 더욱 간결하여 보기 편하다. 여러개의 파일 관리하기 두 개 이상의 파일을 동시에 사용할 때 with as 문을 사용하는 방법이다.두개의 with as 문을 겹쳐도 되고, 하나의 with문에 두 개 이상의 파일을 열어도 된다. 123456789101112131415161718with open('textfile_a.txt', 'r') as a: with open('textfile_b.txt', 'w') as b: a_file = a b_file = b.write('hello wolrd') with open('textfile_a.txt', 'r') as a, open('textfile_b.txt', 'w') as b: a_file = a b_file = b.write('hello world')# 파이썬 3.10.0 b1 버전부터는 아래처럼도 가능하다with ( open('textfile_a','w') as a, open('textfile_b','w') as b, open('textfile_c','w') as c): a.write('apple') b.write('banana') c.write('count') class로 context manager 구현하기 1234567class File(object): def __init__(self, file_name, method): self.file_obj = open(file_name, method) def __enter__(self): return self.file_obj def __exit__(self, type, value, trace_back): self.file_obj.close() 위와 같이 정의를 하고 아래처럼 실행해 보면 12with File('demo.txt', 'wb') as opened_file: opened_file.write('Hola!') with 문은 File class의 __exit__메소드를 저장 File class의 __enter__메소드를 호출 __enter__메소드는 파일을 열고 파일을 반환 열려진 파일은 변수명 opened_file에 저장 .write()을 통해 내용 작성 with문 이기 때문에 __exit__문을 호출 __exit__문을 통해 파일 닫음 위와같은 실행순서로 context manager를 구현 할 수 있다. References.https://tempdev.tistory.com/22https://ddanggle.gitbooks.io/interpy-kr/content/ch24-context-manager.html","link":"/2021/12/06/Python-context-manager/"},{"title":"pandas는 무엇인가?","text":"","link":"/2021/11/30/pandas/"},{"title":"git branch 기초 (추가,이동,삭제 등)","text":"heroku를 통해서 대시보드 배포를 하려고 애를 쓰던중에 끝도없는 에러와 마주쳐서 github Repo를 지웠다 만들었다 하기를 열번가량 반복하다가 현타가 왔다.강사님이 주신 URL 대로하면 가장 기본적인 배포는 가능하니 처음것을 백업해놓고 이것저것 고쳐가며 써보자 하는 생각이 들자 git이 애초에 그런(버전 관리) 프로그램이었다는 게 생각나 찾아보고 포스팅하게 되었다. 그래서 branch가 뭔데? branch는 git에서 독립적으로 어떠한 작업을 진행하기 위한 개념이다.각각 나누어진 branch는 서로 영향을 주거나 받지 않기 때문에 여러작업을 동시에 진행해볼 수 있다.또, 이렇게 나누어진 branch는 다른 branch와 병합하거나 덮어씀으로써 작업한 내용을 새로운 하나의 브랜치로 모을 수 있다. 위의 그림처럼 branch에서 서비스추가, 버그수정 등을 하고 main branch에 병합시키는 것이다.branch 에서 작업을 하다가 문제가 되어도 폐기하고 main branch에서 새로 branch를 만들면 되니 원본 손실의 위험도 없다. 그럼, 어떻게 쓰는건데? branch의 명령어는 꽤나 다양하지만 이 포스팅에서는 추가,이동,삭제등의 기본적인 것만들 다루겠다.(추후 포스팅 예정) branch 확인branch를 추가, 이동, 삭제하기 전에 Repo에 어떤 branch가 있는지 확인해야한다.(동명의 branch는 만들어지지 않는다.)확인을 하기 위해서는 Repo의 디렉토리에서 터미널이나 git bash로 다음 코드를 작성한다. 1git branch branch에 대해 처음 알았고 아무 조작도 가하지 않았다면 아마도 master(또는 main) branch만 있을 것이다.그리고 현재 적용(?)된 branch 가 색이 다르며 앞에 별표(*)가 있다. branch 추가이제 새롭게 branch 를 만들어보자 만약 자신이 원하는 branch 의 이름이 bugfix 라면 터미널에 다음처럼 작성하면 된다. 12# git branch &quot;branchName&quot;git branch bugfix 별다른 반응 없이 추가가 됐을 것이다.확인을 위해 다시 git branch 를 해보면.. 이렇게 새로 branch가 만들어 졌을것이다. branch 이동branch를 새로이 만들었으니 이젠 새로 만든 branch에서 작업을 하기위해 이동을 해야한다.이동하는 명령어는 다음과 같다. 12# git checkout &quot;branchName&quot;git checkout bugfix branch를 이동했으며 bugfix 가 활성화 된 것이 보인다. branch 삭제필요없는 branch를 어떻게 삭제 할까? 12# git branch -d &quot;branchName&quot;git branch -d bugfix 현재 활성화된 branch를 삭제하려는 경우에는 삭제되지않으니 checkout으로 다른 branch로 이동한 다음 삭제를 시켜줘야 한다. 이렇게 branch 의 기본적인 명령어들을 알아보았는데 클론을 만들고 클론이 잘못될 경우 다시 되돌릴수 있다는 것 자체가 매우 필요한 기능이라 자주 사용하게 될듯 하다.","link":"/2021/12/10/git-branch-1/"},{"title":"콜백(Callback)함수의 사용법","text":"Plotly 를 사용하여 대시보드를 만드는 동안에 직면했던 여러 문제들중 해결에 꽤 오랜시간이 걸린 문제가 있었다.바로 콜백함수에 대한 부분인데 처음보게된 콜백함수가 데코레이터가 적용된 그런 함수였기 때문에 굉장히 헷갈렸다. 콜백함수 콜백함수란 다른함수의 인자로써 이용되는함수, 어떤 이벤트에 의해 호출되어지는 함수를 말한다.함수가 다른함수의 인자로 사용될 수 있다니, 잘 이해가 되지 않을 수 있다. 내가 접했던 콜백함수를 가져와 보면 이렇다. 123456789101112131415161718@app.callback( Output('id_fig_age', 'Figure'), Input('country-filter', 'value'))def age_chart_func(value): obj = px.bar(data, x=data[data['Q3'] == value]['Q1'][1:].value_counts().sort_index().index, y=data[data['Q3'] == value]['Q1'][1:].value_counts().sort_index().values, ) obj.update_traces(hovertemplate='%{x}: %{y:.0f}', marker_color='#E08E79', marker_line_width=0,) obj.update_layout(paper_bgcolor=colors['content-background'], font_color=colors['text'], plot_bgcolor=colors['plot_background'], autosize=True) obj.update_xaxes(title_text='Age Distribution') obj.update_yaxes(title_text='Counts') return obj 전체코드의 일부분이지만 함수를 설명하는데에는 문제가 없다. 먼저 가장 위에 있는 @app.callback가 무슨뜻인지 이해하지 못한다면 데코레이터 에 대해 간략히 보고 오면 좋다.그리고 Output과 Input은 dash.dependencies 라이브러리에서 import 한 것인데, 기능을 살펴보기위해 코드대로 해석하자면 Input의 괄호안의 첫번째 인자(country-filter)와 ID가 같은 항목을 찾아 두번째 인자(country-filter 의 파라미터 value)를 아래에 있는 함수의 인자로 넣어주며, 인자를 통해 함수를 실행 후 나온 리턴을,Output의 괄호안의 첫번째 인자(id_fig_age)와 ID가 같은 항목의 두번째 인자(Figure)로 입력되는 것이다. 위 코드에서 복잡해 보일 수 있는 부분인 px.bar ~ obj.update_yaxes 까지는 그냥 그래프를 그려주는 함수라고 생각하면된다. 이때 이 함수를 모두 실행하고 리턴하는 값인 obj 가 반환되어 Output인 ‘id_fig_age’의 ‘Figure’속성으로 입력되고 ‘id_fig_age’는 함수에서 작성된 그래프를 ‘Figure’로 갖게되어 화면에 표현해준다.","link":"/2021/12/30/callback-func/"},{"title":"파이썬(Python) 데이터 크롤링 기초 수업 정리","text":"개발자나 데이터분석가에게 중요한 능력중 하나를 꼽자면 무엇일까.자신이 진행할 프로젝트의 데이터를 수집하는 능력도 꽤나 중요하지 않을까 싶다.그러기 위해서는 크롤링을 해야 할 때가 있는데 크롤링이란 HTML(웹페이지)를 그대로 가져와 데이터를 추출하는 행위를 말한다.그래서 이번 포스트에서는 학원에서 배운 간단한 크롤링에대해 수업 그대로를 정리하려 한다. 사전준비 크롤링을 하기위해 일단 BeautifulSoup 라는 파이썬 라이브러리를 설치해 주어야 한다.다음 코드를 터미널에 입력해 라이브러리를 설치한다. 1pip install beautifulsoup4 설치가 완료되었다면 예제 HTML 문서를 하나 만들어주면 준비는 끝난다. index.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crawl This Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cheshire&quot;&gt; &lt;p&gt;Don't crawl this.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;elice&quot;&gt; &lt;p&gt;Hello, Python Crawling!&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;I am in main&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BeautifulSoup를 사용하여 크롤링먼저 크롤링을 하기 위해 파이썬 파일을 만들어준다. 1from bs4 import Beautifulsoup 이후 Beautifulsoup 라이브러리를 import하고 간단한 함수를 만들어 크롤링을 해보자. HTML 불러오기123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) # open의 괄호안에 크롤링할 HTML파일의 위치를 입력 print(soup)if __name__ == &quot;__main__&quot;: crawling() 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;Crawl This Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;cheshire&quot;&gt;&lt;p&gt;Don't crawl this.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;elice&quot;&gt;&lt;p&gt;Hello, Python Crawling!&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; HTML 파일이 soup에 저장되어 출력된 것을 볼 수 있다. 필요한 태그만 가져오기하지만 우리는 HTML 전체가 아닌 특정 텍스트, 태그만 필요로 하기 때문에 그것들을 뽑아낼 수 있어야 한다. 123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) print(soup.find(&quot;p&quot;))if __name__ == &quot;__main__&quot;: crawling() 1&lt;p&gt;Don't crawl this.&lt;/p&gt; find()함수는 가장 앞쪽의 한 태그만을 가져온다.이처럼 p태그가 출력되었는데 두가지 의문이 생길 것이다.‘p태그는 두개인데 왜 한개만 출력되는가?’와 ‘&lt;p&gt;&lt;/p&gt;없이 텍스트만 추출 할수 없는가?’라는 것이다.물론 가능하다.첫번째는 find()함수를 find_all()로 바꾸면 모든 p태그가 출력되고,두번째는 find()함수 뒤에 .get_text()를 붙여주면 태그가 제외된 텍스트만 출력이 된다.이외에도 많은 함수가 있고, Beautiful Soup Documentation 에서 찾아볼 수 있다. class, id로 태그 가져오기여전히 크롤링이라기엔(기초지만) 부족하다 원하는 태그를 가져올 수는 있으나 태그가 여러개면 같이 가져올 수밖에 없기 때문이다.그래서 이번에는 각 태그에 주어진 class와 id를 통해 크롤링하는 법에 대해 알아보자. index.html을 보면 div태그에 각각 class와 id가 있다.이를통해 크롤링 하는 코드를 보면 123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) print(soup.find(&quot;div&quot;, class_ = &quot;elice&quot;).find(&quot;p&quot;).get_test())if __name__ == &quot;__main__&quot;: crawling() 다음과 같으며 이를 실행하면 1Hello, Python Crawling! 위와 같이 출력된다.만약 class가 아닌 id를 지정해서 태그를 찾고싶을 경우 find()함수 내에 class_ = 가 아닌 id = 를 입력하면 된다.class는 언더바가 붙고 id는 붙지 않는다. OPEN API를 통해 데이터 가져오기open API를 통해 데이터를 가져오는 법도 간단히 알아보자.이 포스팅은 캐글을 기반으로 진행했으며 데이터는 한국도로공사 공공데이터 포털 의 교통데이터를 이용했다. 먼저 API에 접근하기 위해 인증키를 발급 받는다. 이후 실시간 영업소간 통행시간 페이지 에 접속해 아래의 예제 실행하기를 클릭. 원하는 Request Parameter를 입력하고(필자는 key(여기서 키는 방금 발급받은 인증키), type, iStartUnitCode, iEndUnitCode만 작성) URL보기를 하면 URL이 출력되고 , 아래의 예제 실행하기를 통해 직접 볼 수도 있다. 이제, 캐글에 다음과 같이 입력해준다. 12345678import requestskey = &quot;발급받은 인증키&quot;type = &quot;json&quot;url = &quot;출력된 URL&quot;responses = requests.get(url)print(responses)json = responses.json()json 을 입력해주면팝업에서 보았던 예제를 직접 볼 수 있다. 필요한 정보가 있는 “realUnitTrtmVO” 항목을 가져오기 위해 다음 코드 입력 1cars = json[&quot;realUnitTrtmVO&quot;] 이것을 반복문을 통해 리스트, 딕셔너리 형태로 만들어준다. 12345678910data = []for car in cars: dic_df = {} dic_df[&quot;date&quot;] = car[&quot;stdDate&quot;] dic_df[&quot;time&quot;] = car[&quot;stdTime&quot;] dic_df[&quot;destination&quot;] = car[&quot;endUnitNm&quot;] data.append(dic_df)data 아래는 아웃풋 12345678910[{'date': '20220103', 'destination': '수원신갈', 'time': '05:30'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:35'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:40'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:45'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:50'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:55'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06 '}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:00'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:05'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:10'}] 이렇게 딕셔너리로 구성된 리스트가 생성되었다.이것을 Pandas Dataframe으로 변환후 엑셀시트로 출력하려면 다음과 같이 하면 된다. 123import pandas as pddf = pd.DataFrame(data) # 판다스 데이터프레임으로 변환df.to_csv(&quot;temp.csv&quot;,index=False,encoding=&quot;euc-kr&quot;) 이렇게하면 설정된 곳으로 캐글에서 데이터프레임이 다운로드된다.","link":"/2022/01/03/crawling-basic-01/"},{"title":"Heroku로 HTML 페이지 배포하기","text":"캐글 대시보드 배포 프로젝트를 마치고 꽤나 지났을때, 학원에 다니기 한참 전에 HTML과 CSS 로만 만들었던 카카오톡 클론코딩 프로젝트가 생각나 그것도 배포하는 김에 쓰는 글. 사전준비 Heroku 계정 Heroku CLI Git 일단 Heroku에서 배포를 할 것이므로 Heroku 의 계정과 Heroku CLI 설치가 필요하다.Git 도 자신의 환경에 맞추어 설치해주자. 윈도우에서 Git 설치하기 node.js가 설치되어 있는 경우에는 npm 으로 간편히 설치가 가능하다고 한다. 1npm i -g heroku 설치가 잘 됐나 확인해보자 1heroku -v 버전이 출력되면 잘 설치가 된 것이다. 1heroku login 설치가 잘 완료되었으면 heroku login을 입력하자.그러면 브라우저 창이 하나 뜨고, heroku계정을 입력하면 준비 완료. HTML 파일을 Heroku로 배포하기 프로젝트를 로컬에서 완성했다고 바로 heroku로 배포하면 heroku가 어떤 언어로 개발한 프로젝트인지 모르기 때문에 다음과 같은 오류를 내며 구동되지 않는다.코린이 입장에서 프로젝트 만들었다고 싱글벙글하다가 에러나면 진짜 아찔하다.그래서 이런일이 없게 heroku에서 지원하는 언어들중 하나인 php 프로젝트로 인식되게 처리해 주어야 한다.프로젝트의 루트 디렉토리에 다음처럼 html 파일로 리다이렉트 시켜주는 php 파일만 하나 만들어주면 된다. index.php123&lt;? header('Location: /index.html');?&gt; 이제 파일은 모두 완료됐으니 CLI를 이용해서 heroku에 배포를 해보자.당연히 아래의 명령을 입력하는 위치는 프로젝트의 루트 디렉토리여야 한다. 12345678910# 저장소를 만들고 커밋 (github연결과는 무관)git initgit add .git commit -m &quot;first commit&quot;# 새로운 Heroku app 생성heroku create# Heroku에 push하기git push heroku master 이렇게 하면 배포는 마무리 됐다. 이외에도 같이 필요할것같은 몇가지 명령어를 적어보자면 파일 수정 후 재배포시1234git add .git commit -m &quot;커밋 메모&quot;git push heroku master Heroku app 이름 바꾸기heroku create로 app을 만들면 이름이 임의로 생성된다 그렇기때문에 이름을 바꾸고 싶다면 아래의 명령어를 사용하면 된다. 1heroku apps:rename &lt;새 이름&gt; --app &lt;기존 이름&gt; heroku app 열기heroku app 페이지에서 open app 버튼을 통해 여는 방법도 있으나 CLI를 통해 바로 열어보고 싶다면 다음 명령어를 사용하자. 1heroku open heroku git 과 git 저장소 연결 명령어본 포스팅에서는 폴더에서 app을 만들었기때문에 바로 연결되어 사용할 필요가 없었던 명령어이다.그러나 저장소의 주소가 필요하거나 변경할 경우를 위해 기록한다. 12git remote -v # 폴더와 연결된 저장소(heroku git, github 등)의 주소가 출력됨git remote set-url heroku &lt;변경할 git 경로&gt; # heroku저장소의 주소를 변경할 경우 사용, 변경할 git 경로의 예)https://git.heroku.com/&lt;app이름&gt;.git 오류발생시 로그 출력배포를 진행하다 보면 오류가 발생할 수 있다.그럴 경우 로그를 출력하여 에러코드를 확인하고 영어로 구글링하여 답을 찾도록 하자. 12heroku logsheroku logs --tail Reference. heroku에 일반 html 사이트 올리기 [Hosting] heroku.com 사용하기","link":"/2022/01/07/heroku-deploy-html/"},{"title":"자바스크립트(Javascript) 쌩기초","text":"전에 만들어 놓았던 카카오톡 클론코딩을 배포 하던 중 HTML과 CSS만으로는 부족해보이므로 Javascript로 기능을 추가해 보라는 강사님의 피드백에 따라 JS로 기능을 추가하기 위해 JS가 주인 클론코딩 강의를 듣고 카카오톡 클론코딩에 잘 버무려 보기로 했다. 그런데 HTML의 스크립트태그는 몇번 접해본적 있었지만 JS는 초면인지라 다른 언어들의 기초보다 문법이 복잡한지, 어떤 부분이 다른지 전혀 모르고 있었기에 기록 겸 가끔 보려는 용도로 포스팅 한다. 하루 배우고 하루 기록하는 토막글 형식이기에 한두번 만에 끝날것 같지는 않으니, 귀찮아 하지말고 매일 기록할것. 변수 선언 방식 자바에 여러개의 변수 타입이 있듯이 자바스크립트에도 변수 타입이 존재한다. 그러나 다른점이라면 자바는 변수의 크기, 타입에 따라 분류한다면 자바스크립트는 이후에 값을 수정 가능한지 아닌지로 분류한다.일단 기본적인 변수 선언 방식은 다음과 같다. 123const a = 1;let b = 2;var c = 3; 기본적으로 변수 선언 방식 이후 변수에 값을 넣고 닫아주는 형태이다. 갑자기 잡설을 풀어보자면파이썬, 자바등을 공부할때 해당하는 언어를 설치해주어야 했는데 자바스크립트는 그렇지 않다.다른 언어의 경우에는 버전이 올라감에 따라 이전버전의 문법을 사용하지 못하는 경우가 있다.그러나 자바스크립트는 이전버전의 문법(const,let이 있음에도 var가 사용 가능한경우)이 여전히 혼용 가능하다.(그러나 쓰지않는걸 추천하는것 같다.) 각설하고, 총 세 개의 방식이 있는데 각각의 특징은 이렇다. constES6 이후에 추가되었고 가장 기본적으로 사용되는 변수형이다, 상수(변수인데 상수;;)이며 그렇기 때문에 선언 이후에 변경이 불가하다.(할당된개체가 Array와 Objects등의 개체라면 내부의 값을 변경할 수는 있다. ) 선언할때 반드시 값을 할당해주어야 한다. letES6 이후에 추가되었고 현재 사용되고 있는 가변 변수형이다, 선언 이후에도 변경이 가능하다. 선언할때 값을 할당하지 않을수 있지만 그럴경우 값은 undefined가 된다. var자바스크립트 초기에 사용되었던 변수형이며, 선언 이후에도 변경이 가능하다. 역시나 선언할때 값을 할당하지 않을수 있고, 이 경우 값은 undefined가 된다. 왜 let은 쓰는데 var는 쓰지 않는지, 왜 기본적으로 let이 아닌 const를 쓰는지 의문이 생길수 있다.전자의 의문의 답은 세가지이다. 첫째는 변수명이 같아도 선언이 가능하다는것. (재선언 가능)누군가는 장점이 아니냐 할 수 있겠지만 변수의 양이 매우 많거나, 다른사람과 협업을 한다면 이는 단점이 된다. 둘째는 호이스팅(Hoisting).이는 변수의 정의가 선언과 할당으로 분리되는것을 말한다, 이게 무슨뜻인지는 다음 코드를 보자 12console.log(name);var name = &quot;WJ&quot;; 이렇게 코드가 있을때 자바스크립트는 다음과 같이 해석한다. 123var name;console.log(name);name = &quot;WJ&quot;; 결국 출력은 초기화가 되지않았다는 메시지가 나오는 대신 정의되지 않았다는 뜻인 undefined 가 나오게 된다.이는 직관적이지 못하기때문에 var보다 let을 쓰는것이 권장된다. 셋째는 const,let은 ‘블럭’수준 var는 ‘함수’수준으로 적용되기 때문이다.이게 무슨말인지 처음엔 이해가 잘 되지 않을수 있다. (나는 그랬음..)그러니 바로 예시를 보면 123456789var a = 5; # 전역변수 a 선언후 5 할당console.log(a); # 5 출력function setA() { var a = 10; # '함수 내부'에서 지역변수 a 선언후 10 할당 console.log(a); # 10 출력}console.log(a); # 5 출력 전혀 이상할것 없이 당연한 예시이다. 그럼 다음예시도 한번 보자 123456789var a = 5; # 전역변수 a 선언후 5 할당console.log(a); # 5 출력if (true) { var a = 10; # 'if블럭 내부'에서 지역변수 a 선언후 10 할당 console.log(a); # 10 출력}console.log(a); # 10 출력 &lt;-- ??? if블럭 내부에서 지역변수를 할당 했음에도 전역변수로 선언했던 a의 값이 바뀌어 10이 되었다. 이는 위에서 말했듯 var의 범위는 ‘함수’수준으로 적용되기 때문이다.즉, 블럭{}으로 감싸더라도 함수로 감싸진것이 아니기때문에 if블럭 내에서 재할당된 값이 출력된 것이다. 쓰면 안되는 이유 1,3번의 콜라보.. 결국 요약하자면 var는 함수내부에서 쓰는것이 아니라면 전역변수와 같다는 것이다. 안쓰는데는 이유가있다 Array (배열, 리스트)파이썬으로 처음 접했던 리스트 역시 자바스크립트에도 있다.다음은 array를 선언하는 기본적인 방법이다. 1const a = [1, 2, null, true, &quot;hello&quot;]; 인덱싱은 a[2]; 처럼 가능하고, 값을 추가하고 싶을 경우 a.push(추가할 값) 해주면 해당 값이 가장 마지막의 인덱스에 추가된다. Objects (파이썬 딕셔너리)제목에도 적었듯이 키와 값으로 이루어진 것이 파이썬의 딕셔너리와 닮았다. 세세한기능까지 같은지는 모른다오브젝트를 선언하는 기본적인 방법을 보면 123456const a = { name : &quot;WJ&quot;, contry : &quot;KR&quot;, lang : &quot;Javascript&quot;, num : 123} 처럼 선언하는데 중괄호 내부의 프로퍼티 중 왼쪽을 이름, 오른쪽을 값이라 한다. 값 출력시엔 다음처럼 하면 된다. 12a.name;a[&quot;name&quot;]; 예시에서 배열과 오브젝트 둘다 const로 선언했지만 내부의 값은 바꿀 수 있다. function (함수)123function a() { console.log(&quot;Hello!&quot;);} 문법만 조금 다를 뿐 전체적으로 파이썬의 사용자 지정 함수나 자바의 메소드와 비슷하다. 함수호출은 a() 로 할수 있으며 결과는 Hello! 가 출력되게 된다. Reference.ES6의 변수 선언, const와 let - nana_log","link":"/2022/01/10/javascript-basic-1/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"pandas","slug":"pandas","link":"/tags/pandas/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Install","slug":"Install","link":"/tags/Install/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/tags/Data-Visualization/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"Kaggle","slug":"Kaggle","link":"/tags/Kaggle/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Grammar","slug":"Grammar","link":"/tags/Grammar/"},{"name":"Plotly","slug":"Plotly","link":"/tags/Plotly/"},{"name":"Repository","slug":"Repository","link":"/tags/Repository/"},{"name":"Link","slug":"Link","link":"/tags/Link/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Decorator","slug":"Decorator","link":"/tags/Decorator/"},{"name":"Context manager","slug":"Context-manager","link":"/tags/Context-manager/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"version","slug":"version","link":"/tags/version/"},{"name":"Callback","slug":"Callback","link":"/tags/Callback/"},{"name":"checkout","slug":"checkout","link":"/tags/checkout/"},{"name":"Crawling","slug":"Crawling","link":"/tags/Crawling/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","link":"/tags/BeautifulSoup/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"stub","slug":"stub","link":"/tags/stub/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"pandas","slug":"pandas","link":"/categories/pandas/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/categories/Data-Visualization/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"deploy","slug":"deploy","link":"/categories/deploy/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"}]}