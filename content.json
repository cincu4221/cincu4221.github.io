{"pages":[],"posts":[{"title":"Hexo로 깃허브 블로그 만들기","text":"Hexo란?Hexo는 Node.js기반의 정적 블로그 프레임워크 입니다. Markdown으로 문서를 작성하고 빌드시 정적 HTML이 생기고이것을 GitHub pages에 배포 하여 블로그를 관리 합니다. 설치환경 Git Node.js 파이참(PyCharm) GitHub 계정 설치환경 확인 아래 코드로 Node.js 설치를 확인해봅니다.1$ node -v 아래 코드로 Git 설치를 확인합니다.1$ git --version npm을 통해 hexo를 전역으로 설치합니다.1$ npm install -g hexo-cli GitHub 블로그 만들기먼저 원하는 디렉토리로 이동하여 헥소 블로그 디렉토리를 만들어줍니다.(이 포스팅에서는 myblog)1$ hexo init myblog 생성된 디렉토리를 우클릭 한 뒤‘Open Folder as PyCharm Community Edition Project‘를 클릭해 파이참으로 열어줍니다. 실행된 파이참의 좌측 아래에서 터미널 메뉴를 선택하고 사진과같이 Git Bash를 클릭해주면파이참에서 Git을 사용할 수 있게 됩니다. 이후 Git에서 다음 명령어들을 입력해줍니다 123$ npm install$ npm install hexo-server --save$ npm install hexo-deployer-git --save 이제 GitHub 접속하고 우측 상단의 아이콘 클릭 후 ‘Your repositories‘에 들어갑니다.Repository name 란에 만들었던 디렉토리와 같은 이름인 ‘myblog’를 넣은 후 아무것도 건드리지 않고 아래의 ‘Create repository’ 버튼을 눌러줍니다. 다시 파이참으로 돌아와서 아래의 Git 명령어들을 입력해줍니다. 1234567echo &quot;# myblog&quot; &gt;&gt; README.mdgit initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin https://github.com/cincu4221/myblog.gitgit push -u origin main GitHub에서 ‘myblog‘ 리포지토리를 만들때와 이름만 다르게 ‘사용자계정명.github.it‘ 으로 바꾸어서 리포지토리를 하나 더 생성해 줍니다. 파이참의 작업영역에서 _config.yml 파일을 열어서 수정해줍니다. 블로그 정보 설정1234title: blog titlesubtitle: 부제목을 지어주세요description: description을 지어주세요author: YourName 블로그의 URL정보 설정1234url: https://Username.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 깃허브 연동 설정12345# Deploymentdeploy: type: git repo: https://github.com/Username/Username.github.io.git branch: main 위의 코드에서 Username으로 되어있는것은 꼭 사용자의 GitHub계정명으로 바꿔주셔야 합니다. 파이참의 Git Bash(Terminal)에 다음 코드들을 입력합니다. 12$ hexo generate$ hexo server 이후 나오는 localhost:4000에서 화면이 뜨는지 확인합니다. 다음 코드를 입력해 최종적으로 배포를 진행합니다. 1$ hexo deploy 배포가 완료되면 브라우저에서 [USERNAME.github.io]로 접속해 정상적으로 배포되었는지 확인합니다. * 참고 : https://dschloe.github.io/settings/hexo_blog/","link":"/2021/10/28/make_github_blog/"},{"title":"윈도우에서 Git 설치하기","text":"다운로드 먼저 Git홈페이지에서 Download for Windows을 클릭해 자신의 윈도우 버전에 맞는 Git을 다운로드 해준다. Git 홈페이지 윈도우 버전에 맞는 Git이 알아서 다운로드된다. 설치 설치파일을 실행시키면 항상 보는 약관페이지가 나온다. Next를 눌러 넘어간다. 설치경로를 정해주고 Next 설치할 Component 들을 선택하는 창이다. 기본으로 선택되어 있는것만 선택하고 Next를 눌러 넘어간다. 시작메뉴에 폴더를 생성하는 창이다. 폴더를 추가하고 싶지 않다면 아래에 있는 Don't create a Start Menu folder 체크박스를 클릭하고 Next를 눌러준다. Git의 기본 에디터를 설정하는 창이다. 이번에도 기본으로 선택되어있는 항목을 고르고 Next를 눌러 넘어간다. 선택되어있는 Let Git decide를 고르고 Next를 누른다. 환경변수 옵션 설정이다. Git from the Command line and also from 3rd-party software를 선택하고 Next Use bundled OpenSSH를 선택한채로 Next를 누른다. https 전송시 인증서 선택. Use the OpenSSL library을 선택 후 Next Checkout Windows style, commit Unix-style line endings을 선택하고 Next Git Bash 터미널의 형식. Use MinTTY를 선택하고 넘어갑니다. Git pull 작업방식. Default로 설정해주고 Next를 누른다. Credential Helper 사용에 대한 선택. Git Credential Manager Core선택 후 Next 기타 실행옵션. 필자는 Enable file system caching만 체크 후 넘어갔다. 모든 옵션에 체크를 완료하고 설치가 진행되는 모습. 설치가 완료되면 위와 같은 창이 뜬다. 설치 확인 자 이제 설치가 잘 되었는지 확인할 차례이다.윈도우에 cmd를 검색해 명령 프롬프트를 실행한다.아무것도 하지않은채로 git 을 입력한다. 입력하면 위 사진처럼 Git의 명령어가 나오면서 설치가 완료된걸 확인 할 수 있다.","link":"/2021/10/29/setting_Git/"},{"title":"파이썬(Python) 기본 문법 - 1","text":"이 포스트는 필자의 정확한 파이썬 문법을 익히고 필요할때 찾아보기 위해 서술한 것이다. Hello World 어떤 프로그래밍언어든 배우기 시작하면 출력하고 보는 Hello world, 파이썬에서는 다음과 같이 출력한다. 1print(&quot;Hello, world!&quot;) Output: Hello, world! 당연하게도 Hello, world 이외의 다른 문장이 들어가면 그대로 출력되며print() 에서 괄호 내부에 출력을 해주고싶은 변수나 문장을 입력하면 된다, 문장의 경우는 따옴표로 묶어줘야 출력이 된다. 주석처리 접기 / 펼치기 프로그래밍 언어마다 주석처리를 해주는 방법이 다르다, 파이썬의 경우에는 다음과 같이 주석처리한다. 1234567# 한줄을 주석처리하는 방법입니다.&quot;&quot;&quot;여러줄을한번에 주석처리하는방법입니다.&quot;&quot;&quot;print(&quot;Hello, world!&quot;) Output: Hello, world! 위처럼 작성하고 실행시키면 나머지 줄은 모두 주석처리되고 가장 아랫줄인 Hello, world만 출력이 되는걸 볼 수 있다. 변수의 종류 접기 / 펼치기 변수(Variable)는 (문자나 숫자 같은) 값을 담는 컨테이너로 값을 유지할 필요가 있을 때 사용한다. 여기에 담겨진 값은 다른 값으로 바꿀 수 있다. 변수는 마치 (사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다. 출처 : 생활코딩 - 변수 다른 프로그래밍언어와 같이 파이썬 역시 다양한 변수의 종류(타입)가 있는데 이번 단락에서는 그것에 대해 알아보겠다. int타입 (정수형)12num_int = 1print(type(num_int)) 변수에 값을 정수로 주고 그 변수의 타입을 알아본 예제, 출력을 하게되면 &lt;class 'int'&gt;가 줄력된다. float타입 (실수형)12num_float = 0.2print(type(num_float)) 변수에 값을 실수로 주고 그 변수의 타입을 출력한 예제, 출력을 하게되면 &lt;class 'float'&gt;가 출력된다. bool타입 (논리형)12bool_true = Trueprint(type(bool_true)) 변수에 값을 논리타입(True or False)으로 주고 그 변수의 타입을 출력한 예제, 출력하면 &lt;class 'bool&gt;이 출력된다. None타입12none_x = Noneprint(type(none_x)) Null을 나타내는 자료형이다, None라는 한가지 값만 가질 수 있다. (왜 필요한지는 아직 모르겠다) 사칙연산 접기 / 펼치기 파이썬에서의 사칙연산은 일반적인 사칙연산과 같다.그리고 나눈후 정수의값만 구하는 //, 나머지를 구하는 %, 거듭제곱을 뜻하는 ** 등의 연산자가 있다. 123456789a = 3b = 2print('a + b = ', a+b)print('a - b = ', a-b)print('a * b = ', a*b)print('a / b = ', a/b)print('a // b = ', a//b)print('a % b = ', a%b)print('a ** b = ', a**b) Output: a + b = 5 a - b = 1 a * b = 6 a / b = 1.5 a // b = 1 a % b = 1 a ** b = 9 위처럼 각각 계산이 된걸 알 수 있다. 정리하면 아래와 같다 연산자 내용 + 두 변수의 합을 계산 - 두 변수의 차를 계산 * 두 변수의 곱을 계산 / 두 변수로 나눈 결과를 float 형으로 반환 // 두 변수로 나눈 결과에서 정수 부분만 취함 % 두 변수로 나눈 결과에서 나머지 값만 가져옴 ** i**j일 경우, i의 j만큼 제곱하여 계산 (예: 2 ** 4 = 24 = 16) 논리형 연산자 접기 / 펼치기 논리형 연산자에는 and 와 or이 있다.and연산자는 두 조건이 모두 참일때 True가 되며 or의 경우 두 조건중 하나라도 참일때 True가 된다. and연산자1234print(True and True)print(True and False)print(False and True)print(False and False) Output: True False False False 위 결과처럼 두 조건 모두 참일때만 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False False False True False False False False or 연산자1234print(True or True)print(True or False)print(False or True)print(False or False) Output: True True True False 위 결과처럼 두 조건 중 하나만 참이라도 True를 반환한다.표로 나타내면 다음과 같다. 변수1 변수2 AND 연산결과 True True True True False True False True True False False False 비교 연산자 접기 / 펼치기 비교 연산자에는 &gt;,&lt;,&gt;=,&lt;=이 있다.일단, 예제를 보자. 1234print(4 &gt; 3)print(4 &lt; 3)print(4 &gt;= 3)print(4 &lt;= 3) Output: True False True False 예제처럼 결과는 논리타입으로 출력된다. 문자열 연산 접기 / 펼치기 정수나 실수 논리타입뿐만 아니라 문자열도 연산이 가능하다.다만 문자열을 뒤에 덧붙이는+연산자, 문자열을 횟수만큼 반복해주는*연산자만 사용이 가능하다. 123str1 = &quot;Python &quot;str2 = &quot;Editor &quot;print('str1 + str2 = ', str1 + str2) Output: Python Editor +연산자의 경우 위처럼 문자열 두 개가 나란히 이어붙혀져 출력이 되며, 12greet = str1 + str2print('greet * 3 = ', greet * 3) Output: Python Editor Python Editor Python Editor *연산자의 경우 변수에 담긴 문자열이 정해준 횟수만큼 반복되어 나열된다. 문자열 인덱싱 접기 / 펼치기 문자열이 있는경우 숫자을 통해 문자열에서 특정 문자만을 출력할 수 있는데 이를 Indexing 이라고 한다.Hello world이라는 문자열이 있다고 하자 그럼 문자열의 각 인덱스는 다음과 같다. 문자열 H e l l o w o r l d 인덱스 0 1 2 3 4 5 6 7 8 9 10 이처럼 각 글자마다 인덱스가 배정되며 공백에도 인덱스가 배정된다.인덱스를 사용하면 다음과 같은 것도 가능하다. 1234text_ex = &quot;Hello world&quot;print(text_ex[2])print(text_ex[6:10])print(text_ex[2:11:2]) Output: l worl lowrd 위 예제는 문자열을 담은 변수에 인덱싱을 한 것이다첫번째 줄은 인덱스’2’의 문자를 가져오는 것인데 인덱스는 0부터 시작하므로 (2번째가아닌)3번째인’l’을 출력한것이다.두번째 줄은 인덱스’6’부터 ‘9’까지(두번째인덱스-1)의 숫자를 가져오는 것이므로 ‘worl’이 출력되었다.세번째 줄은 인덱스’2’부터 ‘10’까지를 가져오되, 한칸씩 건너뛰고(세번째 숫자가 3이므로) 가져오는것이다. 리스트(list) 접기 / 펼치기 리스트는 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.리스트의 장점은 다음과 같다. 인덱스 번호로 빠른 접근이 가능하다. 데이터의 위치에 대해 직접적인 접근(Access)가 가능하다.1fruit = [['apple', 'banana', 'cherry'], 123] 위가 리스트의 형태이다.리스트의 값은 기본적으로 인덱스가 배정된다 이때는1print(fruit[0]) Output: [‘apple’, ‘banana’, ‘cherry’]위와 같은 형태로 나타낼 수 있으며 해당 인덱스의 요소가 리스트라면 리스트 전체를 출력한다. 만약 위처럼 리스트가 중첩된 형태라면 1print(fruit[0][1]) Output: banana 위처럼 출력이 가능하며 이때 리스트의 요소중 해당 인덱스의 요소가 출력된다.물론 이 때도 출력된 문자열에서 다음과 같이 문자열의 요소를 출력하는것도 가능하다. 1print(fruit[0][1][3]) Output: a 위와같이 결과가 출력된다. 리스트값 수정, 추가, 삭제하기 접기 / 펼치기 리스트가 여러 요소들의 집합이다보니 리스트의 값에 변동이 필요할 때가 있다.리스트는 값의 수정, 추가, 삭제가 가능하므로 기능과 문법에 대해 알아둘 필요가 있다. 리스트 값 수정하기123a = [0,1,2]a[1] = &quot;b&quot;print(a) Output: [0, 'b', 2] 별다른 문법없이 리스트의 인덱스에 값을 넣어주니 수정이 되는것을 알 수 있다. 리스트 값 추가하기 append1234567a = [100, 200, 300]a.append(400)print(a)b = [500,600]a.append(b)print(a) Output: [100, 200, 300, 400] [100, 200, 300, 400, [500, 600]]리스트명.append(값)을 통해서 리스트에 값을 추가할 수 있으며 한개의 값만 추가할 수 있다.리스트의 경우엔 한가지 값이며 추가할 경우 중첩된 리스트의 형태로 추가가 된다. extendextend는 append와 거의 같지만 다른점이 하나 있습니다.append는 인자(리스트, 튜플 등)를 주어도 인자 그대로를 리스트에 추가하지만,extend는 인자를 줄 경우 인자의 값 하나하나를 리스트에 추가한다. 1234a = [2, 9, 3]b = [1, 2, 3]a.extend(b)print(a) Output: [2, 9, 3, 1, 2, 3]결과와 같이 append와 비교했을때 extend된 인자의 값 하나하나가 추가된걸 볼 수 있다. insertinsert는 입력해준 위치의 인덱스에 값을 추가해준다. 1234a = [1,2,3]print(a)a.insert(1,'abc')print(a) Output: [1,2,3] [1,’abc’,2,3] 리스트 값 삭제하기 remove1234567a =[1,2,1,2]#리스트의 첫번째 1이 삭제a.remove(1)print(a)#리스트의 두번째 였던 1이 삭제a.remove(3)print(a) Output: [2, 1, 2] [2, 2]리스트명.remove()는 괄호내의 값을 삭제한다.만약 값이 리스트내에서 중복될경우 가장 앞에 있는 값을 삭제한다. del12345678910a = [0,1,2,3,4,5,6,7,8,9]# 1 삭제del a[1]print(a)b = [0,1,2,3,4,5,6,7,8,9]# 범위로 삭제del b[1:3] #list는 항상 시작하는 index부터, 종료하는 n의 n-1까지의 범위를 잡아준다.print(b) Output: [0, 2, 3, 4, 5, 6, 7, 8, 9] [0, 3, 4, 5, 6, 7, 8, 9]del 리스트명[인덱스]는 리스트의 인덱스에 위치한 값을 삭제해준다.인덱스값에 범위를 주고싶다면 0:4 처럼 넣을수 있으며 이때는 0에서 3번째 값까지 삭제가 된다. pop12345a = [0,1,2,3,4]r = a.pop(1)print(a)print(r) Output: [0, 2, 3, 4] 1리스트명.pop()은 괄호내의 값을 해당 리스트에서 끄집어낸다. 튜플(tuple) 접기 / 펼치기 튜플은 리스트와 비슷하게 여러개의 문자열, 변수, 숫자 등을 담을수 있는 자료구조이다.튜플과 리스트의 가장 차이점으로는 튜플은 값에대한 수정이 불가하다는 점이다.그렇다면 튜플은 무슨 장점이 있느냐 라고 반문할 수 있는데 리스트와 비교한 튜플의 장점은 다음과 같다. 메모리 사용량이 적다. 생성 시간이 빠르다. 인덱스를 사용하여 튜플의 데이터에 접근하는 시간이 비교적 짧다. 튜플의 문법, 기본형태는 다음과 같다. 1234567891011tuple1 = (0) # 끝에 콤마(,)를 붙이지 않았을 때tuple2 = (0,) # 끝에 콤마(,)를 붙여줬을 때tuple3 = 0,1,2print(tuple1)print(tuple2)print(tuple3)print(type(tuple1)) # 콤마(,)를 붙여주지 않으면 튜플이 아닙니다.print(type(tuple2)) # 콤마(,)를 붙여주어야 튜플 자료형 입니다.print(type(tuple3)) # 여러개의 값 일경우 괄호를 없애주어도 튜플 자료형 입니다. Output: 0 (0,) (0, 1, 2) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 튜플을 생성할때 튜플이 되기위해서는 콤마(,)가 필수적이다.콤마를 작성하지 않으면 타입을 출력했을때 튜플이 아닌 입력한 변수형태로 출력이 된다. 튜플역시 리스트와 같이 인덱싱및 슬라이싱이 가능하다. 튜플의 연산튜플도 연산이 가능한데, 더하거나 곱하는 +, * 연산자만 사용이 가능하다. 1234t1 = (0,1,2,3,4)t2 = ('a','b','c')t3 = t1+t2print(t3) Output: (0, 1, 2, 3, 4, 'a', 'b', 'c') 딕셔너리 접기 / 펼치기 딕셔너리는 키와 그에따른 값으로 구성되어있는 파이썬의 자료구조이다. 12345dic = {'teacher':'alice', 'class': 5, 'studentid': '15', 'list':[1,2,3]}print(dic['teacher'])print(dic['class'])print(dic['list']) Output: alice 5 [1, 2, 3] 키를 출력하면 그와 대응하는 값이 출력되는 자료구조이며 자료에 순서가 없는논시퀀스 자료형이다. 123a = {'name': 'bob', 'job': 'farmer', 'age': 35}a.keys()a.values() Output: dict_keys(['name', 'job', 'age']) dict_values(['bob', 'farmer', 35]) 이렇게 키만 출력할수도, 값만 출력할수도 있다. 집합 연산자 접기 / 펼치기 파이썬에도 집합연산이 있고, 자료구조들의 합,교,차집합에 대한 연산을 할수 있다.기호는 |,&amp;,-이며, 각각의 예시는 다음과 같다. 12345a = {1,2,3,4}b = {3,4,5,6}print(a|b) print(a&amp;b)print(a-b) Output: {1, 2, 3, 4, 5, 6} {3, 4} {1, 2} if 조건문 접기 / 펼치기 조건문이란 작성자가 명시한 조건식의 결과인 boolean값이 참인지 거짓인지에 따라 달라지는 계산이나 상황을 수행하는 문장이다. 12345678910a = -5if a&gt;5: print('a는 5이상입니다')elif a &gt; 0: print(&quot;a는 0초과, 5이하입니다&quot;)else: print(&quot;a는 음수입니다&quot;) Output: a는 음수입니다. 조건식에는 기본적으로 조건식이 들어가지만 True나 False등의 직접적인 bool형 변수가 삽입될수도 있으며, and,or 등과 결합하여 여러가지의 조건식을 사용할수도 있다. 반복문 (for,while) 접기 / 펼치기 같은동작을 여러번 반복해야 할 때 같은코드를 여러번 적어넣는건 비효율적이다.그럴때 반복문을 사용하면 훨씬 적은양의 코드로도 같은효과를 낼 수 있다. for문 for문의 기본 구조123for 변수 in 리스트(또는 튜플, 문자열) : 수행할 문장1 수행할 문장2 리스트나 튜플, 문자열의 첫 번째 요소부터 마지막 요소까지 차례로 변수에 대입되어 “수행할 문장1”, “수행할 문장2” 등이 수행된다.123a = ['1','2','3']for i in a : print(i) Output: 1 2 3 리스트 a의 첫번째 값인 1이 i에 대입되고 print(i)가 출력된다.다음엔 두번째 값인 2가 대입되고 출력된다.이것을 마지막 값까지 반복한다. while문 while문의 기본 구조12345while &lt;조건문&gt;: &lt;수행할 문장1&gt; &lt;수행할 문장2&gt; &lt;수행할 문장3&gt; ... while문은 for보다는 간단하다. while, 조건문, 실행문 이 세개면 완성되기 때문이다.이러한 특성때문에 while문은 조건문을 거짓으로 만들어주는 문장이 없다면 무한실행된다. 프로그램 뻗는다간단한 예제를 보면 다음과 같다.1234i = 0while i &lt;= 5 : print(&quot;{}번째 반복입니다.&quot;.format(i)) i += 1 Output: 0번째 반복입니다. 1번째 반복입니다. 2번째 반복입니다. 3번째 반복입니다. 4번째 반복입니다. 5번째 반복입니다.변수 i로 인해 자동으로 조건식이 False가 되면서 while문이 종료되는 모습이다.이렇듯 while문은 조건문을 거짓으로 만들어주는 무엇인가가 없다면 종료되지않는다.","link":"/2021/11/01/Python_Basic_Grammar_1/"},{"title":"pandas 기본 문법","text":"DataFrame 생성 방법 list이용12345import pandas as pdframe = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 1 2 3 1 4 5 6 2 7 8 9 Dictionary 이용1234567891011import pandas as pddata = { 'age' : [20,39,41], 'height' : [176, 182, 180], 'weight' : [73, 78, 69]}indexName = ['사람1', '사람2', '사람3']frame = pd.DataFrame(data, index = indexName)frame 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight 사람1 20 176 73 사람2 39 182 78 사람3 41 180 69 Sample Dataset 가져오기 위처럼 직접 DataFrame을 만드는 것이 아닌 제공하는 Dataset을 직접 가져오는 방법도 있다.Dataset을 가져오는 방법은 다음과 같다. Dataset Github에 접속하고 가져오고싶은 데이터셋을 고른다. 예를들어 flights.csv 를 가져오고 싶다면1234import seaborn as snsflights = sns.load_dataset(&quot;flights&quot;) #여기까지가 가져오기flights.head(5) # 다섯번째 행의 데이터까지만 출력flights[&quot;year&quot;] # 'year'열만 출력 위와 같이 제공되는 데이터셋을 가져올 수 있다. DataFrame 조회 방법 기본적인 조회 방법DataFrame의 기본적인 조회 방법은 다음과 같다. .head() 12# 위에서 가져온 데이터셋 flights를 사용flights.head() # 데이터프레임의 가장 첫부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 이 때 .head()의 괄호 안에 숫자가 있다면 그 수의 개수만큼 데이터가 출력된다. .tail() 1flights.tail() #데이터프레임의 가장 뒷부분부터 표시 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } year month passengers 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 .tail()역시 마찬가지로 괄호안에 숫자가 있다면 수의 개수만큼 데이터가 출력된다. .index 데이터프레임의 인덱스를 표시하는 방법도 있다. 1flights.index RangeIndex(start=0, stop=144, step=1) 열(Column) 조회 방법12345678910#열(Column) 조회print (&quot;* 열 조회 - 1&quot;)print (frame['age'])print (&quot;* 열 조회 - 2&quot;)print(frame.age)#특정 열의 특정 값을 조회하고 싶을때print(&quot;* 특정 열 의 특정 값 조회&quot;)print(frame['age'][1])print(frame.height[2]) 출력 * 열 조회 - 1 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 열 조회 - 2 사람1 20 사람2 39 사람3 41 Name: age, dtype: int64 * 특정 열 의 특정 값 조회 39 180 행(Row) 조회행 조회는 열 조회와 조금 다르게 loc와 iloc를 사용해서 조회 할 수 있다.여기서 loc는 사람이 읽을 수 있는 라벨 값으로 특정 값들을 골라오는 방법이고,iloc는 행이나 칼럼의 순서를 나타내는 정수로 특정 값을 추출하는 방법이다. 12345#행(Row) 조회 (loc)print(&quot;* loc 특정 행 조회&quot;)print(frame.loc['사람1'])# print(frame.loc[0]) - 조건이 정수이므로 조회 불가 출력 * 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 loc를 Seq로 조회할 경우 12345#행(Row) 조회 (iloc)print(&quot;* iloc 특정 행 조회&quot;)print(frame.iloc[0])# print(frame.iloc['사람1']) - 조건이 정수가 아니므로 조회 불가 출력 * iloc 특정 행 조회 age 20 height 176 weight 73 Name: 사람1, dtype: int64 DataFrame 수정 방법 열(Column) 추가하기gender 라는 컬럼을 추가합니다. 12frame_add_col = pd .DataFrame(frame,columns= ['age','height','weight','gender'])frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 NaN 사람2 39 182 78 NaN 사람3 41 180 69 NaN 컬럼이 추가되었고 어떠한 값도 넣어주지 않았으므로 NaN 값이 출력되고있다.이제 데이터를 입력해준다. 12frame_add_col['gender'] = ['male', 'male', 'female']frame_add_col 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 행(Row) 추가하기123frame_add_index = frame_add_col.copy()frame_add_index.loc['사람4'] = [31, 158, 48, 'female']frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람2 39 182 78 male 사람3 41 180 69 female 사람4 31 158 48 female 행, 열 삭제하기drop 메소드를 사용하면 행 또는 열을 삭제할 수 있다.axis 값은 행이면’0’, 열이면 ‘1’로 지정해주면 된다. 12print('remove age column')frame_add_col.drop(&quot;height&quot;, axis=1) 출력 remove age column .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age weight gender 사람1 20 73 male 사람2 39 78 male 사람3 41 69 female 그러나 이 경우 기존에 있던 frame_add_col에서 삭제되는게 아니라 삭제된 상태의 프레임을 리턴해준 것이다.그러므로 기존 프레임에 적용하기 위해서 inplace = True 옵션을 추가로 주어야 한다. 12frame_add_index.drop('사람2', axis=0, inplace = True)frame_add_index 출력 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } age height weight gender 사람1 20 176 73 male 사람3 41 180 69 female 사람4 31 158 48 female References https://hong-sam.tistory.com/100","link":"/2021/11/02/pandas_Basic_Grammar_1/"},{"title":"결정 나무(Decision Tree) 간단 설명","text":"결정 나무란? 결정 나무 Decision Tree 는 분류와 회귀 문제에 널리 사용하는 데이터마이닝 기법이다. 결정 나무는 결정을 하기위해 예/아니오 질문을 연속해가며 학습한다. 결정나무 간단설명영상결정나무 사이킷런 튜토리얼 결정나무의 의사결정 과정 결정 나무가 행하는 이 과정은 ‘스무고개’를 할때의 그것과 비슷하다.사과, 포도, 멜론, 녹차를 구분한다고 생각해보자. 사과와 포도는 과일이고 멜론과 녹차는 과일이 아니다.‘과일인가요?’라는 질문을 통해 사과, 포도 / 멜론, 녹차를 나눌 수 있고, 사과와 포도는 ‘(과실 전체의)모양이 둥근가요?’, 멜론과 녹차는 ‘넝쿨에서 자라나요?’ 라는 질문을 통해 분류해 낼 수 있다.위의 결정나무를 도식화하면 아래와 같다. 이렇게 질문에 따라 데이터를 구분짓는 모델을 결정나무모델이라고 한다. 한번의 질문에 True 혹은 False를 통해 변수영역을 두 개로 분기한다. 위의 그림에서 각각의 네모상자를 노드Node라고 하며, 가장 처음의 분기점을 Root Node라고 하고, 가장 마지막 노드를 Leaf Node또는 Terminal Node라고 한다. 결정나무분류기 = DecisionTreeClassifier DecisionTreeClassifier()는 결정나무의 기능을 바꿀수 있는 파라미터인데 파라미터 내부의 특성 하나하나를 하이퍼파라미터라고 한다.DecisionTreeClassifier()파라미터의 괄호 안에 각각의 값을 입력할 수 있는데 다음과 같은 항목들이 있다. 하이퍼파라미터 기능 criterion 분할 품질을 측정하는 기능 (default : gini) splitter 각 노드에서 분할을 선택하는 데 사용되는 전략 (default : best) max_depth 트리의 최대 깊이 (값이 클수록 모델의 복잡도가 올라간다.) min_samples_split 자식 노드를 분할하는데 필요한 최소 샘플 수 (default : 2) min_samples_leaf 리프 노드에 있어야 할 최소 샘플 수 (default : 1) min_weight_fraction_leaf min_sample_leaf와 같지만 가중치가 부여된 샘플 수에서의 비율 max_features 각 노드에서 분할에 사용할 특징의 최대 수 random_state 난수 seed 설정 max_leaf_nodes 리프 노드의 최대수 min_impurity_decrease 최소 불순도 min_impurity_split 나무 성장을 멈추기 위한 임계치 class_weight 클래스 가중치 presort 데이터 정렬 필요 여부 괄호 내부에 아무것도 입력하지않으면 기본값으로 결정나무가 출력된다. References https://inuplace.tistory.com/548 https://scikit-learn.org/stable/modules/tree.html#classification","link":"/2021/11/04/Decision_Tree/"},{"title":"마크다운(Markdown) 문법","text":"지금 당장만 해도 이 글을 마크다운으로 작성하고 있는 나는 HTML를 접해보긴 했지만 자유자재로 쓸 수 있는정도는 아니였기에 깃허브 블로그를 시작하면서 마크다운의 문법에 대해 알아야 할 필요가 생겼다. 다른 포스트들도 마찬가지지만 더욱 이 포스트는 자주 찾아 봐야 할 것 같기에 문법만을 기록하며, 접기를 최대한 지양한다. 각 챕터의 위쪽은 코드 그 아래는 출력이다. 마크다운 문법 제목 작성1234# 이러면 큰제목 &lt;h1&gt;태그## 이러면 중간제목 &lt;h2&gt;태그### 이러면 작은제목 &lt;h3&gt;태그#### 이것도 되긴 하지만 굵게한 글자와 차이가 없음. &lt;h4&gt;태그로 사용된다 이러면 큰제목 &lt;h1&gt;태그이러면 중간제목 &lt;h2&gt;태그이러면 작은제목 &lt;h3&gt;태그이것도 되긴 하지만 굵게한 글자와 차이가 없는 &lt;h4&gt;태그로 사용된다 줄바꿈12줄바꿈은 행의 끝에서 공백 두칸을 주고 다음행에 작성하면 된다. 줄바꿈은 행의 끝에서 공백 두칸을 주고다음행에 작성하면 된다. 코드블럭123```과 ~~~는 마크다운의 내용을 코드블럭을 씌운다.```(언어명) 내용 ``` 의 형태로 작성하며이것도 코드블럭으로 씌워진 것이다. 인라인코드1이것은 `인라인코드`이다. 이것은 인라인코드이다. 링크 걸기www.naver.com그냥 주소를 써도 링크로 클릭이 되지만 , 1[WJ 블로그](cincu4221.github.io) WJ 블로그위처럼 작성하면 주소를 숨기고 텍스트에 링크를 걸 수 있다. 텍스트1**강조된 텍스트** 강조된 텍스트 12*기울인텍스트****기울임,강조를적용한텍스트*** 기울인텍스트기울임,강조를적용한텍스트 1~~취소선입니다~~ 취소선입니다 글자색 12345678&lt;span style=&quot;color:orange&quot;&gt;주황색 글씨&lt;/span&gt; &lt;span style=&quot;color:yellow&quot;&gt;노란색 글씨&lt;/span&gt; &lt;span style=&quot;color:#FF0000&quot;&gt;빨간색 글씨&lt;/span&gt; &lt;span style=&quot;color:blue&quot;&gt;파란색 글씨&lt;/span&gt; &lt;span style=&quot;color:green&quot;&gt;초록색 글씨&lt;/span&gt; &lt;span style=&quot;color:pink&quot;&gt;분홍색 글씨&lt;/span&gt; &lt;span style=&quot;color:#00FFFF&quot;&gt;헥스코드 적용 글씨&lt;/span&gt; 주황색 글씨노란색 글씨빨간색 글씨파란색 글씨초록색 글씨분홍색 글씨 헥스코드 적용 글씨 검색하기 애매한 색도 여기 에서 찾을 수 있다. 구분선123***-- ----- 표만들기1234|제목|제목||:---:|:---:||내용|내용|||| 제목 제목 내용 내용 내용 내용 리스트1234567891011121. 순서 있는 리스트2. 순서 있는 리스트345. 순서 있는 리스트 (순서가 틀려도 상관 없다)* 순서 없는 리스트* 순서 없는 리스트+ 순서 없는 리스트+ 순서 없는 리스트- 순서 없는 리스트- 순서 없는 리스트 순서 있는 리스트 순서 있는 리스트 순서 있는 리스트 (순서가 틀려도 상관 없다) 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 순서 없는 리스트 앞으로 계속 추가할것","link":"/2021/11/04/Markdown-Grammar/"},{"title":"NumPy 기본 다지기","text":"Numpy란 무엇인가?Numpy는 상당부분 C언어로 작성된 파이썬 라이브러리이다. 기본적으로 array라는 자료를 생성하고 이를 바탕으로 색인, 처리, 연산 등을 하는 기능을 수행한다. 물론 C언어로 작성되었기 때문에 속도도 꽤나 빠른편이다. Numpy의 기본Numpy 불러오기 Numpy를 사용하기 위해서는 먼저 임포트시켜줘야 한다. 1import numpy as np 위처럼 입력하면 Numpy의 임포트가 된다. 뒤의 as np를 빼고 나머지만 입력해도 되지만, 앞으로 사용할 코드에서 조금 더 편히 사용하기 위하여(그리고 관례적으로) as np를 작성해 준다. Numpy배열 생성 및 둘러보기 Numpy는 기본적으로 array라는 자료구조를 사용하기때문에 배열을 생성하는 방법에 대해 먼저 알아두어야 한다. 1234arr1 = [1,2,3]my_array1 = np.array(arr1)print(my_array1)print(my_array1.shape) Output: [1 2 3] (3,) 위의 출력 중 첫째줄은 arr1의 배열을 그대로 my_arrary1로 가져와 출력한 것이고, 둘째 줄은 가져온 배열의 길이를 튜플로 나타낸 것이다. 값 뒤에 콤마(,)가 붙어있는 이유는 값이 하나만 존재할 때, 튜플은 값 뒤에 콤마가 있어야 하기 때문이다. 다음은 2차원 배열일떄의 예제이다. 1234my_array3 = np.array([[2,4,6],[8,10,12],[14,16,18],[20,22,24]])print(my_array3)print(my_array3.shape)print(my_array3.dtype) Output: [[ 2 4 6] [ 8 10 12] [14 16 18] [20 22 24]] (4, 3) int64 먼저 세개의 출력 중 첫번째로 my_array3의 값인 리스트들이 차례로 나열되며, 그 다음으로는 배열의 (행, 열)의 수, 마지막으로 배열내의 요소의 데이터타입을 출력한다. 마지막으로 3차원 배열일때의 예제이다. 12my_array5 = np.array([[[1, 2], [3, 4],[5, 6]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3, 2) 세려는 양(또는 각각) 배열의 수가 대칭일때의 예제이다, 가장 바깥쪽의 배열부터 순서대로 배열의 수를 출력한다.그렇다면 대칭이 아니라면 어떻게 출력될까? 다음을 살펴보자 12my_array5 = np.array([[[1, 2], [3, 4], [5, 6, 7]], [[5, 6], [7, 8], [9, 10]]])my_array5.shape Output: (2, 3) 출력과 동시에 에러(위 출력창에서는 삭제함)가 뜨는데 추측하기론 양쪽 배열이 대칭이 아니기에 양 배열의 길이가 같은 두번째 항목까지는 출력되나 2와 3으로 갈리는 마지막 항목에서 출력이 안되는것 같다.확실하지않으니 참고만… Numpy의 기본 함수들 Numpy는 여러 함수들을 사용할수 있다, 하지만 함수의 종류가 너무 많기 때문에 이 챕터에서는 기본적인 함수들만 알아보도록 한다. arange arange는 배열을 만들어주는 함수이다.arange([시작],끝,[만큼 건너뜀])으로 작성 할 수 있으며 []안의 항목은 생략 할 수 있다. 12arrange_array = np.arange(3, 13, 2)arrange_array Output: array([ 3, 5, 7, 9, 11]) 3부터 시작해서 12(13-1)까지 출력하며 2씩 건너뛰는 배열을 생성하는 arange예제이다. zeros, ones zeros와 ones는 0또는 1로 초기화된 shape* 차원의 ndarray** 배열 객체를 반환한다.두 함수 모두 객체 생성시 데이터 타입은 float64형식이다.*shape : 행열의 차원**ndarray : N차원의 배열객체. 기존파이썬과는 다르게 ndarray는 오직 같은 종류의 데이터만을 배열에 담을 수 있다. 1234zeros_array = np.zeros((3,2))print(zeros_array)print(&quot;Data Type is:&quot;, zeros_array.dtype)print(&quot;Data Shape is:&quot;, zeros_array.shape) Output: [[0. 0.] [0. 0.] [0. 0.]] Data Type is: float64 Data Shape is: (3, 2) 순서대로 배열, 데이터 타입, 데이터의 차원을 출력한다. 1234ones_array = np.ones((3,4), dtype='int32')print(ones_array)print(&quot;Data Type is:&quot;, ones_array.dtype)print(&quot;Data Shape is:&quot;, ones_array.shape) Output: [[1 1 1 1] [1 1 1 1] [1 1 1 1]] Data Type is: int32 Data Shape is: (3, 4) 같은 순서로 항목들을 출력했고 배열생성시 데이터 타입을 바꿀수 있음을 보여주는 예제이다. reshape reshape는 구조를 재배열해주는 함수이다. 배열명.reshape(차원, 차원)으로 사용할 수 있다. 1234# 위에서 만들어진 3 x 4 배열의 ones_array를 reshape하여 2 x 6로 재배열after_reshape = ones_array.reshape(2,6)print(after_reshape)print(&quot;Data Shape is:&quot;, after_reshape.shape) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] Data Shape is: (2, 6) reshape를 통해서 3x4 배열을 2x6으로 재배열 해준 가장 기본적인 예제이다. 재배열하려는 배열이 3x4 라면 3x4를 곱해서 나오는 값인 12의 인수들로 12의 결과가 나오는 배열((1,12), (2,6), (4,3))들로 바꿀 수 있으며, (2,2,3)등과 같은 3차원배열로도 재배열이 가능하다. reshape의 값에 -1을 넣는다면? 그렇다면 reshape의 괄호 차원값에 -1을 넣는다면 어떻게될까?다음 결과를 보자. 12after_reshape2= ones_array.reshape(-1,6)print(after_reshape2) Output: [[1 1 1 1 1 1] [1 1 1 1 1 1]] -1을 작성한 곳에 12에서 나머지(두번째 값인 6)값을 보고 첫번째 값은 알아서 2로 지정이 된 것이다.다음은 값이 -1 하나일 때의 예제이다. 12after_reshape2= ones_array.reshape(-1)print(after_reshape2) Output: [1 1 1 1 1 1 1 1 1 1 1 1] 결과와 같이 1차원 배열로 바뀐다. 하지만 (12)일뿐, 2차원 배열인 (1,12)과는 같지 않다. Numpy 인덱싱과 슬라이딩 Numpy의 배열에도 값을 추출 할 수 있게 인덱싱과 슬라이딩이 가능하다. 1234my_array2 = np.arange(start=3,stop=30,step=3)my_array2 = my_array2.reshape(3,3)my_array2[1:3,:] Output: array([[12, 15, 18], [21, 24, 27]]) 출력에서 첫번째 인자는 1에서 2(3-1)번째 까지의 배열을 출력하고, 두번째 인자인 :은 첫번째 인자에서 지목된 배열의 항목을 모두 출력하는 것이다. Numpy 정렬 여러 값이 모여있는 array인 만큼 정렬도 가능하다. 이 챕터에서는 오름,내림차순으로 정렬해주는 sort(), 값이 낮은 순서대로 인덱스를 배정해 배열을 출력해주는 argsort()가 있다. sort() 12345height_arr = np.array([174, 165, 180, 182, 168])sorted_height_arr = np.sort(height_arr)print('Height Matrix: ', height_arr)print('np.sort() Matrix: ', sorted_height_arr) Output: Height Matrix: [174 165 180 182 168] np.sort() Matrix: [165 168 174 180 182] 결과에서 보이다시피 sort()함수는 배열내의 값을 오름차순으로 정렬해준다. 내림차순으로 정렬을 하고 싶다면 다음과 같이 하면 된다. 12desc_sorted_height_arr = np.sort(height_arr)[::-1]print('np.sort()[::-1] : ', desc_sorted_height_arr) Output: np.sort()[::-1] : [182 180 174 168 165] 위처럼 정렬을 할 때 sort()의 뒷부분에 [::-1]을 붙여주면 된다. argsort() 123456fives = np.array([10, 5, 15, 20])fives_order = fives.argsort()print(&quot;The original data&quot;, fives)print(&quot;The argsort(): &quot;, fives_order)print(&quot;The asending:&quot;, fives[fives_order]) Output: The original data [10 5 15 20] The argsort(): [1 0 2 3] The asending: [ 5 10 15 20] 출력의 첫번째 줄은 가장 처음 입력했던 일반적인 배열이다.두번째 줄은 오름차순으로 인덱스를 매긴 배열이며,마지막은 두번째줄의 배열에 따라 첫번째줄의 결과인 배열을 정렬한 것이다.","link":"/2021/11/06/NumPy-Basic-Grammar-1/"},{"title":"캐글 데이터 시각화 해석-1","text":"임포트 및 데이터프레임 추가 1234567891011121314151617# This Python 3 environment comes with many helpful analytics libraries installed# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python# For example, here's several helpful packages to loadimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# Input data files are available in the read-only &quot;../input/&quot; directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'): for filename in filenames: print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using &quot;Save &amp; Run All&quot; # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session 12from plotly.offline import plot, iplot, init_notebook_modeinit_notebook_mode(connected=True) 123456789101112import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport plotly.express as pximport plotly.graph_objects as gofrom warnings import filterwarningsfilterwarnings('ignore')colors = ['#B1EDED','#B1B2ED','#1DE7ED','#1DA5ED','#1D50ED','#16548E']df = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv')df.head() 원 그래프 해석 1234567891011fig = go.Figure( data=[ # 그래프의 형태를 나타내는 함수 go.Pie( # 원그래프 labels = df['Q2'][1:].value_counts().index, # 값에 붙일 이름 - df['Q2'][1:].value_counts()의 인덱스 values = df['Q2'][1:].value_counts().values, # 나타낼 값 - df['Q2'][1:].value_counts()의 값 textinfo = 'label+percent')]) # 그래프 항목당 나타낼 텍스트 (여기서는 항목명, 비율)fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인지fig.update_layout( # 그래프의 레이아웃 설정 title_text='Gender Distribution', # 그래프의 제목 showlegend=False) # 범례표시여부fig.show() 그래프 코드 해석 123456fig = go.Figure(data=[ go.Pie( labels = df['Q2'][1:].value_counts().index, values = df['Q2'][1:].value_counts().values, textinfo = 'label+percent' )]) fig = go.Figure(data=[-&gt; 그래프의 기본적인 틀을 설정하는 함수이고, fig에 데이터를 부여해준다. go.Pie(-&gt; 그래프의 형태가 파이모양(원그래프)임을 의미한다. labels = df['Q2'][1:].value_counts().index-&gt; 그래프로 표현될 값에 붙일 이름이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스(질문열을 제외하기 위함) 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 인덱스열 인 것이다. values = df['Q2'][1:].value_counts().values-&gt; 그래프로 표현될 값이다. 이 코드에서는 ‘df’의 ‘Q2’열에 있는 데이터의 ‘1번인덱스 행부터 마지막까지’ 카운트하고 값에따라 분류했을 때의 값(각 값을 카운트한 값) 이다. textinfo = 'label+percent'-&gt; 그래프에 표시된 항목에 나타낼 텍스트를 설정한다. 이 코드에서는 항목명(label)과 비율(percent)을 나타낸다. 123456fig.update_traces( marker=dict(colors=colors[2:])) # 그래프를 어떤 색으로 표현할 것인가를 설정fig.update_layout( # 그래프의 부가정보 설정 title_text='Gender Distribution', # 그래프 제목 showlegend=False) # 범례표시여부fig.show() fig.update_traces(-&gt; 추가바람 marker=dict(colors=colors[2:]))-&gt; 그래프의 색상을 설정한다. 이 코드에서는 위에서 설정된 colors 리스트에서 2번 인덱스부터 순서대로 사용한다. fig.update_layout(-&gt; 그래프의 부가정보를 설정한다. title_text='Gender Distribution'-&gt; 그래프의 제목을 설정한다. showlegend=False)-&gt; 범례의 표기여부를 결정한다. 이 코드에서는 False이므로 범례가 표기되지 않는다. fig.show()-&gt; 화면에 그래프를 표시하는 기능을한다. 몇몇에디터에서는 자동으로 표시되기때문에 호출할 필요가 없는 경우가 있다. 막대그래프 해석 12345678910111213141516171819202122232425262728293031man = df[df['Q2'] == 'Man']['Q1'].value_counts() # 성별이 남성[df['Q2'] == 'Man']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.woman = df[df['Q2'] == 'Woman']['Q1'].value_counts() # 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈로 만듦.textonbar_man = [ # list comprehension = [(변수를 활용한 값) for (사용할 변수 이름) in (순회 할 수 있는 값)] round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] # for문을 사용하여 round함수의 계산을 하고 textonbar_man에 저장textonbar_woman = [ # list comprehension round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]# go = graph_objectsfig = go.Figure(data=[ go.Bar( # 막대그래프 name='Man', # 그래프로 나타낼 항목 x=man.index, # x축에 man의 인덱스 y=man.values, # y축에 man의 값 text=textonbar_man, # 막대의 값을 작성해줄 텍스트 marker_color=colors[2]), #막대 색 go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3])])fig.update_traces( texttemplate='%{text:.3s}%', # fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside') # 그래프상에서 값의 위치fig.update_layout( barmode='stack', # 막대의 형태 title_text='Age distribution by gender', # 그래프 제목 xaxis_title='Age', # x축 제목 yaxis_title='Counts') # y축 제목fig.show() 그래프 코드 해석 1234man = df[df['Q2'] == 'Man']['Q1'].value_counts()woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()textonbar_man = [ round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]textonbar_woman = [ round((w/(m+w))*100, 1) for m, w in zip(man.values, woman.values)] man = df[df['Q2'] == 'Man']['Q1'].value_counts()-&gt; 성별이 남성[df['Q2'] == 'Man]인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. woman = df[df['Q2'] == 'Woman']['Q1'].value_counts()-&gt; 성별이 여성[df['Q2'] == 'Woman']인 행에서 나이['Q1']의 값을 카운트하여 시리즈를 생성한다. textonbar_man = [round((m/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_man에 저장한다. textonbar_woman = [round((uw/(m+w))*100, 1) for m, w in zip(man.values, woman.values)]-&gt; for문을 사용하여 round함수를 계산 하고 textonbar_woman에 저장한다. 12345678910fig = go.Figure(data=[ go.Bar( name='Man', x=man.index, y=man.values, text=textonbar_man, marker_color=colors[2] ), go.Bar( name='Woman', x=woman.index, y=woman.values, text=textonbar_woman, marker_color=colors[3] )]) go.Bar(-&gt; 그래프의 모양이 막대모양임을 의미한다. name='Man', x=man.index, y=man.values,-&gt; 순서대로 막대의 이름, x축에는 man의 인덱스, y축에는 man의 값을 나타내라는 의미이다. text=textonbar_man, marker_color=colors[2]),-&gt; 각각 막대의 값을 작성해줄 텍스트, 막대의 색을 의미한다. 123456789fig.update_traces( texttemplate='%{text:.3s}%', textposition='inside')fig.update_layout( barmode='stack', title_text='Age distribution by gender', xaxis_title='Age', yaxis_title='Counts')fig.show()) texttemplate='%{text:.3s}%',-&gt; fig(print(fig)로 출력가능)내부의 text 인자를 차례대로 출력 (그래프의 위의 텍스트를 표현) textposition='inside'-&gt; 그래프상에서의 값의 위치를 설정한다. barmode='stack'-&gt; 막대의 형태를 표현한다. title_text='Age distribution by gender'-&gt; 그래프의 제목을 설정한다. xaxis_title='Age', yaxis_title='Counts'-&gt; 그래프의 x축 제목, y축 제목 몇몇 요소 확인법 print(type(데이터))-&gt; 데이터의 타입을 출력한다 데이터.head(),데이터.tail()-&gt; 데이터를 인덱스 순으로 출력한다. head는 처음부터 끝까지, tail은 반대로 출력하며 괄호안에 숫자를 입력하면 숫자만큼 출력한다. Referencesgo.Figure() propertiesupdate_traces() propertiesupdate_layout() propertiesshow() propertiesgo.Bar() properties","link":"/2021/11/08/Kaggle_Data_Visualization-1/"},{"title":"파이썬 시각화 기본","text":"파이썬 시각화의 기본 형태들 선 그래프로 시각화하기1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, ax = plt.subplots()ax.plot(dates, min_temperature, label = &quot;Min Temp&quot;)ax.plot(dates, max_temperature, label = &quot;Max Temp&quot;)ax.legend()plt.show() Output 위의 그래프에서 크기의 변화를 준 그래프1234567891011121314import matplotlib.pyplot as pltdates = [ '2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-09', '2021-01-10']min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig, axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))axes.plot(dates, min_temperature, label = 'Min Temperature')axes.plot(dates, max_temperature, label = 'Max Temperature')axes.legend()plt.show() Output fig와 axes 출력12print(fig)print(axes) Output Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) Matplotlib 선 그래프먼저 yfinance라이브러리를 사용하기 위해 설치를 한다. 1!pip install yfinance --upgrade --no-cache-dir 실행시 Collecting yfinance Downloading yfinance-0.1.64.tar.gz (26 kB) Requirement already satisfied: pandas&gt;=0.24 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.1.5) Requirement already satisfied: numpy&gt;=1.15 in /usr/local/lib/python3.7/dist-packages (from yfinance) (1.19.5) Requirement already satisfied: requests&gt;=2.20 in /usr/local/lib/python3.7/dist-packages (from yfinance) (2.23.0) Requirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.7/dist-packages (from yfinance) (0.0.9) Collecting lxml&gt;=4.5.1 Downloading lxml-4.6.4-cp37-cp37m-manylinux_2_17_x86_64.manylinux2014_x86_64.manylinux_2_24_x86_64.whl (6.3 MB) \u001b[K |████████████████████████████████| 6.3 MB 5.3 MB/s \u001b[?25hRequirement already satisfied: python-dateutil&gt;=2.7.3 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2.8.2) Requirement already satisfied: pytz&gt;=2017.2 in /usr/local/lib/python3.7/dist-packages (from pandas&gt;=0.24-&gt;yfinance) (2018.9) Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.7/dist-packages (from python-dateutil&gt;=2.7.3-&gt;pandas&gt;=0.24-&gt;yfinance) (1.15.0) Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,&lt;1.26,&gt;=1.21.1 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (1.24.3) Requirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2021.5.30) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests&gt;=2.20-&gt;yfinance) (3.0.4) Building wheels for collected packages: yfinance Building wheel for yfinance (setup.py) ... \u001b[?25l\u001b[?25hdone Created wheel for yfinance: filename=yfinance-0.1.64-py2.py3-none-any.whl size=24109 sha256=da9039df457bcaed01c34fcce5bc8ee52dcf33151b9275684543166937fa1286 Stored in directory: /tmp/pip-ephem-wheel-cache-qozcsm2m/wheels/86/fe/9b/a4d3d78796b699e37065e5b6c27b75cff448ddb8b24943c288 Successfully built yfinance Installing collected packages: lxml, yfinance Attempting uninstall: lxml Found existing installation: lxml 4.2.6 Uninstalling lxml-4.2.6: Successfully uninstalled lxml-4.2.6 Successfully installed lxml-4.6.4 yfinance-0.1.64 다음과 같이 출력되며 yfinace를 설치한다. yfinance를 임포트해주고 그로부터 데이터를 받아와 출력을 할수 있다. 123import yfinance as yfdata = yf.download('AAPL', '2019-08-01', '2020-08-01')data.info() Output [*********************100%***********************] 1 of 1 completed &lt;class 'pandas.core.frame.DataFrame'&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB 다음과 같이 애플의 1년동안의 주가를 볼 수 있다. 데이터의 컬럼을 지목해서 열람하는것 역시 가능하다. 12ts = data['Open']print(ts.head()) Output Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 data에 담겨있는 애플의 주가정보 중 ‘Open’에 해당하는 전일 종가를 가장 앞쪽(.head())부터 출력한 것이다.애플주식이 이렇게 쌌었나 검색해보니 이게 맞다…. 방법 1. Pyplot API 12345678910111213# import fix_yahoo_finance as yfimport yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-11-01', '2021-11-01')ts = data['Open']plt.figure(figsize=(10,6))plt.plot(ts)plt.legend(labels=['Price'], loc='best')plt.title('Stock Market fluctuation of AAPL') plt.xlabel('Date') plt.ylabel('Stock Market Open Price') plt.show() Output [*********************100%***********************] 1 of 1 completed 이처럼 결과가 출력되지만 이 문법은 시각화를 처음배우는 초심자에게는 적합하지 않다고 한다.후술할 문법과 위 문법 모두 출력은 되나 이 문법은 객체지향이 아니기도 하고 상대적으로 복잡하기때문에 초심자의 경우에 헷갈릴수 있어 사용하지 않는다.구글링 했을때 객체.이 아닌 plt.으로 시작하는 애들이 있다면 그 코드는 스킵하는게 좋다. 방법 2. 객체지향 API 123456789101112131415from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figureimport matplotlib.pyplot as pltfig = Figure()import numpy as npnp.random.seed(6)x = np.random.randn(20000)ax = fig.add_subplot(111)ax.hist(x, 100)ax.set_title('Artist Layer Histogram')# fig.savefig('Matplotlib_histogram.png')plt.show() 이 방법에 대해서는 따로 언급이 없었기 때문에 바로 방법 3으로 넘어간다. 방법 3. Pyplot API + 객체지향 API 12345678910111213import yfinance as yfimport matplotlib.pyplot as pltdata = yf.download('AAPL', '2019-08-01', '2020-08-01')ts = data['Open']fig, ax = plt.subplots(figsize=(10, 6))ax.plot(ts)ax.set_title('Stock Market fluctuation of AAPL')ax.legend(labels=['Price'], loc='best')ax.set_xlabel('Date')ax.set_ylabel('Stock Market Open Price')plt.show() Output [*********************100%***********************] 1 of 1 completed 드디어 꼭 외우라고 하셨던 pyplot + 객체지향 API 방법이다.특히 7번째 행 부터 마지막까지가 중요한데 그에대한 설명은 아래에 표로 적겠다.중요하다 몇번을 강조하셨으니 위 코드는 변형을 해가며 여러번 작성해보자. 설명 표 코드 설명 fig, ax = plt.subplots() 데이터 전체적 외형을 설정하는 부분 ax.plot(ts) 데이터를 표현해주는 행 ax.set_title() 데이터 시각화의 제목 ax.legend() 범례 ax.set_xlabel() x축 데이터의 제목 ax.set_ylabel() y축 데이터의 제목 plt.show() 안해도 상관없으나 ‘완료후 게시’ 라는 뜻으로 작성 앞으로 나올 표의 내용도 표의 위에 있는 코드들과 적절히 섞어서 이해하길 바란다. 막대 그래프 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npimport calendarmonth_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]sold_list = [300, 400, 550, 900, 600, 960, 900, 910, 800, 700, 550, 450]fig, ax = plt.subplots(figsize=(10,6))plt.xticks(month_list, calendar.month_name[1:13], rotation=90)plot = ax.bar(month_list, sold_list)for rect in plot: print(&quot;graph:&quot;, rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.002*height,'%d' % int(height), ha='center', va='bottom')plt.show() Output graph: Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) graph: Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) graph: Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) graph: Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) graph: Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) graph: Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) graph: Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) graph: Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) graph: Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) graph: Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 메소드 설명 .xticks()는 x축의 눈금을 나타내는 메소드인데 기본적으로는 list자료형 한개을 사용한다.하지만 메소드에 인자가 ‘list’ 두 개로 받아졌을 경우,첫번째 list는 x축 눈금의 갯수가 된다.두번째 list는 x축 눈금의 이름이 된다.이 코드에서는 rotation 옵션도 들어가 있는데 이것은 그냥 이름을 몇도정도 기울일지 나타낸다.plot = ax.bar()는 그래프를 막대로 만든다.첫번째 리스트 인자의 수 만큼 막대가 생성되고,두번째 리스트 인자의 값 만큼 막대가 길어진다.이렇다보니 첫번째 리스트와 두번째 리스트의 인자의 수가 일치해야 에러가 나지 않는다.for문 내부의 ax.text()는 Seaborn-막대그래프-표현할 값이 한 개인 막대 그래프 챕터에 서술했으니 참고하길 바란다. 산점도 그래프 두개의 연속형 변수 (키, 몸무게 등) 상관관계 != 인과관계 나타내는 값이 한가지인 산점도 그래프 123456789101112131415import matplotlib.pyplot as pltimport seaborn as sns# 내장 데이터tips = sns.load_dataset(&quot;tips&quot;)x = tips['total_bill']y = tips['tip']fig, ax = plt.subplots(figsize=(10, 6))ax.scatter(x, y) # 각각의 값을 선으로 표현해주는 scatter()ax.set_xlabel('Total Bill')ax.set_ylabel('Tip')ax.set_title('Tip ~ Total Bill')fig.show() Output 나타내는 값이 두 가지인 산점도 그래프 12345678910111213label, data = tips.groupby('sex')tips['sex_color'] = tips['sex'].map({&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot;})fig, ax = plt.subplots(figsize=(10, 6))for label, data in tips.groupby('sex'): ax.scatter(data['total_bill'], data['tip'], label=label, color=data['sex_color'], alpha=0.5) ax.set_xlabel('Total Bill') ax.set_ylabel('Tip') ax.set_title('Tip ~ Total Bill by Gender')ax.legend()fig.show() Output 히스토그램 수치형 변수 1개 12345678910111213141516import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터 titanic = sns.load_dataset('titanic')age = titanic['age']nbins = 21fig, ax = plt.subplots(figsize=(10, 6))ax.hist(age, bins = nbins) # 여기서 bins = nbins는 히스토그램을 더 세밀하게 나누어 준다.ax.set_xlabel(&quot;Age&quot;)ax.set_ylabel(&quot;Frequency&quot;)ax.set_title(&quot;Distribution of Aae in Titanic&quot;)ax.axvline(x = age.mean(), linewidth = 2, color = 'r')fig.show() Output 코드 설명 .hist() 데이터를 히스토그램으로 표현해주는 메소드 .axvline() 데이터의 평균을 선으로 나타내주는 메소드 박스플롯 x축 변수: 범주형 변수, 그룹과 관련있는 변수, 문자열 y축 변수: 수치형 변수 12345678910111213import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset('iris')data = [iris[iris['species']==&quot;setosa&quot;]['petal_width'], iris[iris['species']==&quot;versicolor&quot;]['petal_width'], iris[iris['species']==&quot;virginica&quot;]['petal_width']]fig, ax = plt.subplots(figsize=(10, 6))ax.boxplot(data, labels=['setosa', 'versicolor', 'virginica'])fig.show() Output 수정바람) 정확히 어떻게 이 그래프가 출력되는지 모르기에 좀 더 공부후 수정할 것 히트맵 123456789101112131415import matplotlib.pyplot as pltimport numpy as npimport seaborn as sns# 내장 데이터flights = sns.load_dataset(&quot;flights&quot;)flights = flights.pivot(&quot;month&quot;, &quot;year&quot;, &quot;passengers&quot;)fig, ax = plt.subplots(figsize=(12, 6))im = ax.imshow(flights, cmap = 'YlGnBu')ax.set_xticklabels(flights.columns, rotation = 20)ax.set_yticklabels(flights.index, rotation = 10)fig.colorbar(im)fig.show() Output year month passengers 0 1949 Jan 112 1 1949 Feb 118 2 1949 Mar 132 3 1949 Apr 129 4 1949 May 121 .. ... ... ... 139 1960 Aug 606 140 1960 Sep 508 141 1960 Oct 461 142 1960 Nov 390 143 1960 Dec 432 [144 rows x 3 columns] 제목 제목 fig.colorbar() 값의 빈도 수에 대한 컬러바생성 Seaborn 산점도와 회귀선이 있는 산점도 산점도 12345678%matplotlib inline import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)sns.scatterplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips)plt.show() Output 회귀선이 있는 산점도 1234567891011121314fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(15, 5))sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[0], fit_reg = True)sns.regplot(x = &quot;total_bill&quot;, y = &quot;tip&quot;, data = tips, ax = ax[1], fit_reg = False)plt.show() Output 위의 코드처럼 fit_reg = True로 해줄 경우 회귀선이 나타나는것을 알 수 있다.그리고 ax = ax[num]의 경우에는 그래프의 인덱스로 보인다. 히스토그램/커널 밀도 그래프 12345678910import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)plt.figure(figsize=(10, 6))sns.displot(x = &quot;tip&quot;, data = tips)sns.displot(x=&quot;tip&quot;, kind=&quot;kde&quot;, data=tips) # 종류 = 커널밀도 그래프(kde)sns.displot(x=&quot;tip&quot;, kde=True, data=tips) # 히스토그램에 kde를 넣을건가 = Trueplt.show() Output &lt;Figure size 720x432 with 0 Axes&gt; 박스플롯12345678#import matplotlib.pyplot as plt # 주석처리된 부분은 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. #import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.boxplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips)sns.swarmplot(x = &quot;day&quot;, y = &quot;total_bill&quot;, data = tips, alpha = .25)plt.show() Output 막대 그래프1234567#import matplotlib.pyplot as plt # 이 주석 역시 원래 실행 해줘야 하는 내용이지만 위 히스토그램 챕터에서 미리 입력했기 때문에 생략한다. 이하 기본주석이라 하고 생략한다.#import seaborn as sns#tips = sns.load_dataset(&quot;tips&quot;)sns.countplot(x = &quot;day&quot;, data = tips)plt.show() Output 'tips'Data의 'day'값, 인덱스별 정렬, 'tips'의 내림차순 재배치 123print(tips['day'].value_counts())print(&quot;index: &quot;, tips['day'].value_counts().index)print(&quot;values: &quot;, tips['day'].value_counts().values) Sat 87 Sun 76 Thur 62 Fri 19 Name: day, dtype: int64 index: CategoricalIndex(['Sat', 'Sun', 'Thur', 'Fri'], categories=['Thur', 'Fri', 'Sat', 'Sun'], ordered=False, dtype='category') values: [87 76 62 19] 'tips'Data의 'day'값에 대한 오름차순(ascending) 정렬 1print(tips['day'].value_counts(ascending=True)) Fri 19 Thur 62 Sun 76 Sat 87 Name: day, dtype: int64 표현할 값이 한 개인 막대 그래프 1234567# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, order = tips['day'].value_counts().index) # x축을 'day'로 지정, data는 'tips'로 채워넣음, 'day'의 값이 높은 순서대로 막대그래프 정렬 for p in ax.patches: # ax.patches = p height = p.get_height() # 아래행을 실행하기위해 막대그래프의 높이 가져옴 ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9) # 막대그래프 위 수치 작성ax.set_ylim(-5, 100) # y축 최소, 최대범위plt.show() Output 나중에 다시 본다면 조금 설명이 필요할 것 같다.특히 ax.text행의 인자가 조금 많은데 설명이 필요한 듯하다.직접 colab에서 이것저것 만져본 결과 추측하기로는 다음 표과 같은듯 하다. 코드 설명 p.get_x() + p.get_width()/2. 수치가 들어갈 x축 위지 height+3 y축 위치(현재 +3) height 수치의 값을 조절할 것인지(현재 +0) ha = ‘center’ 수치를 (x,y)축의 가운데로 정렬 size=9 폰트의 크기이다 여기서 혹시나 ha = 'center'부분이 잘 이해가 안될수 있다.내가그랬다ha =는 (x,y)축의 기준이 될 곳을 정하는 인자인듯 하다.center말고도 left,right등을 사용할수 있는데 막대의 기준에서 왼쪽,오른쪽이 아닌 텍스트의 기준에서 왼쪽,오른쪽이라 방향을 선택하면 오히려 반대로 배치되는것을 알 수 있다. 표현할 값이 두 개인 막대 그래프 123456789# 기본주석 생략ax = sns.countplot(x = &quot;day&quot;, data = tips, hue = &quot;sex&quot;, dodge = True, order = tips['day'].value_counts().index)for p in ax.patches: height = p.get_height() ax.text(p.get_x() + p.get_width()/2., height+3, height, ha = 'center', size=9)ax.set_ylim(-5, 100)plt.show() Output 이 코드에서 첫째줄의 인자를 표로 나타내면 코드 설명 x = “day” x축이 나타낼 자료 data = tips 표현할 데이터셋 hue = “sex” 그래프로 표현할 항목 dodge = True 항목끼리 나눠서 표현할 것인지 order = tips[‘day’].value_counts().index ‘day’의 값이 높은 순서대로 그래프 정렬 sns.countplot() x축이 나타낼 자료, 나타낼 데이터셋, 그래프로 나타낼 항목, 항목끼리 나눠서 표현할것인지, ‘day’의 값이 높은 순서대로 막대그래프 정렬 상관관계 그래프 데이터 불러오기 및 행, 열 갯수 표시하기 12345678910import pandas as pd import numpy as np import seaborn as snsimport matplotlib.pyplot as pltmpg = sns.load_dataset(&quot;mpg&quot;)print(mpg.shape) # 398 행, 9개 열num_mpg = mpg.select_dtypes(include = np.number) # num_mpg에 'mpg' 데이터셋의 데이터타입 총갯수를 입력한다(숫자형 데이터타입만 포함)print(num_mpg.shape) # 398 행, 7개 열 (두개가 사라진 이유는 number타입이 아닌 Object타입이기 때문) (398, 9) (398, 7) 데이터셋의 컬럼 표시 1num_mpg.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 398 entries, 0 to 397 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 mpg 398 non-null float64 1 cylinders 398 non-null int64 2 displacement 398 non-null float64 3 horsepower 392 non-null float64 4 weight 398 non-null int64 5 acceleration 398 non-null float64 6 model_year 398 non-null int64 dtypes: float64(4), int64(3) memory usage: 21.9 KB 데이터셋 컬럼간의 상관관계 표시 1num_mpg.corr() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mpg cylinders displacement horsepower weight acceleration model_year mpg 1.000000 -0.775396 -0.804203 -0.778427 -0.831741 0.420289 0.579267 cylinders -0.775396 1.000000 0.950721 0.842983 0.896017 -0.505419 -0.348746 displacement -0.804203 0.950721 1.000000 0.897257 0.932824 -0.543684 -0.370164 horsepower -0.778427 0.842983 0.897257 1.000000 0.864538 -0.689196 -0.416361 weight -0.831741 0.896017 0.932824 0.864538 1.000000 -0.417457 -0.306564 acceleration 0.420289 -0.505419 -0.543684 -0.689196 -0.417457 1.000000 0.288137 model_year 0.579267 -0.348746 -0.370164 -0.416361 -0.306564 0.288137 1.000000 상관관계 히트맵 1234567891011fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]sns.heatmap(num_mpg.corr(), ax=ax[0])ax[0].set_title('Basic Correlation Heatmap', pad = 12) # 상관관계 수치 그래프 [Correlation Heatmap with Number]sns.heatmap(num_mpg.corr(), vmin=-1, vmax=1, annot=True, ax=ax[1])ax[1].set_title('Correlation Heatmap with Number', pad = 12)plt.show() Output 위의 코드에서 pad는 히트맵과 타이틀의 간격설정이며,set_title의 인자를 설명하면 (히트맵을 만들 ‘데이터셋.corr()’, 히트맵의 최소값, 최대값, 수치표현(bool값), 마지막인자는 확실하지는 않지만 앞의 히트맵 설정을 어떤 히트맵에 적용시킬지 묻는것 같다.) 상관관계 배열 만들기 1234# import numpy as np# 윗단 코드에서 만들어진 num_mpg 사용print(int(True))np.triu(np.ones_like(num_mpg.corr())) 1 array([[1., 1., 1., 1., 1., 1., 1.], [0., 1., 1., 1., 1., 1., 1.], [0., 0., 1., 1., 1., 1., 1.], [0., 0., 0., 1., 1., 1., 1.], [0., 0., 0., 0., 1., 1., 1.], [0., 0., 0., 0., 0., 1., 1.], [0., 0., 0., 0., 0., 0., 1.]]) np.triu(배열, k=0)는 위 결과처럼 우하향 대각선이 있고 위 아래로 삼각형이 있다 생각했을때 아래쪽의 삼각형이 모두 0이 되는 함수이다.k의 숫자가 낮아질수록 삼각형은 한칸씩 작아진다.위 결과에서 행과 열이 7칸이 된 이유는 np.ones_like(num_mpg.corr())의 행이 7개 이기때문인듯 하다.확실히 모르겠음 질문 필수 12mask = np.triu(np.ones_like(num_mpg.corr(), dtype=np.bool))print(mask) [[ True True True True True True True] [False True True True True True True] [False False True True True True True] [False False False True True True True] [False False False False True True True] [False False False False False True True] [False False False False False False True]] k 값을 바꿔 True와 False로 값을 준 경우. 12345678910# 기본주석 생략fig, ax = plt.subplots(figsize=(16, 5))# 기본 그래프 [Basic Correlation Heatmap]ax = sns.heatmap(num_mpg.corr(), mask=mask, vmin=-1, vmax = 1, annot=True, cmap=&quot;BrBG&quot;, cbar = True)ax.set_title('Triangle Correlation Heatmap', pad = 16, size = 16)fig.show() Output 위의 글들을 모두 읽었음에도 단 하나 모르는 요소가 있다면 바로 cmap일 것이다.cmap은 colormap을 줄인것으로 cmap의 종류는 상당히 많다.이곳에 가면 상당히 잘 정리되어 있으니 cmap옵션을 사용할 때마다 요긴하게 쓸 수 있을것이다. Intermediate페가블로그 코드 https://jehyunlee.github.io/2020/08/27/Python-DS-28-mpl_spines_grids/ 이 챕터의 내용은 코드가 너무 긺으로 시각화 결과물을 접지않고 코드를 접는형식으로 서술하겠음. 필수 코드이므로 생략을 생략 1234import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as np Code 12345678910111213141516171819202122232425262728def plot_example(ax, zorder=0): ax.bar(tips_day[&quot;day&quot;], tips_day[&quot;tip&quot;], color=&quot;lightgray&quot;, zorder=zorder) ax.set_title(&quot;tip (mean)&quot;, fontsize=16, pad=12) # Values h_pad = 0.1 for i in range(4): fontweight = &quot;normal&quot; color = &quot;k&quot; if i == 3: fontweight = &quot;bold&quot; color = &quot;darkred&quot; ax.text(i, tips_day[&quot;tip&quot;].loc[i] + h_pad, f&quot;{tips_day['tip'].loc[i]:0.2f}&quot;, horizontalalignment='center', fontsize=12, fontweight=fontweight, color=color) # Sunday ax.patches[3].set_facecolor(&quot;darkred&quot;) ax.patches[3].set_edgecolor(&quot;black&quot;) # set_range ax.set_ylim(0, 4) return axdef major_formatter(x, pos): return &quot;{%.2f}&quot; % xformatter = FuncFormatter(major_formatter) 123tips = sns.load_dataset(&quot;tips&quot;)tips_day = tips.groupby(&quot;day&quot;).mean().reset_index()print(tips_day) day total_bill tip size 0 Thur 17.682742 2.771452 2.451613 1 Fri 17.151579 2.734737 2.105263 2 Sat 20.441379 2.993103 2.517241 3 Sun 21.410000 3.255132 2.842105 Code 12fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2) Code 123456fig, ax = plt.subplots(figsize=(10, 6))ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False) Code 12345678910fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) Code 12345678910111213fig, ax = plt.subplots()ax = plot_example(ax, zorder=2)ax.spines[&quot;top&quot;].set_visible(False)ax.spines[&quot;right&quot;].set_visible(False)ax.spines[&quot;left&quot;].set_visible(False)ax.yaxis.set_major_locator(MultipleLocator(1))ax.yaxis.set_major_formatter(formatter)ax.yaxis.set_minor_locator(MultipleLocator(0.5)) ax.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;) 책 코드 Code 12345678910111213141516import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0]) Code 12345group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)print(&quot;The Best Day:&quot;, h_day)print(&quot;The Highest Avg. Total Biil:&quot;, h_mean) The Best Day: Sun The Highest Avg. Total Biil: 21.41 Code 1234567891011121314151617181920212223tips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)fig.show() Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)fig.show() Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import matplotlib.pyplot as pltfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, FuncFormatter)import seaborn as snsimport numpy as nptips = sns.load_dataset(&quot;tips&quot;)fig, ax = plt.subplots(nrows = 1, ncols = 2, figsize=(16, 5))def major_formatter(x, pos): return &quot;%.2f$&quot; % xformatter = FuncFormatter(major_formatter)# Ideal Bar Graphax0 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, color='lightgray', alpha=0.85, zorder=2, ax=ax[0])group_mean = tips.groupby(['day'])['total_bill'].agg('mean')h_day = group_mean.sort_values(ascending=False).index[0]h_mean = np.round(group_mean.sort_values(ascending=False)[0], 2)for p in ax0.patches: fontweight = &quot;normal&quot; color = &quot;k&quot; height = np.round(p.get_height(), 2) if h_mean == height: fontweight=&quot;bold&quot; color=&quot;darkred&quot; p.set_facecolor(color) p.set_edgecolor(&quot;black&quot;) ax0.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12, fontweight=fontweight, color=color)ax0.set_ylim(-3, 30)ax0.set_title(&quot;Ideal Bar Graph&quot;, size = 16)ax0.spines['top'].set_visible(False)ax0.spines['left'].set_position((&quot;outward&quot;, 20))ax0.spines['left'].set_visible(False)ax0.spines['right'].set_visible(False)ax0.yaxis.set_major_locator(MultipleLocator(10))ax0.yaxis.set_major_formatter(formatter)ax0.yaxis.set_minor_locator(MultipleLocator(5))ax0.set_ylabel(&quot;Avg. Total Bill($)&quot;, fontsize=14)ax0.grid(axis=&quot;y&quot;, which=&quot;major&quot;, color=&quot;lightgray&quot;)ax0.grid(axis=&quot;y&quot;, which=&quot;minor&quot;, ls=&quot;:&quot;)ax0.set_xlabel(&quot;Weekday&quot;, fontsize=14)for xtick in ax0.get_xticklabels(): print(xtick) if xtick.get_text() == h_day: xtick.set_color(&quot;darkred&quot;) xtick.set_fontweight(&quot;demibold&quot;)ax0.set_xticklabels(['Thursday', 'Friday', 'Saturday', 'Sunday'], size=12)ax1 = sns.barplot(x = &quot;day&quot;, y = 'total_bill', data = tips, ci=None, alpha=0.85, ax=ax[1])for p in ax1.patches: height = np.round(p.get_height(), 2) ax1.text(p.get_x() + p.get_width()/2., height+1, height, ha = 'center', size=12)ax1.set_ylim(-3, 30)ax1.set_title(&quot;Just Bar Graph&quot;)plt.show() Text(0, 0, 'Thur') Text(0, 0, 'Fri') Text(0, 0, 'Sat') Text(0, 0, 'Sun')","link":"/2021/11/03/python_visualization_basic_/"},{"title":"파이썬(Python) 사용자 지정 함수","text":"사용자 지정 함수란? 파이썬에서(다른프로그래밍 언어, 스크립트 언어에서도) 함수란, 소프르웨어에서 특정 동작을 수행하는 일정 코드부분을 의미한다. 하나의 큰 프로그램을 여러부분으로 나누어주기 때문에 같은 함수를 여러 상황에서 여러차례 호출할 수 있고, 일부분을 수정하기 쉽다는 장점을 지닌다. 파이썬에서는 미리 정의 되어있는 built in 함수(내장함수)가 있고. 또, 사용자가 필요에 의해 정의를 한 사용자 지정 함수가 존재한다. 파이썬에서의 함수 모형 파이썬 함수의 기본 모형1234def 함수명() : 실행문 실행문 ... 이와 같은 구조인데 함수를 정의하는 def뒤에 함수명이 오고 소괄호()를 붙인 다음 콜론:을 붙여주고, 다음줄에 원하는 실행문을 들여쓰기하여 사용하면 된다. 12def func() : print('python function') 위는 기본 모형을 응용하여 함수를 정의한 것이다. 이는 입력값도, 반환값도 없는 함수이며 값이 있는 함수에 대해서는 후술하겠다. 그러나 위 코드는 함수를 정의한 것이지 사용을 한 것이 아니다. 그렇기 때문에 함수를 사용하기 위해서는 함수의 사용법을 알아야 한다. 12345def func() : print('python function')#함수 호출func() Output 1python function func()함수는 입력값이 없기때문에 호출시에 입력값을 넣어주지 않고 괄호만 입력해 준다. 입력값만 있는 함수 123456def func2(a) : print('입력한 문자는 ' + a + ' 입니다.')func2(&quot;비행기&quot;)func2(&quot;자동차&quot;)func2(&quot;파이썬&quot;) Output 123입력한 문자는 비행기 입니다.입력한 문자는 자동차 입니다.입력한 문자는 파이썬 입니다. func2()함수의 입력값이 a 에 입력되어 출력 된 것을 볼 수 있다. 리턴값만 있는 함수 1234def func3() : return &quot;12345&quot;print(func3()) Output 112345 func3()의 값이 리턴되어 print()를 통해 출력된 것을 알 수 있다. 입력,리턴값이 모두 있는 함수 1234def func4(a, b) : return a + bprint(func4(10,20)) Output 130 a,b의 입력값을 더하는 함수에 10,20의 값을 주었더니 예상대로 30이 출력 되었다. 기본 인자 값 입력이 있는 함수를 여러 곳에 사용할 때 반복되는 값에 대해서는 기본적인 값을 지정할 수 있다.기본값은 입력 = 값의 형태로 작성된다. 12345def func_b(a,b,c=5) : return a*b+cprint(func_b(2,3,10))print(func_b(2,3)) Output 121611 출력에서처럼 기본값이 주어진 c 인자에 별다른 값을 넣지 않으면 기본값 5로 계산되어 10이들어간 결과보다 5가 낮아지게 된다. 이렇게 기본 인자를 줄 때는 주의 할 점이 한 가지 있는데 바로 인자의 순서에 맞게 넣어주어야 한다는 것과, 기본값과 입력값이 없으면 에러가 난다는 것이다.다음 예시를 보자. 1234def func_b2(a,b=5,c) : return a*b+cprint(func_b2(2,3)) 위와 같이 값을 주게 된다면 어떨까?b에 기본값이 있으니 a와 c에 각각 2와 3이 입력된다고 생각한 사람도 있을 것이다.그러나 이 생각은 적어도 사용자 지정 함수에서는 옳지 않다. 이 코드가 불가능한 데에는 두 가지 이유가 있다. 첫 번째로는 a에는 2가 들어가는 것이 맞겠지만, b에 기본값이 있더라도 두 번째 입력값 자리에 3을 넣게 되는 순간 그 숫자는 b에 입력되기 때문에 결국엔 기본값이 없는 c는 어떠한 값도 입력받지 못하게 되기 때문이고, 두 번째 이유로는 c의 인자에 기본값이 없음에도 앞에 있는 b의 인자에 기본값이 있으므로 아예 성립할 수 없는 코드이다.그러므로 기본값을 부여받은 인자는 항상 뒤에 배치해야 한다. 키워드 인자 키워드 인자는 함수를 정의할때 인자에 키워드를 부여하고 함수를 호출할 때 키워드=값의 형태로 넣어줄 수 있는 인자이다.그냥 인자에 값을 넣어주는것과 뭐가 다르냐?라는 의문이 들 수도 있다.다음 예시를 보자. 1234def score(kim=100, lee=100, park=100, choi=100) : print('score = kim :', kim, 'lee :',lee, 'park :',park, 'choi :',choi)score(park= 50) Output 1score = kim : 100 lee : 100 park : 50 choi : 100 이렇게 중간의 인자만 키워드=값의 형태로 입력해 값을 변경해 줄 수 있다.예제처럼 여러 기본값이 있고 그중 몇 가지의 기본값만 바꿔 주어야 할 때 용이하게 쓸 수 있다. Arbitrary Argument Lists (임의 인자 리스트) Arbitrary Argument Lists는, 여러인자를 함수에 잔달하는 방법들중 하나이다. 함수내부에서 이 인자들은 튜플로 감싸져있으며 이는*argsarguments 생성자를 사용하여 정의 된다. 12345678910def avg_score(*numbers) : s = 0 count = 0 for i in numbers: s += i count += 1 return s / countprint('국어와 수학점수의 평균은{}점 입니다'.format(avg_score(95, 87)))print('입력된 숫자들의 평균은{} 입니다.'.format(avg_score(42,63,45,32,48))) Output 12국어와 수학점수의 평균은91.0점 입니다입력된 숫자들의 평균은46.0 입니다. 위 코드에서는 *args를 *numbers로 대체했다.이처럼 함수를 호출 할 때에 숫자를 몇가지를 넣어도 사용이 가능하다. Lambda 함수 우리가 앞에서 배웠던 대로 사용자 지정 함수를 정의하고 사용하여 평균을 구하라고 한다면 아마 다음과 같을것이다. 12345def avg(x,y): return(x + y) / 2print(avg(5,13))&gt;&gt; 9.0 그러나 파이썬은 Lambda함수를 통해서 이 코드를 더욱 짧게 줄일수 있다. 123print((lambda x,y: (x + y)/2)(5,13))&gt;&gt; 9.0 그러나 배우는 입장인 내 눈으로 단점을 찾아보자면 함수인데 정의를 하는 부분이 따로 없다 보니, 출력할 일이 여러 번 생긴다면 번거로워 질 것 같다.그러니 앞으로 호출 횟수에 따라 적다면 람다 함수를, 많다면 기본적인 사용자 지정 함수를 사용하는 방식이 좋을 듯하다. References https://djangojeng-e.github.io","link":"/2021/11/10/Python-UserDefinedFunctions/"},{"title":"산점도(scatter plot)와 박스플롯(box plot)","text":"산점도(scatter plot)산점도란? 산점도, 산포도scatter plot는 직교좌표계를 이용해 좌표상의 점들을 표시함으로써 두 개 변수 간의 관계를 나타내는 그래프 방법이다.도표 위에 두 변수 X와 Y값이 만나는 지점을 표시한 그림. 이 그림을 통해 두 변수 사이의 관계를 알 수 있다. 언제 사용되는가?? 산점도는 다음의 경우에 사용된다. 두 종류의 데이터의 관계를 파악할때. 즉, 양의 상관관계, 음의 상관관계, 관계없음 등의 관계를 파악한다. 산점도의 작성으로 한 변수에 대한 결과의 영향조사를 한다. Plotly로 산점도 작성하기 데이터 임포트 및 데이터셋 생성123456789import numpy as npimport pandas as pd# plotly 라이브러리 불러오기import plotly.offline as poimport plotly.graph_objs as go# 임의의 숫자로 이루어진 2열,100행의 데이터프레임 생성df1 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B'])df2 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B']) 하나의 산점도 그리기 123trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers')data = [trace1]pyo.iplot(data) Output df1이 그대로 산점도로 출력된 모습이다. 두 개 이상의 산점도 그리기 1234trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers')trace2 = go.Scatter(x=df2['A'], y=df2['B'], mode='markers')data = [trace1, trace2]pyo.iplot(data) Output df1과 df2가 한 도표 내에 산점도로 출력된 모습이다.이렇게 다른 데이터를 표시하고 싶을때에는 출력코드에 새로운 데이터값을 넣어주기만 하면 된다. 마커 모양 변경하기 1234trace1 = go.Scatter(x=df1['A'], y=df1['B'], mode='markers', marker=dict(size=7, color='#D90B0B', symbol=20))trace2 = go.Scatter(x=df2['A'], y=df2['B'], mode='markers', marker=dict(size=7, color='#F24444', symbol=23))data = [trace1, trace2]pyo.iplot(data) Output 그림처럼 마커의 모양을 변경 할 수 있다.color옵션은 헥스코드와 rgb값 모두 가능하며, 모양의 경우 매우 다양하므로 포스팅 최하단에 링크를 첨부한다. 박스플롯 (box plot)박스플롯이란?? ‘박스플롯’box plot,또는 ‘상자 수염 그림’은 수치적 자료를 나타내는 그래프이다. 이 그래프는 가공하지 않은 자료 그대로를 이용하여 그린 것이 아니라, 자료로부터 얻어낸 통계량인 ‘5가지 요약 수치’five-number summary 를 가지고 그린다. 이 때 5갸지 요약 수치란 최솟값, 제 1사분위(Q1),제 2사분위(Q2), 제 3사분위(Q3), 최댓값을 일컫는 말이다. 히스토그램과는 다르게 집단이 여러개인 경우에도 한 공간에 수월하게 나타낼수 있다. 언제 사용되는가?? 박스 플롯을 사용하는 이유는 데이터가 매우 많을때 모든 데이터를 한눈에 확인하기 어려우니 그림을 이용해 데이터 집합의 범위와 중앙값을 빠르게 확인 할 수 있는 목적으로 사용한다.또한, 통계적으로 이상치outlier가 있는지도 확인이 가능하다. 박스플롯의 구성 박스플롯을 처음 접한다면 박스플롯을 어떻게 해석해야 하는지 난해할수 있다.다음 그림에서 박스플롯의 각 구성이 무엇을 의미하는지 간단하게 알아보자.각 요소들을 설명하면 다음과 같다. 요소 설명 이상치(outlier) 최소값보다 작은데이터 또는 최대값보다 큰 데이터가 이상치에 해당한다 최대값(upper whisker) ‘중앙값 + 1.5 × IQR’보다 작은 데이터 중 가장 큰 값 최소값(lower whisker) ‘중앙값 - 1.5 × IQR’보다 큰 데이터 중 가장 작은 값 IQR(Inter Quartile Range) 제3사분위수 - 제1사분위수실수 값 분포에서 1사분위수(Q1)와 3사분위수(Q3)를 뜻하고 이 3사분위수와 1사분위수의 차이(Q3 - Q1)를 IQR라고 한다. 중앙값 박스내부의 가로선, 용어 그대로 중앙값이다 whisker 상자의 상하로 뻗어있는 선 Plotly로 박스플롯 작성하기 1234567891011import numpy as npimport pandas as pdimport matplotlib.pyplot as pltdf3 = pd.DataFrame(np.random.randint(0, 100, (100, 2)), columns=['A', 'B']) #임의로 수 생성plt.figure(figsize=(8,7)) # 크기 지정boxplot = df3.boxplot(column=['B']) # df3의 'B'컬럼을 박스플롯으로 생성plt.yticks(np.arange(0,101,step=5)) # 박스플롯이 그려질 범위 지정plt.show() Output 위처럼 임의로 생성된 데이터프레임을 이용해 박스플롯을 만들 수 있다. References산점도 그리기산점도 마커 모양위키백과 - 산점도위키백과 - 상자 수염 그림박스플롯 및 요소 설명","link":"/2021/11/12/scatterPlot-boxPlot/"},{"title":"2021 캐글 대회 코드 작성기 - 1","text":"파이썬을 배운지 며칠 되지 않아 kaggle이라는 예측모델 및 분석대회 플랫폼의 데이터 분석 대회에 참가하게 되었다.주제는 2021년 캐글러kaggler들에게 설문조사이며, 그 설문조사 데이터셋을 바탕으로 참가자가 분석을 하여 참가자만의 주제에 그래프와 수치로 답을 찾아내는 대회이다. 데이터셋에 있는 캐글러의 수는 19년 19717명, 21년 25974명, 직업은 데이터사이언스, 데이터 엔지니어부터 학생까지 다양하며, 나이, 학력, 국적, 라이브러리, 언어 등 매우 다양한 항목들이 있다. 우리 조에서 처음으로 선정하려 했던 주제는 한국, 일본, 중국의 캐글러의 트렌드변화로 하려 했으나, 중국, 일본에 비해 데이터가 턱없이 부족해 비교가 무의미한 수준이었기에 캐글러의 수가 비슷한 두 나라인 중국과 일본로 선정했다.(의외로 중국의 캐글러 절대적인 수가 인구에 비해 상당히 적어 일본보다 조금 적은편이였다.) import(Kaggle notebook) 1234567891011121314151617import numpy as np import pandas as pdimport matplotlib.pyplot as pltimport plotly.express as pximport plotly.graph_objects as gofrom warnings import filterwarningsfrom plotly.subplots import make_subplotsfilterwarnings('ignore')colors = ['#B1EDED','#B1B2ED','#1DE7ED','#1DA5ED','#1D50ED','#16548E']gen_colors = ['#4169E1','#B2182B','#81007F','#D1B2FF','#EFE4E2']JP_colors = ['#D90B0B','#F24444','#EFE4E2','#FCCE88','#64807F']CN_colors = ['#E0201B','#FFCE3F','#A63F03','#04BF33','#F2E6D8']coun_years_colors = ['#D90B0B','#FFCE3F','#FF6161','#FFDB81']df19 = pd.read_csv('../input/kaggle-survey-2019/multiple_choice_responses.csv')df21 = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv') 이처럼 후에 사용할 라이브러리를 임포트, 그래프에 사용할 색을 리스트로 만들어주고 df19에 19년의 데이터셋을, df21에 21년의 데이터셋을 넣어준다. 사용자 지정 함수 12345678910def group(data, country, question_num): return data[data['Q3'] == country][question_num].value_counts()def go_Pie(country, label_value): return go.Pie(title = country, labels = label_value.index, values = label_value.values, textinfo = 'label+percent', rotation=315, hole = .3,) 앞으로 코드에서 사용될 함수이다.사용자 지정 함수란? Q1. What`s your age? 12345678910111213141516171819202122232425262728JP_age_19 = group(df19,'Japan','Q1').sort_index()JP_age_21 = group(df21,'Japan','Q1').sort_index()CN_age_19 = group(df19,'China','Q1')CN_age_19.loc['55-59'] = 0CN_age_19.loc['60-69'] = 0CN_age_19 = CN_age_19.sort_index()CN_age_21 = group(df21,'China','Q1')CN_age_21.loc['60-69'] = 0CN_age_21 = CN_age_21.sort_index()fig_age = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]])fig_age.add_trace(go.Bar(name=coun_years[0], x=JP_age_19.index, y=JP_age_19.values, marker_color='#FDB0C0'),1,1)fig_age.add_trace(go.Bar(name=coun_years[2], x=JP_age_21.index, y=JP_age_21.values, marker_color='#FD4659'),1,1)fig_age.add_trace(go.Bar(name=coun_years[1], x=CN_age_19.index, y=CN_age_19.values, marker_color='#FFDB81'),1,2)fig_age.add_trace(go.Bar(name=coun_years[3], x=CN_age_21.index, y=CN_age_21.values, marker_color='#FFAB0F'),1,2)fig_age.update_layout(barmode='group', title_text='2019 &amp; 2021, Japan and China age distribution', showlegend=True)fig_age.update_xaxes(title_text='Japan Age distribution', row=1, col=1)fig_age.update_yaxes(title_text='Counts', row=1, col=1)fig_age.update_xaxes(title_text='China Age distribution', row=1, col=2)fig_age.update_yaxes(title_text='Counts', row=1, col=2)fig_age.show() 첫번째 주제인 What`s your age?에 대한 일본과 중국의 캐글러 나이분포를 막대그래프로 나타낸 것이다.각 그래프는 연도별로 나눈 일,중 캐글러의 나이 분포이고 그래프의 항목은 18세부터 70세 이상까지 3,4년씩을 한 항목으로 묶었다. Q2. What`s your gender? 1234567891011121314151617181920212223242526272829303132333435363738394041JP_ndarray = df19[df19['Q3'] == 'Japan']['Q2'].valuesCN_ndarray = df19[df19['Q3'] == 'China']['Q2'].valuesJP_age_list = []CN_age_list = []for item in JP_ndarray: if item == 'Male': item_mod = item.replace('Male','Man') JP_age_list.append(item_mod) elif item == 'Female': item_mod2 = item.replace('Female','Woman') JP_age_list.append(item_mod2) else : JP_age_list.append(item) for item in CN_ndarray: if item == 'Male': item_mod = item.replace('Male','Man') CN_age_list.append(item_mod) elif item == 'Female': item_mod2 = item.replace('Female','Woman') else : CN_age_list.append(item)JP_age_series = pd.Series(JP_age_list)CN_age_series = pd.Series(CN_age_list)fig = make_subplots(rows=2, cols=2, specs=[[{'type':'domain'}, {'type':'domain'}], [{'type':'domain'}, {'type':'domain'}]])fig.add_trace(go_Pie('2019_Japan', JP_age_series.value_counts()),1,1)fig.add_trace(go_Pie('2019_China', CN_age_series.value_counts()),1,2)fig.add_trace(go_Pie('2021_Japan', group(df21,'Japan','Q2')),2,1)fig.add_trace(go_Pie('2021_China', group(df21,'China','Q2')),2,2)fig.update_traces(marker=dict(colors=gen_colors[0:]))fig.update_layout(title_text='Gender Distribution', showlegend=True, autosize=True, height=700)fig.show() 두번쨰 질문에 답하기 위해 일본과 중국의 캐글러 성별분포를 도넛모양으로 나타낸 그래프이다.각각의 그래프는 국가,년도(2019, 2021)별로 각각 나누었고 그래프의 항목은ManWomanPrefer not to sayNonbinaryPrefer to self-describe이렇게 다섯가지로 나누었다. Referencesplotly bar chart tutorialplotly bar chart properties (bar traces)plotly pie chart tutorialplotly pie chart properties (pie traces)","link":"/2021/11/17/kaggle-2021survey-code-1/"},{"title":"2021 캐글 대회 코드 작성기 - 2","text":"Q3. In which country do you currently reside? 1234567891011121314151617181920years = ['2019', '2021']JP_country_count_19 = (df19[df19['Q3'] == 'Japan']['Q3']).count()CN_country_count_19 = (df19[df19['Q3'] == 'China']['Q3']).count()JP_country_count_21 = (df21[df21['Q3'] == 'Japan']['Q3']).count()CN_country_count_21 = (df21[df21['Q3'] == 'China']['Q3']).count()JP_country_count_19_21 = [JP_country_count_19, JP_country_count_21]CN_country_count_19_21 = [CN_country_count_19, CN_country_count_21]fig_country = go.Figure(data=[ go.Bar(name='Japan', x=years, y=JP_country_count_19_21, marker_color=JP_colors[0]), go.Bar(name='China', x=years, y=CN_country_count_19_21, marker_color=CN_colors[1])])fig_country.update_layout( barmode='group', title_text='2019 &amp; 2021, the number of Kaggler living in Japan and China', xaxis_title='Years', yaxis_title='Counts')fig_country.show() 2019년과 2021년 일본과 중국 캐글러의 수를 비교한 막대그래프이다.일본은 빨강 중국은 노란색 막대로 표현했으며 일본의 수치가 인구 대비 상당히 높은 걸 알 수 있다.양국 모두 캐글러의 수치가 증가했다.2년간 일본은 약 35%, 중국은 약 40%가 증가했으며 증가한 캐글러의 수는 일본이 높지만 비율은 중국이 앞섰다. Q14. What data visualization libraries or tools do you use on a regular basis? 12345678910111213141516171819202122232425262728293031323334353637383940414243df19_JP = df19[df19.Q3.isin(['Japan'])]df19_CN = df19[df19.Q3.isin(['China'])]df21_JP = df21[df21.Q3.isin(['Japan'])]df21_CN = df21[df21.Q3.isin(['China'])]df19_JP_Q14 = pd.DataFrame()df19_CN_Q14 = pd.DataFrame()df21_JP_Q14 = pd.DataFrame()df21_CN_Q14 = pd.DataFrame()df19_JP_Q14['Q20'] = [df19_JP[col][1:].value_counts().index[0] for col in df19_JP.columns[97:109]]df19_CN_Q14['Q20'] = [df19_CN[col][1:].value_counts().index[0] for col in df19_CN.columns[97:109]]df21_JP_Q14['Q14'] = [df21_JP[col][1:].value_counts().index[0] for col in df21_JP.columns[59:71]]df21_CN_Q14['Q14'] = [df21_CN[col][1:].value_counts().index[0] for col in df21_CN.columns[59:71]]df19_JP_Q14['counts'] = [df19_JP[col][1:].value_counts().values[0] for col in df19_JP.columns[97:109]]df19_CN_Q14['counts'] = [df19_CN[col][1:].value_counts().values[0] for col in df19_CN.columns[97:109]]df21_JP_Q14['counts'] = [df21_JP[col][1:].value_counts().values[0] for col in df21_JP.columns[59:71]]df21_CN_Q14['counts'] = [df21_CN[col][1:].value_counts().values[0] for col in df21_CN.columns[59:71]]df19_JP_Q14.index = [3,0,6,4,5,2,7,1,8,9,10,11]df19_CN_Q14.index = [3,0,6,4,5,2,7,1,8,9,10,11]df19_JP_Q14 = df19_JP_Q14.sort_index()df19_CN_Q14 = df19_CN_Q14.sort_index()df21_JP_Q14['Q14'].index = [0,1,2,3,4,5,6,7,8,9,10,11]df21_CN_Q14['Q14'].index = [0,1,2,3,4,5,6,7,8,9,10,11]df19_JP_Q14.replace(regex = 'D3.js', value = 'D3 js', inplace = True)df19_CN_Q14.replace(regex = 'D3.js', value = 'D3 js', inplace = True)fig_T = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]])fig_T.add_trace(go.Bar(name=coun_years[0], x=df19_JP_Q14['Q20'].values, y=df19_JP_Q14['counts'], marker_color=coun_years_colors[0]),1,1)fig_T.add_trace(go.Bar(name=coun_years[1], x=df19_CN_Q14['Q20'].values, y=df19_CN_Q14['counts'], marker_color=coun_years_colors[1]),1,1)fig_T.add_trace(go.Bar(name=coun_years[2], x=df21_JP_Q14['Q14'].values, y=df21_JP_Q14['counts'], marker_color=coun_years_colors[2]),1,2)fig_T.add_trace(go.Bar(name=coun_years[3], x=df21_CN_Q14['Q14'].values, y=df21_CN_Q14['counts'], marker_color=coun_years_colors[3]),1,2)fig_T.update_layout(title_text='2019 &amp; 2021, Visualization Library and Tools in Use', showlegend=True, autosize=True)fig_T.update_xaxes(title_text='2019 Library and Tools', row=1, col=1)fig_T.update_yaxes(title_test='Counts', row=1, col=1)fig_T.update_xaxes(title_text='2021 Library and Tools', row=1, col=2)fig_T.update_yaxes(title_text='Counts', row=1, col=2)fig_T.show() 각 그래프를 연도로 나누고 그래프에는 그에 해당하는 라이브러리,툴 사용량을 국가별로 나누어 넣은 막대그래프이다.양국 모두 전반적으로 증가하였으나 눈에띄는 부분은 중국의 None항목이 크게 늘었고, 중국은 모든 항목의 사용량이 증가한 반면에 일본은 감소세가 보이는 항목이 있었다. Q16. Which of the following machine learning frameworks do you use on a regular basis? 1234567891011121314151617fig_F = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]]) fig_F.add_trace(go.Bar(name=coun_years[0], x=df19_JP_Q16['Q28'].values, y=df19_JP_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[0]),1,1)fig_F.add_trace(go.Bar(name=coun_years[1], x=df19_CN_Q16['Q28'].values, y=df19_CN_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[1]),1,1)fig_F.add_trace(go.Bar(name=coun_years[2], x=df21_JP_Q16['Q16'].values, y=df21_JP_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[2]),1,2)fig_F.add_trace(go.Bar(name=coun_years[3], x=df21_CN_Q16['Q16'].values, y=df21_CN_Q16['counts'].sort_values(ascending=False).values, marker_color=coun_years_colors[3]),1,2) fig_F.update_layout(title_text='2019 &amp; 2021, Machine Learning Frameworks in Use', showlegend=True, autosize=True)fig_F.update_xaxes(title_text='2019 Machine Learning Frameworks', row=1, col=1)fig_F.update_yaxes(title_text='Counts', row=1, col=1)fig_F.update_xaxes(title_text='2021 Machine Learning Frameworks', row=1, col=2)fig_F.update_yaxes(title_text='Counts', row=1, col=2)fig_F.show() 이번 질문에대한 답도 비슷하다. 그래프는 연도로 나누고 각각의 x축에는 사용하는 머신러닝 프레임워크, y축에는 그 수가 표기되어 얼마나 많은 캐글러가 머신러닝 프레임워크를 사용하지는 나타낸다.각 년도의 차이점은 (프레임워크의 사용자의 수는 물론이거니와)프레임워크의 종류가 19년도에 비해 21년에 약증했다는 점이 있고, 특이점이라면 21년 일본의 사이킷런Scikit-learn 사용자의 수가 급증했다는 점이 있다.","link":"/2021/11/19/kaggle-2021survey-code-2/"},{"title":"Github Repository생성 및 로컬 저장소 연결, 업로드 명령어","text":"Github repository 생성 로그인된 깃허브 홈페이지에서 Your repositories &gt; 우상단 New 버튼을 클릭한 후 Repository name을 입력하여 리포지토리를 생성한다. Repository와 로컬 저장소를 연결 Repository와 같은 이름으로 폴더를 하나 생성해 준 후 폴더 아무곳이나 우클릭하여 Git Bash Here로 터미널을 실행해준다. 1$ cd [Directory] 디렉토리 주소를 입력하면 바탕화면에서 터미널을 실행하여 명령어로 진입 할 수도 있다. 1$ git init 명령어를 입력해 업로드할 폴더에서 깃을 init한다.(로컬 저장소 생성) 우측의 copy버튼을 클릭하여 주소를 복사한다. 1$ git remote add origin [Repository URL] 명령어를 입력해준 후 위에서 복사했던 주소를 붙여넣어준다. (Git Bash에서의 붙여넣기는 Shift + Insert) Repository URL을 잘못입력했다면 아래 명령어들을 참고하면 된다. 현재 로컬 저장소의 Repository URL 확인 : $ git remote -v 현재 로컬 저장소의 Repository URL 변경 : $ git remote set-url origin [재설정할 Repository URL] 현재 로컬 저장소의 Repository URL 삭제 : $ git remote remove origin 로컬 저장소에 있는 파일을 업로드로컬 저장소에 있는 파일을 깃허브에 업로드하기 위해서는 다음 세가지의 명령어를 차례로 입력해주어야 한다. 12$ git add .$ git add file.py 위처럼 add 명령어로 commit 될 대상에 파일을 포함시킬수 있다.add . 은 변동사항이 있는 모든파일을, 두번째줄은 해당파일만 포함시킨다. 1$ git commit -m &quot;표시할 메세지&quot; 파일을 커밋하고 그 커밋에 대해 간단한 메세지를 남기는 명령어이다. 12$ git push$ git push origin HEAD:master 커밋한 파일들을 깃허브로 올려주는 명령어이다.첫째 줄 명령어로 푸시가 안된다면 아래 명령어를 입력해보자 성공적으로 연결되어 커밋, 푸시까지 된 모습이다.","link":"/2021/11/26/Link_github_repository/"},{"title":"plotly를 사용하여 막대그래프 만들기","text":"캐글 대회에 참가하면서 파이썬 문법이나 plotly의 특성에 대해 구글링하는 시간이 훨씬 늘었다.앞으로도 대회에 참가하거나 시각화를 할 때에 이렇게나 많은 특성을 모두 외울수는 없으니 구글링을 하게 될 텐데, 자주쓰는 속성이나 기본틀에 대해서는 포스팅을 해두고 바로바로 찾아보는것이 좋겠다는 생각이 들었다. 그래서 이번 포스팅에서는 앞으로 자주 사용하게 될 차트 중 하나인 막대그래프의 기본 틀과 자주 사용되는 속성에 대해 포스팅 하려 한다. 데이터는 2021 Kaggle Machine Learning &amp; Data Science Survey 대회의 데이터를 사용한다. import 및 데이터 불러오기12345import plotly.graph_objects as goimport pandas as pdfrom plotly.subplots import make_subplotsdf21 = pd.read_csv('../input/kaggle-survey-2021/kaggle_survey_2021_responses.csv') 필요한 라이브러리를 import 해주고 데이터를 불러와 저장해준다.필자는 캐글노트북에서 작성하여 data add 기능으로 kaggle에 있는 데이터를 바로 불러왔지만 로컬이나 colab, jupyter등의 다른 노트북을 사용중이라면 데이터를 다운받은후 괄호안의 경로를 재설정해주어야 한다. 출력할 데이터 확인1df21[0:5][Q1,Q14] # Q1,Q14 항목의 값 0부터 4까지 출력 ㅤ Q1 Q3 0 What is your age (# years)? In which country do you currently reside? 1 50-54 India 2 50-54 Indonesia 3 22-24 Pakistan 4 45-49 Mexico 이렇게 출력하거나 1df21[df21['Q3'] == &quot;South Korea&quot;] # Q3 항목의 값이 &quot;South Korea&quot;인 행의 데이터프레임 출력 위 코드처럼 어느 조건에 해당하는행을 출력 할 수도 있다. 12KR_Age = df21[df21['Q3'] == 'South Korea']['Q1'].value_counts()JP_Age = df21[df21['Q3'] == 'Japan']['Q1'].value_counts() 위 코드는 Q3(국가)이 South Korea인 행과 Japan인 행의 Q1(연령)값을 뽑아내는 코드로 이를 통해 그래프를 만들어 볼 것이다. 다중 차트 틀 만들기위에서 import한 make_subplots으로 차트여러개를 출력 할 수 있다. 1fig = make_subplots(rows=1, cols=2, specs=[[{'type':'xy'}, {'type':'xy'}]]) fig 객체를 생성해주고 차트를 1행, 2열로 만들어주는 코드이다.막대그래프의 경우엔 'type':'xy' 파이그래프의 경우엔 'type':'domain'으로 할수있다.specs에서 중괄호는 차트한개를 나타내며 내부의 중괄호가 여러개라면 각각 행을 구분하는 용도로 쓰인다. 각 속성으로 차트 그리기1234567891011fig.add_trace(go.Bar(name='Korea', x=KR_Age.index, y=KR_Age.values, marker_color='red'),1,1)fig.add_trace(go.Bar(name='Japan', x=JP_Age.index, y=JP_Age.values, marker_color='blue'),1,2)fig.update_layout(barmode='group', title_text='2021, Korea and Japan age distribution', showlegend=True)fig.update_xaxes(title_text='Korea Age distribution', row=1, col=1)fig.update_yaxes(title_text='Counts', row=1, col=1)fig.update_xaxes(title_text='Japan Age distribution', row=1, col=2)fig.update_yaxes(title_text='Counts', row=1, col=2)fig.show() add_trace, update_layout 등의 파라미터(속성)값으로 그래프를 꾸미는 코드이다. fig.add_trace(go.Bar(name='Korea', x=KR_Age.index, y=KR_Age.values, marker_color='red'),1,1)부터 살펴보면go.Bar는 막대그래프를 뜻한다, 각 파라미터를 살펴보면name는 그래프에 표현되는 항목의 이름,x는 그래프의 x축이 나타낼 항목,y는 그래프의 y축이 나타낼 값,marker_color은 그래프의 색을 표현하며가장 끝의1,1는 위 항목이 표시될 그래프의 행,열을 뜻한다.(그러니 1번째 행 1번째 열의 그래프에 Korea 항목이 들어간다.) fig.update_layout(barmode='group', title_text='2021, Korea and Japan age distribution', showlegend=True)도 뜯어보겠다.barmode는 한 그래프에 여러 항목이 들어있을 경우 어떻게 나타내는지에 대한 속성인데 대표적으로 group과stack이 있다.title_text는 제목, showlegend는 범례 표기 여부를 가리킨다. 마지막의 fig.show()는 fig객체를 출력하는 코드이다. 아래 References에 막대그래프의 파라미터가 정리되있는 링크를 걸어놓을테니 활용하여 다양하게 그래프를 만들어보자. References plotly bar chart tutorial plotly bar chart properties (bar traces)","link":"/2021/11/24/plotly-Bar-Chart-basic/"},{"title":"파이썬 데코레이터 (Python Decorator)","text":"데코레이터란? 파이썬으로된 소스코드들을 보면, 가끔 다음과 같은 구문을 볼 수 있다. 123@decoratordef func() print(&quot;How to use Python&quot;) 본적은 있는것 같으나 어디에 어떻게 사용되는지 처음보는사람은 모를 수 있다.데코레이터는 함수를 수정하지 않은 상태에서 추가기능을 구현할 때 사용한다.일단 다음의 예시를 보자 12345678def func1(): print(&quot;func1&quot;)def func2(): print(&quot;func2&quot;)func1()func2() 위 두개의 함수에 각각 시작부분과 끝부분을 표기하고싶다면 아래와 같이 함수 시작, 끝부분에 print를 따로 넣어주어야 한다. 123456789101112def func1(): print(&quot;func1 start&quot;) print(&quot;func1&quot;) print(&quot;func1 end&quot;)def func2(): print(&quot;func2 start&quot;) print(&quot;func2&quot;) print(&quot;func2 end&quot;)func1()func2() 함수가 한개, 두개라면 부담이 되지않겠지만 만약 10개, 100개, 1000개의 함수가 있고 그것을 수정해야한다면 여간 귀찮은 일이 아닐것이다. 이런 경우에 데코레이터를 사용하면 편리하다.바로 다음 예시를 보자 1234567891011121314151617181920212223def dec(func): def wrapper(func): print(func.__name__, &quot;start&quot;) func() print(func.__name__, &quot;end&quot;) return wrapperdef func1(): print(&quot;func1&quot;)def func2(): print(&quot;func2&quot;)dec_func1 = dec(func1)dec_func1()dec_func2 = dec(func2)dec_func2()'''또는dec(func1)()dec(func2)()''' 1234567&lt;Output&gt;func1 startfunc1func1 endfunc2 startfunc2func2 end 위처럼 입력하게 될 경우 먼저 만들어졌던 dec 함수에 의해 func1, func2의 함수 출력부분에 시작과 끝을 나타내는 print가 같이 출력되게 할 수 있다. 위 코드에서 start 와 end 앞에 있는 func1,func2의 경우에는 함수의 이름이 출력되는것이고, 그 사이에 있는 func1,func2은 함수의 print 열이 출력된 것이다. @가 있는 데코레이터 사용하기 그런데 처음에 예시로 보았던 @로 시작하는 데코레이터는 어디에도 보이지 않는다.@를 사용하는 데코레이터는 어떻게 만드는 것일까? @를 사용하는 데코레이터는 다음과 같이 작성한다. 123@decdef func1(): print(&quot;func1&quot;) 간결하게 적어서 이해가 어려울 수 있으니 이전 챕터의 가장 뒷부분 코드를 가져와 수정해보면 다음과 같다. 1234567891011121314151617def dec(func): def wrapper(): print(func.__name__, &quot;start&quot;) func() print(func.__name__, &quot;end&quot;) return wrapper@decdef func1(): print(&quot;func1&quot;)@decdef func2(): print(&quot;func2&quot;)func1()func2() 결과는 같지만 무엇보다 출력부분이 매우 간결해졌다. 만약 한개의 함수에 데코레이터 여러개를 사용해야한다면 다음과 같이 할 수 있다. 12345@dec1@dec2@dec3def func1(): print(&quot;func1&quot;) 코드가 위와 같을 때 여러개의 데코레이터가 지정되며 이때 데코레이터가 실행되는 순서는 위에서 아래 순으로 실행된다. 마지막으로 데코레이터를 그림으로 표현하면 다음과 같다. Referencehttps://bluese05.tistory.com/30","link":"/2021/12/07/Python-Decorator/"},{"title":"파이썬(Python) with 구문","text":"with 구문이 무엇인가? 보통 프로그램은 파일에 접근해서 파일 내용등을 읽고 쓰고 수정하는등의 일을 수행한 뒤 다시 그 파일을 마운트 해제 하는 패턴을 따른다.예시로 사용자가 워드파일 문서 작업을 하고 있을 때 그 파일을 열고있는 동안 파일관리자가 그 문서의 이름을 바꾼다던지 파일의 경로를 변경한다던지 같은 파일에 접근을 필요로하는 행동을 타 프로그램에서 할 수 없게 된다. 결론만 말하자면 파일에 접근했으면(열었으면) 해제하는(닫아주는) 일을 빼먹지 않고 해주어야 한다는 것이다.보통 close() 같은 메소드를 사용하여 파일을 닫아주지만 이는 문제점이 있다.파일 처리를 수행하는 도중에 오류가 발생하게되면 아래에있는 close() 문을 실행할 수 없고 파일을 닫을수 없게된다. with 문은 그 구문을 실행했을 때 오류가 발생하던 하지않던 마지막에 close 를 해주도록 하는 것이다. with문 사용 예시 123456789101112131415# 일반적인 코드file = open('textfile.txt', 'r')contents = file.read()file.close()# try finally를 사용한 코드try: file = open('textfile.txt', 'r') contents = file.read()finally: file.close() # with 구문을 사용한 코드with open('textfile.txt', 'r') as file: contents = file.read() 위의 세가지 코드는 모두 같은 내용이지만 첫번째 코드를 실행할때 contents = file.read() 행에서 에러가 난다면 file.close()를 실행하지 못해 파일을 닫을 수 없다.그러나 아래의 두가지 코드는 에러가 발생해도 코드를 닫을 수 있을 뿐더러 with문은 더욱 간결하여 보기 편하다. 여러개의 파일 관리하기 두 개 이상의 파일을 동시에 사용할 때 with as 문을 사용하는 방법이다.두개의 with as 문을 겹쳐도 되고, 하나의 with문에 두 개 이상의 파일을 열어도 된다. 123456789101112131415161718with open('textfile_a.txt', 'r') as a: with open('textfile_b.txt', 'w') as b: a_file = a b_file = b.write('hello wolrd') with open('textfile_a.txt', 'r') as a, open('textfile_b.txt', 'w') as b: a_file = a b_file = b.write('hello world')# 파이썬 3.10.0 b1 버전부터는 아래처럼도 가능하다with ( open('textfile_a','w') as a, open('textfile_b','w') as b, open('textfile_c','w') as c): a.write('apple') b.write('banana') c.write('count') class로 context manager 구현하기 1234567class File(object): def __init__(self, file_name, method): self.file_obj = open(file_name, method) def __enter__(self): return self.file_obj def __exit__(self, type, value, trace_back): self.file_obj.close() 위와 같이 정의를 하고 아래처럼 실행해 보면 12with File('demo.txt', 'wb') as opened_file: opened_file.write('Hola!') with 문은 File class의 __exit__메소드를 저장 File class의 __enter__메소드를 호출 __enter__메소드는 파일을 열고 파일을 반환 열려진 파일은 변수명 opened_file에 저장 .write()을 통해 내용 작성 with문 이기 때문에 __exit__문을 호출 __exit__문을 통해 파일 닫음 위와같은 실행순서로 context manager를 구현 할 수 있다. References.https://tempdev.tistory.com/22https://ddanggle.gitbooks.io/interpy-kr/content/ch24-context-manager.html","link":"/2021/12/06/Python-context-manager/"},{"title":"git branch 기초 (추가,이동,삭제 등)","text":"heroku를 통해서 대시보드 배포를 하려고 애를 쓰던중에 끝도없는 에러와 마주쳐서 github Repo를 지웠다 만들었다 하기를 열번가량 반복하다가 현타가 왔다.강사님이 주신 URL 대로하면 가장 기본적인 배포는 가능하니 처음것을 백업해놓고 이것저것 고쳐가며 써보자 하는 생각이 들자 git이 애초에 그런(버전 관리) 프로그램이었다는 게 생각나 찾아보고 포스팅하게 되었다. 그래서 branch가 뭔데? branch는 git에서 독립적으로 어떠한 작업을 진행하기 위한 개념이다.각각 나누어진 branch는 서로 영향을 주거나 받지 않기 때문에 여러작업을 동시에 진행해볼 수 있다.또, 이렇게 나누어진 branch는 다른 branch와 병합하거나 덮어씀으로써 작업한 내용을 새로운 하나의 브랜치로 모을 수 있다. 위의 그림처럼 branch에서 서비스추가, 버그수정 등을 하고 main branch에 병합시키는 것이다.branch 에서 작업을 하다가 문제가 되어도 폐기하고 main branch에서 새로 branch를 만들면 되니 원본 손실의 위험도 없다. 그럼, 어떻게 쓰는건데? branch의 명령어는 꽤나 다양하지만 이 포스팅에서는 추가,이동,삭제등의 기본적인 것만들 다루겠다.(추후 포스팅 예정) branch 확인branch를 추가, 이동, 삭제하기 전에 Repo에 어떤 branch가 있는지 확인해야한다.(동명의 branch는 만들어지지 않는다.)확인을 하기 위해서는 Repo의 디렉토리에서 터미널이나 git bash로 다음 코드를 작성한다. 1git branch branch에 대해 처음 알았고 아무 조작도 가하지 않았다면 아마도 master(또는 main) branch만 있을 것이다.그리고 현재 적용(?)된 branch 가 색이 다르며 앞에 별표(*)가 있다. branch 추가이제 새롭게 branch 를 만들어보자 만약 자신이 원하는 branch 의 이름이 bugfix 라면 터미널에 다음처럼 작성하면 된다. 12# git branch &quot;branchName&quot;git branch bugfix 별다른 반응 없이 추가가 됐을 것이다.확인을 위해 다시 git branch 를 해보면.. 이렇게 새로 branch가 만들어 졌을것이다. branch 이동branch를 새로이 만들었으니 이젠 새로 만든 branch에서 작업을 하기위해 이동을 해야한다.이동하는 명령어는 다음과 같다. 12# git checkout &quot;branchName&quot;git checkout bugfix branch를 이동했으며 bugfix 가 활성화 된 것이 보인다. branch 삭제필요없는 branch를 어떻게 삭제 할까? 12# git branch -d &quot;branchName&quot;git branch -d bugfix 현재 활성화된 branch를 삭제하려는 경우에는 삭제되지않으니 checkout으로 다른 branch로 이동한 다음 삭제를 시켜줘야 한다. 이렇게 branch 의 기본적인 명령어들을 알아보았는데 클론을 만들고 클론이 잘못될 경우 다시 되돌릴수 있다는 것 자체가 매우 필요한 기능이라 자주 사용하게 될듯 하다.","link":"/2021/12/10/git-branch-1/"},{"title":"콜백(Callback)함수의 사용법","text":"Plotly 를 사용하여 대시보드를 만드는 동안에 직면했던 여러 문제들중 해결에 꽤 오랜시간이 걸린 문제가 있었다.바로 콜백함수에 대한 부분인데 처음보게된 콜백함수가 데코레이터가 적용된 그런 함수였기 때문에 굉장히 헷갈렸다. 콜백함수 콜백함수란 다른함수의 인자로써 이용되는함수, 어떤 이벤트에 의해 호출되어지는 함수를 말한다.함수가 다른함수의 인자로 사용될 수 있다니, 잘 이해가 되지 않을 수 있다. 내가 접했던 콜백함수를 가져와 보면 이렇다. 123456789101112131415161718@app.callback( Output('id_fig_age', 'Figure'), Input('country-filter', 'value'))def age_chart_func(value): obj = px.bar(data, x=data[data['Q3'] == value]['Q1'][1:].value_counts().sort_index().index, y=data[data['Q3'] == value]['Q1'][1:].value_counts().sort_index().values, ) obj.update_traces(hovertemplate='%{x}: %{y:.0f}', marker_color='#E08E79', marker_line_width=0,) obj.update_layout(paper_bgcolor=colors['content-background'], font_color=colors['text'], plot_bgcolor=colors['plot_background'], autosize=True) obj.update_xaxes(title_text='Age Distribution') obj.update_yaxes(title_text='Counts') return obj 전체코드의 일부분이지만 함수를 설명하는데에는 문제가 없다. 먼저 가장 위에 있는 @app.callback가 무슨뜻인지 이해하지 못한다면 데코레이터 에 대해 간략히 보고 오면 좋다.그리고 Output과 Input은 dash.dependencies 라이브러리에서 import 한 것인데, 기능을 살펴보기위해 코드대로 해석하자면 Input의 괄호안의 첫번째 인자(country-filter)와 ID가 같은 항목을 찾아 두번째 인자(country-filter 의 파라미터 value)를 아래에 있는 함수의 인자로 넣어주며, 인자를 통해 함수를 실행 후 나온 리턴을,Output의 괄호안의 첫번째 인자(id_fig_age)와 ID가 같은 항목의 두번째 인자(Figure)로 입력되는 것이다. 위 코드에서 복잡해 보일 수 있는 부분인 px.bar ~ obj.update_yaxes 까지는 그냥 그래프를 그려주는 함수라고 생각하면된다. 이때 이 함수를 모두 실행하고 리턴하는 값인 obj 가 반환되어 Output인 ‘id_fig_age’의 ‘Figure’속성으로 입력되고 ‘id_fig_age’는 함수에서 작성된 그래프를 ‘Figure’로 갖게되어 화면에 표현해준다.","link":"/2021/12/30/callback-func/"},{"title":"파이썬(Python) 데이터 크롤링 기초 수업 정리","text":"개발자나 데이터분석가에게 중요한 능력중 하나를 꼽자면 무엇일까.자신이 진행할 프로젝트의 데이터를 수집하는 능력도 꽤나 중요하지 않을까 싶다.그러기 위해서는 크롤링을 해야 할 때가 있는데 크롤링이란 HTML(웹페이지)를 그대로 가져와 데이터를 추출하는 행위를 말한다.그래서 이번 포스트에서는 학원에서 배운 간단한 크롤링에대해 수업 그대로를 정리하려 한다. 사전준비 크롤링을 하기위해 일단 BeautifulSoup 라는 파이썬 라이브러리를 설치해 주어야 한다.다음 코드를 터미널에 입력해 라이브러리를 설치한다. 1pip install beautifulsoup4 설치가 완료되었다면 예제 HTML 문서를 하나 만들어주면 준비는 끝난다. index.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Crawl This Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;cheshire&quot;&gt; &lt;p&gt;Don't crawl this.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;elice&quot;&gt; &lt;p&gt;Hello, Python Crawling!&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;p&gt;I am in main&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; BeautifulSoup를 사용하여 크롤링먼저 크롤링을 하기 위해 파이썬 파일을 만들어준다. 1from bs4 import Beautifulsoup 이후 Beautifulsoup 라이브러리를 import하고 간단한 함수를 만들어 크롤링을 해보자. HTML 불러오기123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) # open의 괄호안에 크롤링할 HTML파일의 위치를 입력 print(soup)if __name__ == &quot;__main__&quot;: crawling() 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;title&gt;Crawl This Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;cheshire&quot;&gt;&lt;p&gt;Don't crawl this.&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;elice&quot;&gt;&lt;p&gt;Hello, Python Crawling!&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; HTML 파일이 soup에 저장되어 출력된 것을 볼 수 있다. 필요한 태그만 가져오기하지만 우리는 HTML 전체가 아닌 특정 텍스트, 태그만 필요로 하기 때문에 그것들을 뽑아낼 수 있어야 한다. 123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) print(soup.find(&quot;p&quot;))if __name__ == &quot;__main__&quot;: crawling() 1&lt;p&gt;Don't crawl this.&lt;/p&gt; find()함수는 가장 앞쪽의 한 태그만을 가져온다.이처럼 p태그가 출력되었는데 두가지 의문이 생길 것이다.‘p태그는 두개인데 왜 한개만 출력되는가?’와 ‘&lt;p&gt;&lt;/p&gt;없이 텍스트만 추출 할수 없는가?’라는 것이다.물론 가능하다.첫번째는 find()함수를 find_all()로 바꾸면 모든 p태그가 출력되고,두번째는 find()함수 뒤에 .get_text()를 붙여주면 태그가 제외된 텍스트만 출력이 된다.이외에도 많은 함수가 있고, Beautiful Soup Documentation 에서 찾아볼 수 있다. class, id로 태그 가져오기여전히 크롤링이라기엔(기초지만) 부족하다 원하는 태그를 가져올 수는 있으나 태그가 여러개면 같이 가져올 수밖에 없기 때문이다.그래서 이번에는 각 태그에 주어진 class와 id를 통해 크롤링하는 법에 대해 알아보자. index.html을 보면 div태그에 각각 class와 id가 있다.이를통해 크롤링 하는 코드를 보면 123456def crawling(): soup = BeautifulSoup(open(&quot;data/index.html&quot;), &quot;html.parser&quot;) print(soup.find(&quot;div&quot;, class_ = &quot;elice&quot;).find(&quot;p&quot;).get_test())if __name__ == &quot;__main__&quot;: crawling() 다음과 같으며 이를 실행하면 1Hello, Python Crawling! 위와 같이 출력된다.만약 class가 아닌 id를 지정해서 태그를 찾고싶을 경우 find()함수 내에 class_ = 가 아닌 id = 를 입력하면 된다.class는 언더바가 붙고 id는 붙지 않는다. OPEN API를 통해 데이터 가져오기open API를 통해 데이터를 가져오는 법도 간단히 알아보자.이 포스팅은 캐글을 기반으로 진행했으며 데이터는 한국도로공사 공공데이터 포털 의 교통데이터를 이용했다. 먼저 API에 접근하기 위해 인증키를 발급 받는다. 이후 실시간 영업소간 통행시간 페이지 에 접속해 아래의 예제 실행하기를 클릭. 원하는 Request Parameter를 입력하고(필자는 key(여기서 키는 방금 발급받은 인증키), type, iStartUnitCode, iEndUnitCode만 작성) URL보기를 하면 URL이 출력되고 , 아래의 예제 실행하기를 통해 직접 볼 수도 있다. 이제, 캐글에 다음과 같이 입력해준다. 12345678import requestskey = &quot;발급받은 인증키&quot;type = &quot;json&quot;url = &quot;출력된 URL&quot;responses = requests.get(url)print(responses)json = responses.json()json 을 입력해주면팝업에서 보았던 예제를 직접 볼 수 있다. 필요한 정보가 있는 “realUnitTrtmVO” 항목을 가져오기 위해 다음 코드 입력 1cars = json[&quot;realUnitTrtmVO&quot;] 이것을 반복문을 통해 리스트, 딕셔너리 형태로 만들어준다. 12345678910data = []for car in cars: dic_df = {} dic_df[&quot;date&quot;] = car[&quot;stdDate&quot;] dic_df[&quot;time&quot;] = car[&quot;stdTime&quot;] dic_df[&quot;destination&quot;] = car[&quot;endUnitNm&quot;] data.append(dic_df)data 아래는 아웃풋 12345678910[{'date': '20220103', 'destination': '수원신갈', 'time': '05:30'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:35'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:40'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:45'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:50'}, {'date': '20220103', 'destination': '수원신갈', 'time': '05:55'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06 '}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:00'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:05'}, {'date': '20220103', 'destination': '수원신갈', 'time': '06:10'}] 이렇게 딕셔너리로 구성된 리스트가 생성되었다.이것을 Pandas Dataframe으로 변환후 엑셀시트로 출력하려면 다음과 같이 하면 된다. 123import pandas as pddf = pd.DataFrame(data) # 판다스 데이터프레임으로 변환df.to_csv(&quot;temp.csv&quot;,index=False,encoding=&quot;euc-kr&quot;) 이렇게하면 설정된 곳으로 캐글에서 데이터프레임이 다운로드된다.","link":"/2022/01/03/crawling-basic-01/"},{"title":"Heroku로 HTML 페이지 배포하기","text":"캐글 대시보드 배포 프로젝트를 마치고 꽤나 지났을때, 학원에 다니기 한참 전에 HTML과 CSS 로만 만들었던 카카오톡 클론코딩 프로젝트가 생각나 그것도 배포하는 김에 쓰는 글. 사전준비 Heroku 계정 Heroku CLI Git 일단 Heroku에서 배포를 할 것이므로 Heroku 의 계정과 Heroku CLI 설치가 필요하다.Git 도 자신의 환경에 맞추어 설치해주자. 윈도우에서 Git 설치하기 node.js가 설치되어 있는 경우에는 npm 으로 간편히 설치가 가능하다고 한다. 1npm i -g heroku 설치가 잘 됐나 확인해보자 1heroku -v 버전이 출력되면 잘 설치가 된 것이다. 1heroku login 설치가 잘 완료되었으면 heroku login을 입력하자.그러면 브라우저 창이 하나 뜨고, heroku계정을 입력하면 준비 완료. HTML 파일을 Heroku로 배포하기 프로젝트를 로컬에서 완성했다고 바로 heroku로 배포하면 heroku가 어떤 언어로 개발한 프로젝트인지 모르기 때문에 다음과 같은 오류를 내며 구동되지 않는다.코린이 입장에서 프로젝트 만들었다고 싱글벙글하다가 에러나면 진짜 아찔하다.그래서 이런일이 없게 heroku에서 지원하는 언어들중 하나인 php 프로젝트로 인식되게 처리해 주어야 한다.프로젝트의 루트 디렉토리에 다음처럼 html 파일로 리다이렉트 시켜주는 php 파일만 하나 만들어주면 된다. index.php123&lt;? header('Location: /index.html');?&gt; 이제 파일은 모두 완료됐으니 CLI를 이용해서 heroku에 배포를 해보자.당연히 아래의 명령을 입력하는 위치는 프로젝트의 루트 디렉토리여야 한다. 12345678910# 저장소를 만들고 커밋 (github연결과는 무관)git initgit add .git commit -m &quot;first commit&quot;# 새로운 Heroku app 생성heroku create# Heroku에 push하기git push heroku master 이렇게 하면 배포는 마무리 됐다. 이외에도 같이 필요할것같은 몇가지 명령어를 적어보자면 파일 수정 후 재배포시1234git add .git commit -m &quot;커밋 메모&quot;git push heroku master Heroku app 이름 바꾸기heroku create로 app을 만들면 이름이 임의로 생성된다 그렇기때문에 이름을 바꾸고 싶다면 아래의 명령어를 사용하면 된다. 1heroku apps:rename &lt;새 이름&gt; --app &lt;기존 이름&gt; heroku app 열기heroku app 페이지에서 open app 버튼을 통해 여는 방법도 있으나 CLI를 통해 바로 열어보고 싶다면 다음 명령어를 사용하자. 1heroku open heroku git 과 git 저장소 연결 명령어본 포스팅에서는 폴더에서 app을 만들었기때문에 바로 연결되어 사용할 필요가 없었던 명령어이다.그러나 저장소의 주소가 필요하거나 변경할 경우를 위해 기록한다. 12git remote -v # 폴더와 연결된 저장소(heroku git, github 등)의 주소가 출력됨git remote set-url heroku &lt;변경할 git 경로&gt; # heroku저장소의 주소를 변경할 경우 사용, 변경할 git 경로의 예)https://git.heroku.com/&lt;app이름&gt;.git 오류발생시 로그 출력배포를 진행하다 보면 오류가 발생할 수 있다.그럴 경우 로그를 출력하여 에러코드를 확인하고 영어로 구글링하여 답을 찾도록 하자. 12heroku logsheroku logs --tail Reference. heroku에 일반 html 사이트 올리기 [Hosting] heroku.com 사용하기","link":"/2022/01/07/heroku-deploy-html/"},{"title":"PyCharm, PostgresSQL 연동","text":"이번 포스팅에서는 PyCharm에 DB를 연동하는 방법을 포스팅 한다. 포스팅에서 필자는 PostgreSQL을 사용한다. 포스팅의 대략적인 길이를 보면 알겠지만 매우 간단하다. 먼저 본인이 연결하고싶은 위치에 파이참을 실행시켜준다. 이후 좌측상단의 File &gt; Settings &gt; Plugins 으로 들어가면 위와 같은 화면이 열린다. 파이참에 여러가지 플러그인을 설치할 수 있는 창이다. 이후 data를 검색하고 Database Navigator를 INSTALL 해준다. (필자의 경우 미리 돼 있음) 그런 다음 View &gt; Tool Windows &gt; DB Browser를 실행시킨다. DB Browser가 보이지 않을경우 파이참을 종료후 다시 실행해보면 된다. Database Navigator를 해당 폴더에서 처음 실행했다면 DB Browser에 Nothing to show라는 문구가 뜰 것이다. 버튼을 누르고 자신이 사용할 DB를 선택해준다. 필자는 PostgreSQL를 설치했고 사용할 것이니깐 PostgreSQL를 클릭 PostgresSQL에서 따로 설정을 만지거나 하지않았다면 User = postgresPassword = DB생성시 자신이 입력한 비밀번호(또는 기본값 5432) 이외에 항목을 무언가 바꾸었다면 어떤 항목에 손대야 하는지는 독자 자신이 더 잘 알것이다. 우측 하단에 TEST CONNECTION을 누르고 위와 같은 화면이 뜬다면 Apply 후 OK 여기까지 잘 따라왔다면 이제 끝났다. DB Browser에서 DB가 잘 불러와진 것을 확인하면 된다. 만약 SQL파일을 갖고있다면 이젠 PyCharm에서 전체실행, 라인별로 실행도 가능하다.","link":"/2022/01/11/PyCharm-DB-Link/"},{"title":"PostgreSQL Data 불러오기, 내보내기","text":"DB를 사용하다보면 데이터를 불러와야할 일도, csv파일 등으로 내보내야 할 일도 있다. 처음 사용하는 사용자에겐 이 과정이 상당히 복잡하기 때문에 배운것을 기록 해 둘겸 남에게 쓰임새 있게 쓰이길 바라며 포스팅 시작. 사전 준비 DB 로그인이 가능한 pgAdmin(PostgreSQL 관리 프로그램) 사용 가능한 .csv, .dump 파일 Data import 좌상단의 File &gt; Preferences &gt; Paths &gt; Binary paths 에서 ※ EDB Advanced Server Binary Path가 아닌 PostgreSQL Binary Path 에 위 사진처럼 자신의 이하경로/PostgreSQL/버전/bin 을 입력해준다 잘 입력했다면 Set as default를 누르고 Save. 이젠 적용할 테이블에 우클릭을 한 후, Import/Export… 을 클릭해준다. Import/Export 는 Import로 Filename은 테이블에 적용하고 싶은 파일을 찾아주고 Header를 Yes로 Delimiter는 파일마다 다를수 있는데 필자의 경우 파일을 메모장으로 열어봤을때 구분이 쉼표로 되어있기때문에 ,로 골라주었다. OK로 적용해주고 테이블 리프레쉬~ 이후 Query Tool을 열어 테이블을 조회해주면 깔끔히 적용된 모습이 출력된다. Data exportPostgreSQL의 데이터 export 방법에는 두가지가 있다. 첫째는 pgAdmin 을 통해 위 사진에 있는 Save results to file 버튼을 클릭하여 csv로 다운로드 받는법. 이는 직관적이고 쉽지만 항상 pgAdmin을 통해 다운받을수는 없으니 다른 방법도 알아보려 한다. 둘째는 CMD 를 통해 csv를 다운받는 법이다. 그러기 위해서는 미리 원하는 형식의 sql파일을 만들어 놓아야 한다. 가령 cities 테이블 전체를 내보내려면 1SELECT * FROM cities; 가 작성된 sql 파일을 미리 만들어 놓아야 한다. 이번 포스팅에서는 이 파일 이름이 cities.sql이라 가정하고 포스팅을 작성한다. 이후 CMD에서 할 일은 다음과 같다. 먼저 파일이 있는 곳으로 이동해야 한다 1cd [cities.sql이 있는 경로] 이제 다음의 명령을 입력해 cities.sql의 출력값을 그대로 csv로 출력하면 된다 12345678910psql -U postgres -d postgres -f cities.sql -o cities.csv -F ',' -A -t-- 명령어의 뜻은 다음과 같다.-- -U = 데이터베이스 사용자 이름-- -d = 연결할 데이터 베이스 이름-- -f = 파일 내부의 지정한 명령을 실행후 끝냄-- -o = 쿼리 결과를 파일(또는 |파이프)로 보냄-- -F = unaligned 출력용 필드 구분자 설정(기본값: &quot;|&quot;)-- -A = 정렬되지 않은 표 형태의 출력 모드-- -t = 행만 인쇄 어후 복잡하다. 그래도 psql --help를 입력하면 모든 명령어가 출력되니 참고하며 쓰면 된다. 위의 명령어를 입력하면 DB의 암호 입력창이 나오는데 DB를 만들때 입력했던 암호를 입력하면 csv생성이 완료된다. dump파일 업로드dump파일이 있는 폴더로 이동하고 다음 명령 입력시 데이터 베이스에 테이블 각각 생성됨.psql -U postgres -d postgres -f function_example.dump유저네임, DB이름, 파일이름에따라 명령어를 알맞게 바꿔주어야 함.명령어에 대한 설명은 바로 위에 있고, psql --help를 해도 볼 수 있음.","link":"/2022/01/11/PostgreSQL-Data-import-export/"},{"title":"SQL리뷰 수업 코드정리-2","text":"2일차 코드 (서브쿼리 기본) 12345678910111213141516171819202122232425262728293031323334353637383940--실제 보유하고 있는 과일 데이터select * from real_amount; -- 테이블값 있음, 위 이미지 첫번째 테이블-- 카운터 컴퓨터에서 추정한 과일 데이터select * from assumption_amount; -- 테이블값 있음, 두번째 테이블-- 외상 데이터select * from exception; -- 테이블값 없음, 세번째-- 기본적으로 서브쿼리에서 true가 반환되어야 메인쿼리가 실행되는듯-- exists(서브쿼리) == 서브쿼리의 결과가 한건이라도 존재할 경우 True 없으면 False 리턴-- 카운터에는 데이터 존재 / 외상 데이터 현재 없음select * from real_amount -- 현재 과일 데이터 출력where exists ( -- 위의 exists 설명 참조 select * from assumption_amount -- 컴퓨터 추정 과일데이터);-- 결과 : 컴퓨터에서 추정한 과일 데이터가 존재하니 exists == true 반환, 그러므로 메인쿼리가 실행됨select * from real_amount -- 현재 과일 데이터 출력where exists ( -- 위의 exists 설명 참조 select * from exception -- 외상데이터);-- 결과 : 외상데이터 조회시 테이블값이 없기 때문에 exists == false 반환, 메인쿼리가 실행되지 않음-- SQL의 아웃풋 창에는 select * from exception이 출력-- IN 연산자 / NOT IN 연산자-- IN 연산자 : 하나이상의 값이 도출이 되면 trueselect * from real_amount -- 현재 과일 데이터 출력where amount in ( -- amount(메인쿼리의 테이블에서 값을 받아오는 것으로 추정)값에 10, 20, 30 이 있을경우 true 10, 20, 30);-- 결과 : real_amount 테이블의 amount 컬럼에 10과 30이 존재하기 때문에 메인쿼리가 실행되어 현재 과일데이터가 출력됨-- ANY 연산자select * from real_amount -- 현재 과일 데이터 출력 (3)where 10 = any ( -- 서브쿼리의 출력에 10이 있을 경우 (2) select amount from assumption_amount -- assumption_amount 테이블의 amount 컬럼을 출력 (1));-- 결과 : assumption_amount 테이블의 amount 컬럼에 10이 존재하기 때문에 real_amount 출력 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596select * from populations; -- 위 테이블 이미지-- 기본적인 집계함수-- avg(*) NULL 값이 아닌 모든 입력 값의 평균select avg(life_expectancy) from populations; -- 모든 life_expectancy의 평균값 출력-- count(*) 입력한 행의 총 갯수select count(*) from populations; -- populations 테이블의 모든 행 갯수 - 434-- count(컬럼명) NULL 값이 아닌 해당 컬럼 행의 갯수select count(life_expectancy) from populations; -- populations 테이블의 NULL이 있는 행을 제외한 life_expectancy 컬럼의 갯수 - 398-- max, min, sum -- 모두NULL 값이 아닌 해당 컬럼 행만 계산select max(life_expectancy) from populations; select min(life_expectancy) from populations;select sum(life_expectancy) from populations;-- 기대수명이 가장 높은 country codeselect country_code, life_expectancy -- country_code, life_expectancy 출력 (5)from populations -- populations 테이블의(4)where life_expectancy = ( -- (2)와 동일한 life_expectancy값을 가진 행의 (3) select min(life_expectancy) -- life_expectancy컬럼의 최솟값(2) from populations -- populations 테이블의 (1));-- 결과 : populations 테이블의 life_expectancy컬럼의 최소값과 동일한 life_expectancy를 가진 country_code, life_expectancy를 populations 테이블에서 찾아 출력-- 삼중쿼리-- 집계함수는 where절에서 사용 불가이기 때문에 서브쿼리 사용select country_code -- country_code 출력 (8)from populations -- populations테이블의 (7)where code = ( -- (5)에서 선택된 테이블의 행중에 code 컬럼과 같은값을 가진 행 (6) select * -- (4)에서 선택된 테이블의 모든 컬럼 조회 (5) from countries -- countries 테이블 (4) where life_expectancy = ( -- (2)와 동일한 life_expectancy값을 가진 행 (3) select min(life_expectancy) -- life_expectancy컬럼의 최솟값 (2) from populations -- populations 테이블의 (1)));-- 복잡하다... 설명을 못해서 그렇기도 하지만, 차라리 SQL로 보는게 낫지 한글로 풀어설명하는게 더 복잡하다.-- 조건 1. 2015년 전체 국가의 평균 수명 계산-- 조건 2. 모든 데이터를 조회합니다.-- 조건 3. 2015년 평균 기대수명의 1.15배보다 높도록 조건을 설정합니다.-- 이번엔 거꾸로 과정 작성select * -- 모든 컬럼 출력 (1)from populations -- populations 테이블의 (2)where life_expectancy &gt; 1.15 * ( -- 단, life_expectancy가 서브쿼리 값의 1.15배보다 큰것만 출력 (3) select avg(life_expectancy) -- life_expectancy의 평균값 출력(4) from populations -- populations 테이블의 (5) where year = 2015) -- year 컬럼이 2015인것들로만 평균값 출력(6) and year = 2015; -- (3)의 and조건 추가절, year가 2015 일것.-- 결론 : 2015년도의 평균life_expectancy * 1.15 보다 크고, year 가 2015인 행의 모든 컬럼 출력 -- 간단한 편.. select * from cities; -- nameselect * from countries; -- capital-- 메인쿼리-- citi 테이블에서, name, country_code, urban_pop-- urban_pop 내림차순 정렬-- 상위 5개만 출력-- 서브쿼리-- city 테이블에 name과 countries capital 매칭이 되는 애들만 조회select name, country_code, urbanarea_pop -- 각 컬럼 출력from cities -- cities 테이블에서 조회where name in (select capital from countries) -- name컬럼 내부에 서브쿼리의 값과 같은값이 있는 경우만order by urbanarea_pop desc -- urbanarea_pop 컬럼 내림차순으로 정렬limit 5; -- 상위 5개만-- 결과물을 동일하게-- 두개의 테이블을 JOINSELECT countries.name AS country, COUNT(*) AS cities_num FROM cities INNER JOIN countries ON countries.code = cities.country_code -- 테이블 교집합GROUP BY country -- country의 항목으로 묶어줌ORDER BY cities_num DESC, country -- cities_num 컬럼을 내림차순으로 정렬, country 컬럼 출력LIMIT 9; -- 상위 9개만-- 서브쿼리를 where --&gt; select 절로 옮긴 결과select countries.name as country , (select count(*) from cities where countries.code = cities.country_code) as cities_numfrom countriesorder by cities_num desc, countrylimit 9;-- 안보던 형식이라 그런지 더 복잡해 보인다.","link":"/2022/01/12/sqlreview-2/"},{"title":"SQL리뷰 수업 코드정리-1","text":"1일차 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104-- 전체 테이블 조회select * from subway;-- 테이블 생성create table develop_book( book_id integer , date date , name varchar(80));-- 등록된 테이블 리스트 조회-- CMD 창에서 \\dt 실행하면 동일한 리스트 확인 가능SELECT * FROM pg_catalog.pg_tablesWHERE schemaname != 'pg_catalog' AND schemaname != 'information_schema';-- 테이블 삭제drop table develop_book;-- 테이블 생성create table develop_book( book_id integer , date date , name varchar(80));-- 데이터 자료 추가하기insert into develop_book values(1, '2021-12-22', 'SQL 레시피');-- 큰 따옴표 입력insert into develop_book values(2, '2021-12-23', '&quot;자바의 정석&quot;');-- 작은 따옴표 입력insert into develop_book values(3, '2021-12-24', '''자바의 정석''');-- Let's go 입력insert into develop_book values(4, '2021-12-25', 'I''am book');-- 조회 하기select * from develop_book;-- 테이블에 자료 여러 개 추가하기insert into develop_book values(5, '2021-12-30', '책1'),(6, '2021-12-30', '책2'),(7, '2021-12-30', '책3'),(8, '2021-12-30', '책4');-- 조회 하기select * from develop_book;-- 컬럼 선택 조회select book_id, name from develop_book;-- Limit 명령어select * from develop_book limit 3;-- OFFSET 명령어 추가-- ~번째 인덱스부터 시작select * from develop_book limit 5 offset 2;-- ORDER BY-- 오름차순select * from develop_bookorder by name asc;select * from develop_bookorder by name desc;-- WHERE 조건문select * from develop_bookwhere book_id = 5;select * from develop_bookwhere book_id &lt;&gt; 5; -- 5 제외-- AS 명령어select name as 책제목 from develop_book;-- Coalesc 함수-- 데이터 조회 시, NULL 값을 다른 기본 값으로 치환-- ex) NULL --&gt; &quot;데이터 없음&quot;insert into student_score(name, score)values ('Hello', NULL), ('Hi', NULL);-- 조회select id , name , score , case when score &lt;= 100 and score &gt;= 90 then 'A' when score &lt;= 89 and score &gt;= 80 then 'B' when score &lt;= 79 and score &gt;= 70 then 'C' when coalesce (score,0) &lt;= 69 then 'F' endfrom student_score;-- 결측치 처리select students , coalesce((12/nullif(students, 0))::char, '나눌 수 없음') as column8from division_by_zero;","link":"/2022/01/11/sqlreview-1/"},{"title":"자바스크립트(Javascript) 기록-2","text":"prompt() 자바스크립트는 브라우저를 통해 사용자와 상호작용한다. 마우스의 위치가 어디인지, 어떤값을 받아오는지, 스크롤이 어디쯤인지에 따라 각각의 이벤트를 지정할 수 있다.그런데 당연하게도 그런 값을 받아오는건 브라우저나 자바스크립트가 별도의 코딩없이 척척해주지는 않는다. (적어도 내가 아는선에서는)그런 자바스크립트에는 값을 받아오는 명령어가 있는데 그것이 바로 prompt()이다. 1ex) prompt(&quot;What your name?&quot;) prompt()는 alert() 처럼 팝업창이 뜨는데 alert와 다르게 값을 입력받을수 있다.일단 입력은 모두 String타입으로 받아진다.하지만 커스텀이 자유롭지못해서 요즘엔 잘 쓰이지 않고 있다고 한다. typeof 파이썬에서의 type() 과 같은 역할을 한다.typeof a또는 typeof(a)처럼 객체나 변수의 타입을 출력해준다. parseInt() 변수 a 가 있고, a가 숫자로만 이루어진 문자열(string)일 경우 parseInt(a) 는 내용은 같으나 타입은 number인 a를 반환해준다.그러나 a 가 만약 문자로 이루어져있다면 대신 NaN(Not a Number)이 반환 된다. 조건문 (if만) 1234567if (a&lt;0) { console.log(&quot;a는 음수입니다.&quot;);} else if (a=0) { console.log(&quot;a는 0입니다.&quot;);} else { console.log(&quot;a는 양수입니다.);} 기본적으로 자바와 크게 다르지 않아 패스…. 비교연산자 다른부분만 빠르게 체크하겠다.자바스크립트에는 같다 라는 뜻의 ==와 같지 않다 라는 뜻의 !=가 있다.하지만 ===와 !== 도 존재하는데 이는 ‘엄격하게 같다’와 ‘엄격하게 같지 않다’이다.‘엄격하게’가 뜻하는 바는 비교하는 변수의 타입까지 고려한다는 뜻이다. 굳이 예를 들자면 다음과 같다 12345678const a = &quot;10&quot;;const b = 10;a == b # truea === b # falsea != b # falsea !== b # true 이처럼 ===와 !==는 변수의 타입까지 고려하며 비교를 하는 비교연산자이다.","link":"/2022/01/11/javascript-record-2/"},{"title":"자바스크립트(Javascript) 기록-1","text":"전에 만들어 놓았던 카카오톡 클론코딩을 배포 하던 중 HTML과 CSS만으로는 부족해보이므로 Javascript로 기능을 추가해 보라는 강사님의 피드백에 따라 JS로 기능을 추가하기 위해 JS가 주인 클론코딩 강의를 듣고 카카오톡 클론코딩에 잘 버무려 보기로 했다. 그런데 HTML의 스크립트태그는 몇번 접해본적 있었지만 JS는 초면인지라 다른 언어들의 기초보다 문법이 복잡한지, 어떤 부분이 다른지 전혀 모르고 있었기에 기록 겸 가끔 보려는 용도로 포스팅 한다. 하루 배우고 하루 기록하는 토막글 형식이기에 한두번 만에 끝날것 같지는 않으니, 귀찮아 하지말고 매일 기록할것. 변수 선언 방식 자바에 여러개의 변수 타입이 있듯이 자바스크립트에도 변수 타입이 존재한다. 그러나 다른점이라면 자바는 변수의 크기, 타입에 따라 분류한다면 자바스크립트는 이후에 값을 수정 가능한지 아닌지로 분류한다.일단 기본적인 변수 선언 방식은 다음과 같다. 123const a = 1;let b = 2;var c = 3; 기본적으로 변수 선언 방식 이후 변수에 값을 넣고 닫아주는 형태이다. 갑자기 잡설을 풀어보자면파이썬, 자바등을 공부할때 해당하는 언어를 설치해주어야 했는데 자바스크립트는 그렇지 않다.다른 언어의 경우에는 버전이 올라감에 따라 이전버전의 문법을 사용하지 못하는 경우가 있다.그러나 자바스크립트는 이전버전의 문법(const,let이 있음에도 var가 사용 가능한경우)이 여전히 혼용 가능하다.(그러나 쓰지않는걸 추천하는것 같다.) 각설하고, 총 세 개의 방식이 있는데 각각의 특징은 이렇다. constES6 이후에 추가되었고 가장 기본적으로 사용되는 변수형이다, 상수(변수인데 상수;;)이며 그렇기 때문에 선언 이후에 변경이 불가하다.(할당된개체가 Array와 Objects등의 개체라면 내부의 값을 변경할 수는 있다. ) 선언할때 반드시 값을 할당해주어야 한다. letES6 이후에 추가되었고 현재 사용되고 있는 가변 변수형이다, 선언 이후에도 변경이 가능하다. 선언할때 값을 할당하지 않을수 있지만 그럴경우 값은 undefined가 된다. var자바스크립트 초기에 사용되었던 변수형이며, 선언 이후에도 변경이 가능하다. 역시나 선언할때 값을 할당하지 않을수 있고, 이 경우 값은 undefined가 된다. 왜 let은 쓰는데 var는 쓰지 않는지, 왜 기본적으로 let이 아닌 const를 쓰는지 의문이 생길수 있다.전자의 의문의 답은 세가지이다. 첫째는 변수명이 같아도 선언이 가능하다는것. (재선언 가능)누군가는 장점이 아니냐 할 수 있겠지만 변수의 양이 매우 많거나, 다른사람과 협업을 한다면 이는 단점이 된다. 둘째는 호이스팅(Hoisting).이는 변수의 정의가 선언과 할당으로 분리되는것을 말한다, 이게 무슨뜻인지는 다음 코드를 보자 12console.log(name);var name = &quot;WJ&quot;; 이렇게 코드가 있을때 자바스크립트는 다음과 같이 해석한다. 123var name;console.log(name);name = &quot;WJ&quot;; 결국 출력은 초기화가 되지않았다는 메시지가 나오는 대신 정의되지 않았다는 뜻인 undefined 가 나오게 된다.이는 직관적이지 못하기때문에 var보다 let을 쓰는것이 권장된다. 셋째는 const,let은 ‘블럭’수준 var는 ‘함수’수준으로 적용되기 때문이다.이게 무슨말인지 처음엔 이해가 잘 되지 않을수 있다. (나는 그랬음..)그러니 바로 예시를 보면 123456789var a = 5; # 전역변수 a 선언후 5 할당console.log(a); # 5 출력function setA() { var a = 10; # '함수 내부'에서 지역변수 a 선언후 10 할당 console.log(a); # 10 출력}console.log(a); # 5 출력 전혀 이상할것 없이 당연한 예시이다. 그럼 다음예시도 한번 보자 123456789var a = 5; # 전역변수 a 선언후 5 할당console.log(a); # 5 출력if (true) { var a = 10; # 'if블럭 내부'에서 지역변수 a 선언후 10 할당 console.log(a); # 10 출력}console.log(a); # 10 출력 &lt;-- ??? if블럭 내부에서 지역변수를 할당 했음에도 전역변수로 선언했던 a의 값이 바뀌어 10이 되었다. 이는 위에서 말했듯 var의 범위는 ‘함수’수준으로 적용되기 때문이다.즉, 블럭{}으로 감싸더라도 함수로 감싸진것이 아니기때문에 if블럭 내에서 재할당된 값이 출력된 것이다. 쓰면 안되는 이유 1,3번의 콜라보.. 결국 요약하자면 var는 함수내부에서 쓰는것이 아니라면 전역변수와 같다는 것이다. 안쓰는데는 이유가있다 Array (배열, 리스트)파이썬으로 처음 접했던 리스트 역시 자바스크립트에도 있다.다음은 array를 선언하는 기본적인 방법이다. 1const a = [1, 2, null, true, &quot;hello&quot;]; 인덱싱은 a[2]; 처럼 가능하고, 값을 추가하고 싶을 경우 a.push(추가할 값) 해주면 해당 값이 가장 마지막의 인덱스에 추가된다. Objects (파이썬 딕셔너리)제목에도 적었듯이 키와 값으로 이루어진 것이 파이썬의 딕셔너리와 닮았다. 세세한기능까지 같은지는 모른다오브젝트를 선언하는 기본적인 방법을 보면 123456const a = { name : &quot;WJ&quot;, contry : &quot;KR&quot;, lang : &quot;Javascript&quot;, num : 123} 처럼 선언하는데 중괄호 내부의 프로퍼티 중 왼쪽을 이름, 오른쪽을 값이라 한다. 값 출력시엔 다음처럼 하면 된다. 12a.name;a[&quot;name&quot;]; 예시에서 배열과 오브젝트 둘다 const로 선언했지만 내부의 값은 바꿀 수 있다. function (함수)123function a() { console.log(&quot;Hello!&quot;);} 문법만 조금 다를 뿐 전체적으로 파이썬의 사용자 지정 함수나 자바의 메소드와 비슷하다. 함수호출은 a() 로 할수 있으며 결과는 Hello! 가 출력되게 된다. Reference.ES6의 변수 선언, const와 let - nana_log","link":"/2022/01/10/javascript-record-1/"},{"title":"자바스크립트(Javascript) 기록-3","text":"document 자바스크립트는 기본적으로 HTML의 모든 항목을 읽고 변경이 가능하다. HTML 파일의 모든것이 document 객체로 담겨있는데 자바스크립트는 document 객체를 object 타입으로 가져와 내부의 값을 변경 할 수 있다. 사용 예시는 다음과 같다. 1document.title = &quot;hello&quot;; 이렇게 한다면 HTML의 title태그에 내용이 있더라도 페이지의 제목이 hello로 바뀌게 된다. document 내부에는 title, head, body 등 여러가지 태그가 object 타입으로 담겨있다. getElementById getElementById는 HTML의 특정 개체를 가져오는 기능이다. 사용예시를 먼저 보자. 1&lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; 이런 HTML태그가 있다고 할 때 1document.getElementById(&quot;title&quot;); 이라면 HTML에서 태그의 id값(태그값 자체가 아니다! &lt;title&gt;태그와 혼동하지 말자)이 title인 태그를 가져온다. 12const h1Tag = document.getElementById(&quot;title&quot;);h1Tag.innerText = &quot;hi&quot;; 이처럼 변수에 저장해 객체처럼 사용 할 수도 있다. console.dir console.log가 console에 로그를 찍어주는 역할이라면 console.dir은 이를 통해 가져온 태그 내부의 모든 정보를 object 타입으로 가져온다. 1console.dir(document); 이렇게 하면 document의 모든 정보가 object 타입으로 콘솔에 출력된다. 출력된 정보를 보고 수정, 추가, 삭제, 이벤트 등 여러방면으로 활용이 가능하다. querySelector querySelector 역시 태그를 가져올수 있는태그이다. 먼저 사용 예제를 보자 123&lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello!&lt;/h1&gt;&lt;/div&gt; 123const h1 = document.querySelector(&quot;.hello h1&quot;);console.log(h1) 각각의 HTML, JS코드가 있고 JS의 querySelector 를 통해 div태그 내부의 h1태그를 가져온 후 콘솔에 출력한 코드이다. 만약 위 코드에 상응하는 값이 여러개라면 어떻게 되는지 한번 보자. 123456789&lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello 1!&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello 2!&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello 3!&lt;/h1&gt;&lt;/div&gt; 123const h1 = document.querySelector(&quot;.hello h1&quot;);console.log(h1) 결과는 한개만 나오며 제일 앞의 것이 출력되는것으로 나왔다. 모두 출력하고 싶을경우 querySelectorAll을 사용하면 된다. querySelectorAll을 사용하면 결과는 리스트로 반환된다. 코드에서 살짝 알수 있었듯이 querySelector는 CSS선택자를 지원한다. (예시에서의 .hello) 그래서 title을 쓸때 #title을 쓸때 .title을 쓸때 모두 다르며 각각 태그, ID, 클래스를 의미한다. addEventListener addEventListener는 이벤트를 감지하는 역할을 한다. 여기서 이벤트란 마우스를 움직이거나 키를 입력하거나 브라우저 창 크기를 조정하거나 텍스트를 복사하거나 와이파이연결을 해제하는등 PC의 대부분의 IO에 관한 모든것을 말한다. 다음은 사용예시이다. 12// 객체가 h1태그, 이름은 name, 함수이름은 func 라 가정name.addEventListener(&quot;click&quot;, func); 위 코드가 뜻하는 바는 ‘name의 h1 태그를 클릭할 경우 func 함수를 실행한다.’ 이다. 코드에서 주의할 점이 있는데 func()가 아닌 그냥 func인 것이다. func()를 하게되면 클릭이라는 조건이 갖춰지지 않아도 페이지 로딩중에 함수가 실행된다. 그렇기 때문에 함수는 괄호를 제외한 함수 이름만 입력해 주어야 한다. 여기서 click같은 조건을 더 많이 알고싶다면 구글링으로 (태그명) HTML event MDN 등을 검색하거나, console.dir(객체)를 통해 콘솔에서 더 찾아볼 수 있다. 객체의 내부 구성요소중 앞에 on이 붙은것들이 모두 이벤트라보면 된다. 이벤트 종류는 매우 많으니 다 외울수도 없을뿐더러 외울 필요도 없다. 파생형으로 name.onclick = func;이렇게 사용할 수도 있다. 그러나 addEventListener를 통해 이벤트를 감지한다면 이후 removeEventListener를 통해 event listener를 제거할 수도 있다. 필자는 addEventListener를 주로 사용할듯.","link":"/2022/01/12/javascript-record-3/"},{"title":"SQL리뷰 수업 코드정리-3","text":"3일차 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 서브쿼리 쓰는 방식-- where 절 서브쿼리-- select 절 서브쿼리-- from 절 서브쿼리select * from languages;select * from countries;-- 질문 : 각 나라별 언어의 갯수 구하기-- Table: languagesselect code, count(*) as lang_num -- 국가 코드, 모든행을 카운트해 lang_num 으로 출력from languages -- 사용한 테이블group by code; -- 국가 코드로 묶을것-- 결과 : 각각의 국가 코드로 묶인 lang_num 출력-- 질문, country로 변경하고, 언어의 갯수 구하기-- lang_num을 내림차순으로 정렬함.-- 이 쿼리서 from절 서브쿼리 사용select local_name, subquery.lang_num -- countries 테이블의 local_name, (as)subquery 에서 lang_num을 각각 출력from countries -- 테이블은 countries 와 다음의 서브쿼리 , (select code, count(*) as lang_num -- 전 질문의 쿼리를 가져와 'subquery' 명칭을 붙임 from languages group by code) as subquerywhere countries.code = subquery.code -- countries.code 와 subquery.code가 매칭이 될 경우만 조회order by lang_num desc; -- lang_num을 내림차순으로 정렬-- 결과 : countries.local_name과 subquery.lang_num이 각각 lang_num의 내림차순으로 출력--select * from economieswhere year = 2015;-- 코드별 inflation_rate-- 각 대륙별, 각 나라별 inflation_rate-- 각 대륙에서 inflation_rate가 가장 높은, inflation_rate를 출력SELECT name, continent, inflation_rate -- name, continet, inflation_rate 를 조회 FROM countries -- countries 테이블 INNER JOIN economies -- inner join = 기준테이블, 조인테이블 모두에 해당 값이 존재할 경우 메인쿼리 조회 on countries.code = economies.code -- economies 와 countries.code = economies.code 에 겹치는 값이 있는지 WHERE year = 2015 -- year항목이 2015이고 and inflation_rate in ( -- inflation_rate 항목에 다음 서브쿼리의 값이 있는지 SELECT MAX(inflation_rate) AS max_inf -- 가장 큰 inflation_rate를 조회 FROM ( -- 다음의 서브쿼리에서 SELECT name, continent, inflation_rate -- name, continent, inflation_rate 조회 FROM countries -- countries 테이블 INNER JOIN economies -- economies 와 on countries.code = economies.code -- countries.code = economies.code 에 겹치는 값이 있는지 WHERE year = 2015) AS subquery -- year = 2015인 것만 조회 ) subquery로 명명 GROUP BY continent); -- 바로 위에서 출력한 서브쿼리를 continent로 묶음-- 결과 : countries테이블의 name, continent, inflation_rate 조회 group by 때문에 대륙별로 한 나라씩만 조회되었고 조회된 나라의 기준은 inflation_rate가 가장 높은 국가 첫번째와 두번째 쿼리는 직접 작성하지는 못해도 해석은 할 수 있었는데 마지막 쿼리는 정말이지 복잡했다.강의 뿐만 아니라 책도 구매해서 SQL를 더 파야 할 듯.","link":"/2022/01/13/sqlreview-3/"},{"title":"자바스크립트(Javascript) 기록-4","text":"태그 다루기 중간제목에서 말하는 태그를 다룬다는 것은 태그의 내부 속성을 수정한다는 것이다. 강의에서 나왔던 대로 h1태그를 사용하여 적어보면 1h1.className = &quot;&quot;; 가장먼저 클래스를 바꿀수 있는 속성인 .className이다. “” 내부에 입력한 클래스로 바뀌게 되는데 문제는 원래 있던 클래스가 사라지고 입력한 클래스만 새로 추가되는 것이다. 1h1.classList.(Element) 그래서 .classList를 불러와 클래스를 추가하는 방법이 있는데 추가는 h1.classList.add로 클래스를 추가 할 수 있으며, 삭제는 h1.classList.remove로 삭제가 가능하다. 여기에 if문을 추가해준다면 특정 이벤트(클릭 등)에 따라 클래스의 추가와 삭제가 반복되게 만들수도 있다. 그런데 이렇게 반복을 하게 할때는 add와 remove를 쓰면 코드가 길어지게 되는데 이럴때를 위해 있는게 toggle 속성이다. 12345if (h1.classList.contains(&quot;clicked&quot;)) { // .contains()는 괄호 내부의 클래스가 존재하는지 확인 h1.classList.remove(&quot;clicked&quot;);} else { h1.classList.add(&quot;clicked&quot;);} add 와 remove 를 쓰면 다섯줄이였던 코드가 1h1.classList.toggle(&quot;clicked&quot;); toggle을 사용하면 이정도로 줄어들게 된다. 설명에 생략이 매우 많지만 사용법은 대략 이렇다. 이외에도 태그별로 많은 속성이 있으며, MDN Web Docs 에서 찾아볼 수 있다. .preventDefault .preventDefault는 이벤트가 발생했을때 그 이벤트의 기본동작을 막는다. 예를들어 ‘submit’ 이벤트가 발생했을때 브라우저는 기본적으로 페이지를 새로고침한다. 이런것들이 기본동작인데 이를 막아주는것이 .preventDefault 이다. 사용 예는 다음과 같다. 1234function func(event) { event.preventDefault(); console.log(event);} 이렇게 이벤트의 동작을 막고 콘솔에서 이벤트의 로그를 볼 수 있다. 새로고침을 막는등의 기능 이외에도 클릭시 링크로의 이동을 막거나, form의 제출을 막는등 여러가지를 할 수 있다. 백틱(``)으로 문자열 작성 문자열과 변수를 합쳐서 출력하려면 언어를 처음 배우기 시작한 사람들은 보통 다음과 같이 출력할 것이다 12const a = &quot;world&quot;;console.log(&quot;hello &quot; + a;); 그런데 파이썬의 포맷함수처럼 사용할수 있는 기능이 JS에도 있다. 사용법은 다음과 같다. 12const a = &quot;world&quot;;console.log(`hello ${a}`); 띄어쓰기를 따로 생각하지 않아도 되고 + 부호가 지저분해보였기 때문에 이 방법이 필자에게는 더욱 깔끔해 보였다.","link":"/2022/01/13/javascript-record-4/"},{"title":"SQL리뷰 수업 코드정리-4","text":"4일차 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140select * from summer_medals;-- row_number()-- 각 행에 숫자를 1, 2, 3, ..., N 형태로 추가한다.-- 오름차순으로 기준을 진행한다.-- 기본적 row_num만 추가select row_number() over() as row_num , *from summer_medals;-- 올림픽 연도를 오름차순 순번대로 작성을 한다.-- 연도 중복값 제거-- 서브쿼리 : select distinct year from summer_medals order by year asc;select row_number() over() as row_num -- 각 행에 오름차순으로 숫자 추가 as row_num, year행 출력 , yearfrom (select distinct year from summer_medals order by year asc) as years -- 중복값을 제거한 year 컬럼을 오름차순으로 출력 as yearsorder by year asc; -- select절의 컬럼들을 year컬럼의 오름차순으로 정렬select * from summer_medals;-- 운동선수 메달 갯수 쿼리 작성with athlete_medals as ( select athlete -- athlete, 전체 컬럼을 count하고 athlete로 묶음(group by절) as medal_counts , count(*) medal_counts from summer_medals group by athlete)select athlete -- athlete, medal_counts, medal_counts의 내림차순으로 숫자를 붙인 row_num 출력 , medal_counts , row_number() over(order by medal_counts desc) as row_numfrom athlete_medalsorder by medal_counts desc -- select절의 컬럼들을 medal_counts의 내림차순으로 정렬limit 10; -- 상위 10개만 출력-- 남자 69 KG 역도 경기에서 금메달 리스트 추출.-- Discipline = 'Weightlifting'-- Event 69KG,-- Gender-- Medalselect * from summer_medals;select distinct event, discipline, athlete, gender from summer_medals where event = '200M' and gender = 'Women' and medal = 'gold';select year -- 연도, 국가 as champion 출력 , country as championfrom summer_medalswhere discipline = 'Weightlifting' and -- 종목 = 역도, event = '69KG' and -- 세부종목 = 69KG, gender = 'Men' and -- 성별 = 남자, medal = 'Gold'; -- 금메달만, 상기 4개 조건 모두 만족하는결과만 출력-- LAGwith weightligting_69_men_gold as ( select year , country as champion from summer_medals where discipline = 'Weightlifting' and event = '69KG' and gender = 'Men' and medal = 'Gold')select year , champion , LAG(champion) over(order by year asc) as last_championfrom weightligting_69_men_goldorder by year asc;-- Athletics, 200미터, 여자, 금메달 목록 가져오기-- 나라 대신 선수이름 출력 year, 현재 챔피언 이름, 이전 챔피언 이름with Athletics_200_Women_Gold as ( select year , athlete as champion from summer_medals where discipline = 'Athletics' and event = '200M' and gender = 'Women' and medal = 'Gold')select year , champion , lag(champion) over(order by year asc) as last_championfrom Athletics_200_Women_Goldorder by year asc;-- partition by 함수-- partition by 미적용WITH Discus_Gold_Medal AS ( SELECT Year, Event, Country AS Champion FROM summer_medals WHERE Year IN (2004, 2008, 2012) AND Gender = 'Men' AND Medal = 'Gold' AND Event IN ('Discus Throw', 'Triple Jump') AND Gender = 'Men') SELECT YEAR, Event, Champion, LAG(Champion) OVER (ORDER BY Event ASC, Year ASC) AS Last_ChampionFROM Discus_Gold_Medal ORDER BY Event ASC, Year ASC;-- partition by 적용WITH Discus_Gold_Medal AS ( SELECT Year, Event, Country AS Champion FROM summer_medals WHERE Year IN (2004, 2008, 2012) AND Gender = 'Men' AND Medal = 'Gold' AND Event IN ('Discus Throw', 'Triple Jump') AND Gender = 'Men') SELECT YEAR, Event, Champion, LAG(Champion) OVER (PARTITION BY Event ORDER BY Event ASC, Year ASC) AS Last_ChampionFROM Discus_Gold_Medal ORDER BY Event ASC, Year ASC;","link":"/2022/01/17/sqlreview-4/"},{"title":"SQL리뷰 수업 코드정리-5","text":"5일차 코드 Discus_Gold_Medal123456789101112131415161718192021222324-- 성별, 연도 (2004, 2008, 2012), 현재 국가 (as Champion), 이전 국가-- 조건 : Event명 'Javelin Throw', Medal = GoldWITH Discus_Gold_Medal AS ( -- 아래 서브쿼리의 이름 SELECT gender -- 성별, 연도, 종목, 국가(as 챔피언) , year , event , country AS champion FROM summer_medals -- 조회 테이블 WHERE Year IN (2000, 2004, 2008, 2012) -- year컬럼이 2000, 2004, 2008, 2012 중에 하나이며 AND Medal = 'Gold' -- medal컬럼이 Gold이며 AND Event = ('Javelin Throw')) -- event컬럼이 Javelin Throw 인것 SELECT gender -- 성별, 연도, 종목, 현재 1위국가, , year , event , champion, LAG(Champion) OVER -- LAG(컬럼, 숫자(기본값1)) = 괄호안의 컬럼의 이전값(숫자만큼)을 건너뛰고 가져와 컬럼을 새로 만듦, (PARTITION BY gender ORDER BY Event ASC, Year ASC) AS -- 파티션을 gender로 분류, event와 year의 오름차순 정렬 Last_Champion -- as Last_ChampionFROM Discus_Gold_Medal -- 위에서 생성한 Discus_Gold_Medal 테이블에서 조회 ORDER BY gender asc, year ASC; -- gender, year의 오름차순 정렬 서브쿼리가 정렬되어 출력되고, last_champion이 바로 전 대회의 우승국을 출력하는것을 볼 수 있다. Athletics_Gold123456789101112131415161718192021222324-- 경기종목을 2개로 추가 ('100M', '10000M')WITH Athletics_Gold AS ( -- 이하 서브쿼리의 이름 SELECT gender -- 성별, 연도, 종목, 국가(as champion) 조회 , year , event , country AS champion FROM summer_medals -- 조회 테이블 WHERE Year IN (2000, 2004, 2008, 2012) -- year컬럼이 2000, 2004, 2008, 2012 중에 하나이며 AND Medal = 'Gold' -- medal컬럼은 Gold AND Event IN ('100M', '10000M')) -- 100M 또는 10000M 종목인것 SELECT gender -- 성별, 연도, 종목, 현재 1위국가 , year , event , champion, LAG(Champion) OVER (PARTITION BY gender, event ORDER BY Year ASC) AS -- 파티션을 gender와 event로 분류하고 year의 오름차순으로 정렬 Last_Champion -- as Last_ChampionFROM Athletics_Gold -- 위 쿼리에서 생성한 Athletics_Gold 테이블에서 조회 ORDER BY gender asc, event ASC, year ASC; -- gender, event, year의 순서대로 오름차순 정렬 DiscusThrow_Gold123456789101112131415161718192021-- year, athlete, future_champion(3회 이후 챔피언)-- 조건 : Medal =Gold / event = discus Throw / gender women / year &gt;= 1992-- lead(컬럼명, 3) over()WITH DiscusThrow_Gold AS ( -- 이하 서브쿼리의 이름 select year -- 연도, 선수 조회 , athlete from summer_medals -- 조회 테이블 where medal = 'Gold' -- 조건들 : medal컬럼이 Gold이며, and event = 'Discus Throw' -- event컬럼이 Discus Throw, and gender = 'Women' -- gender컬럼이 Women, and year &gt;= 1992 -- year컬럼이 1992 년 이후인것)select year -- 연도, 선수, future_champion , athlete , lead(athlete, 3) over -- lead(컬럼, 숫자(기본값1)) = 괄호안의 컬럼의 이후값(숫자만큼)을 건너뛰고 가져와 컬럼을 새로 만듦 () as future_champion -- as future_championfrom DiscusThrow_Gold; -- DiscusThrow_Gold 테이블에서 조회 이전까지 쿼리에서 사용된 LAG함수와 LEAD함수는 다음 절에서 설명한다. LAG() 함수와 LEAD() 함수 LAG() 함수 LAG함수는 보통 LAG(column, n(기본값1))의 형태인데 이는 현재 행 앞의 행에 있는 열의 값을 반환한다. 그렇기 때문에 위 사진에서 last_champion의 첫번째 결과는 null이 된다(앞의 결과가 없기때문) 이후 부터는 champion컬럼의 결과가 차례로 출력된다. 참고로 5번 열에서의 null은 gender를 partition by로 나누었고 현재 행의 앞의 열을 분리시킨상태이기 때문에 null값이 조회된다. LEAD() 함수 기본적인형태는 LEAD(column, n(기본값1))의 형태이며, LEAD 함수는 LAG 함수와는 반대로 현재 행 뒤의 행에 있는 열의 값을 반환한다. 사진에서 사용한 코드는 LEAD(athlete,3) 이므로 3칸 뒤의 열의 값을 반환한다. 이후 athlete컬럼의 결과가 차례로 출력되며 3번열 이후의 값은 존재하지 않기때문에 null이 반환된다.","link":"/2022/01/18/sqlreview-5/"},{"title":"(JAVA) 오버로딩, 오버라이딩 차이점","text":"자바를 공부하다가 오버로딩(Overloading)과 오버라이딩(Overriding)이란 용어가 나와 헷갈릴수 있겠다 싶어 차이점을 찾아보고 포스팅 하려 한다. 오버로딩(Overloading) 오버로딩이란같은 이름을 갖고있지만, 매개변수가 서로 다른 형식인 생성자, 메소드를 새로 정의하는 것. 오버로딩의 조건 메소드의 이름이 같아야 한다. 각 메소드 매개변수의 개수, 타입이 달라야 한다. 오버로딩의 예제&lt;코드&gt; 12345678910111213141516171819202122232425262728public class example { //메서드 오버로딩 public void method1() { System.out.println(&quot;매개변수가 없는 매서드&quot;); } void method1(String var) { System.out.println(&quot;매개변수 문자열 &quot; + var); } void method1(int value) { System.out.println(&quot;매개변수 정수타입 &quot; + value); }}class exampleRun { public static void main(String[] args) { example ex = new example(); ex.method1(); ex.method1(&quot;안녕하세요&quot;); ex.method1(12345); }} &lt;출력&gt; 123매개변수가 없는 매서드매개변수 문자열 안녕하세요매개변수 정수타입 12345 위 코드에서는 메소드만 오버로딩하였지만 생성자도 오버로딩하여 사용이 가능하다. 코드에서 확인할수 있는 것이 접근제한자가 달라도 오버로딩이 된다는 것이다. 오버로딩의 장점을 살펴보면 다음과 같다. 다형성 구현 소스코드 가독성 증가 메소드 이름 절약 오버라이딩(Overriding) 오버라이딩이란상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식클래스에서 같은 이름을 가진 메소드로 다시 정의하는 것. 오버라이딩의 조건 메소드의 선언부가 기존메소드와 같을것 접근제한자를 부모클래스의 메소드보다 더 좁은범위로 변경 불가 부모클래스의 메소드보다 더 큰 범위의 예외 선언 불가 오버로딩의 예제&lt;코드&gt; 1234567891011121314151617181920212223class parent { void method1() { System.out.println(&quot;이것은 부모클래스의 메소드입니다.&quot;); }}class child extends parent { @Override void method1() { System.out.println(&quot;이것은 자식클래스의 메소드입니다.&quot;); }}class childExample { public static void main(String[] args) { parent pa = new parent(); pa.method1(); child ch = new child(); ch.method1(); parent fa = new child(); // 자동 타입변환 fa.method1(); }} &lt;결과&gt; 123이것은 부모클래스의 메소드입니다.이것은 자식클래스의 메소드입니다.이것은 자식클래스의 메소드입니다. @Override 는 무엇인가?@Override 는 어노테이션(Annotation)이라는 기능으로 오버라이딩된 메소드의 위에 추가해주면 정상적으로 오버라이딩 되었는지 검증해주는 역할을 한다. 오버로딩, 오버라이딩의 차이점 정리 오버로딩은 새로운 메소드를 추가하는 것이고, 오버라이딩은 상속받은 메소드를 다시 정의하는 것이다. 이를 표로 나타내면 다음과 같다. 오버로딩(Overloading) 오버라이딩(Overriding) 매개변수 달라야 한다. 같아야 한다. 메소드명 같아야 한다. 달라야 한다. 리턴형 달라도 된다. 같아야 한다. 접근제한자 모든 접근제한자 사용 가능 부모클래스의 접근제한자보다 더 넓거나 같은범위의 접근제한자만 가능 적용 범위 동일 클래스 내에서 적용된다. 상속관계에서 적용된다.","link":"/2022/01/31/Java-overloading-overriding/"},{"title":"(JAVA) 맵 (Map) 자료형","text":"스프링 강의를 듣던중 Map이라는 자료형에 대해 처음으로 접했었는데 어떻게 사용하는지, 문법이 무엇을 의미하는지 전혀 몰랐기 때문에 구글링으로 좀 알아볼 필요성이 생겼다. key value music 음악 water 물 기본적으로 위의 표처럼 파이썬의 딕셔너리, 자바스크립트의 오브젝트같이 key값과 value의 대응관계로 구분된 자료형이다. Map은 리스트나 배열처럼 인덱스를 통해 해당 요소의 값을 구하는 것이 아닌 key를 통해 value의 값을 얻는다. HashMap Map은 인터페이스이며(필자는 포스팅하며 처음 알게되었다.) Map인터페이스를 구현한 Map자료형에는 HashMap, LinkedHashMap, TreeMap 등이 있다. 이번 챕터에서는 이들중 가장 간단한HashMap에 대해 알아본다. put제네릭 &lt;&gt; 에서 선언한 타입으로 항목값을 입력할때 사용한다. 123456789import java.util.HashMap;public class MapExample { public static void main(String[] args) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;music&quot;, &quot;음악&quot;); map.put(&quot;water&quot;, &quot;물&quot;); }} Map이 그렇듯 HashMap 역시 제네릭을 사용한다. getkey 값을 통해 value값을 얻을때 사용한다. 12System.out.println(map.get(&quot;music&quot;)); // 음악 출력System.out.println(map.get(&quot;water&quot;)); // 물 출력 위처럼 get 메소드를 통해 key 값을 입력하면 대응하는 value값을 얻을 수 있다. getOrDefault맵의 key에 해당하는 value가 없을때 get메서드를 사용하면 null 값이 리턴된다. 이 경우 null 대신 다른 디폴트 값을 얻고 싶다면 getOrDefault 메서드를 사용하면 된다. 1System.out.println(map.getOrDefault(&quot;nation&quot;, &quot;Korea&quot;)); // nation이 없기 때문에 'Korea' 리턴 containsKeycontainsKey 메소드는 Map에 해당 key가 있는지 확인후 그 결과값을 리턴한다. 12System.out.println(map.containsKey(&quot;music&quot;)); // key값이 있으므로 trueSystem.out.println(map.containsKey(&quot;nation&quot;)); // key값이 없으므로 false removeremove 메소드는 Map의 항목을 삭제하는 메소드로 key값에 해당되는 항목(key, value)를 삭제한 후 그 value 값을 리턴한다. 1System.out.println(map.remove(&quot;music&quot;)); // 음악 출력 map 객체에 있던 “music”와 “음악”항목이 사라지고 “음악”이 리턴 될 것이다. sizesize 메소드는 Map 항목의 갯수를 리턴한다. 1System.out.println(map.size()); // 1 출력 “music”, “water” 두개의 항목이 있었으나, remove 로 “music”을 삭제했으니 1이 출력 될 것이다. keySetkeySet은 Map의 모든 key를 모아서 리턴한다. 1234567891011import java.util.HashMap;public class MapExample { public static void main(String[] args) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;music&quot;, &quot;음악&quot;); map.put(&quot;water&quot;, &quot;물&quot;); System.out.println(map.keySet()); // [music, water] 출력 }} 이때 리턴되는 자료형은 Set 자료형이며, list 자료형과는 다르지만 변환하여 사용이 가능하다. Reference.점프 투 자바 3-8 맵(Map) - 박응용","link":"/2022/02/04/Java-Map/"},{"title":"(JAVA) 집합 (Set) 자료형","text":"Map자료형에 대해 포스팅하던중 keySet() 메소드의 리턴값이 Set 자료형인걸 알게되었지만 난 그게 무슨 자료형인지 몰랐다. 자바에 자료형이 많은건지 기초공부를 제대로 안한건지 내가 모르는 자료형에는 Map과 Set외에도 Enum 등의 자료형이 있었다. 그래서 일단은 강의를 보면서 중간에 이해를 못하는일을 줄이기 위해 기본적인 자료형들의 사용법을 간단히 포스팅 하려 한다. 집합 자료형의 생성 집합 자료형은 아래 코드처럼 HashSet을 사용하여 만들 수 있다. 123456789import java.util.Arrays;import java.util.HashSet;public class SetExample { public static void main(String[] args) { HashSet&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;)); System.out.println(set); // [e, H, l, o] 출력 }} Set 자료형 역시 Map 자료형 처럼 인터페이스이며, Set 인터페이스를 구현한 자료형에는 HashSet, TreeSet, LinkedHashSet 등이 있다. 집합 자료형의 특징 분명 H,e,l,l,o 가 들어있는 배열로 HashSet 자료형을 만들었으나 출력을 보면 l 한개가 빠져있고 순서도 뒤바뀌어 있다. 그 이유는 집합자료형에는 다음과 같은 특징이 있기 때문이다. 중복을 허용하지 않음 순서가 없음 리스트나 배열은 순서가 있으므로 인덱싱을 통해 자료형의 값을 얻을수 있지만 Map과 Set 자료형은 순서가 없기때문에 인덱싱으로 값을 얻을 수 없다. 교집합, 합집합, 차집합 구하기 교집합, 합집합, 차집합을 구하기 위해 일단 중복되는 숫자가 있는 각각의 배열로 Set 자료형을 2개 만든다. 123456789import java.util.Arrays;import java.util.HashSet;public class SetExample { public static void main(String[] args) { HashSet&lt;Integer&gt; set1 = new HashSet&lt;&gt;(Arrays.asList(1,2,3,4)); HashSet&lt;Integer&gt; set2 = new HashSet&lt;&gt;(Arrays.asList(3,4,5,6)); }} 교집합123HashSet&lt;Integer&gt; inter = new HashSet&lt;&gt;(set1); // set1 으로 inter 생성inter.retainAll(set2); // 교집합 수행System.out.println(inter); // [3, 4] 출력 위에서 만든 set1과 set2의 교집합을 구하는 방법이다. set1이 있던 inter에 retainAll 을 통해 set2를 교집합해주니 원본이 사라지고 교집합의 결과가 inter가 되었다. 합집합123HashSet&lt;Integer&gt; union = new HashSet&lt;&gt;(set1);union.addAll(set2); // 합집합 수행System.out.println(union); // [1, 2, 3, 4, 5, 6] 출력 합집합을 구하는 방법. set1으로 union을 만들고 addAll 의 인자로 set2를 주면 union의 원본이 사라지고 합집합의 결과가 union에 저장된다. 차집합123HashSet&lt;Integer&gt; sub = new HashSet&lt;&gt;(set1);sub.removeAll(set2); // 차집합 수행System.out.println(sub); // [1, 2] 출력 차집합을 구하는 방법. set1 으로만든 sub에 removeAll 의 인자로 set2를 주면 sub의 원본이 사라지고 sub와 set2의 차집합의 결과가 sub에 저장된다. 집합 자료형 관련 메소드 값 추가하기(add)집합 자료형에 값을 추가할 때 add 메소드를 사용한다. 1234567891011import java.util.HashSet;public class SetExample { public static void main(String[] args) { HashSet&lt;String&gt; addSet = new HashSet&lt;&gt;(); addSet.add(&quot;마우스&quot;); addSet.add(&quot;키보드&quot;); addSet.add(&quot;스피커&quot;); System.out.println(addSet); // [스피커, 키보드, 마우스] 출력 }} 값 여러개 추가하기(addAll)여러개의 값을 한꺼번에 추가 할 때 addAll 메소드를 사용한다. 1234567891011import java.util.Arrays;import java.util.HashSet;public class SetExample { public static void main(String[] args) { HashSet&lt;String&gt; addAllSet = new HashSet&lt;&gt;(); addAllSet.add(&quot;마우스&quot;); addAllSet.addAll(Arrays.asList(&quot;마이크&quot;, &quot;모니터&quot;)); System.out.println(addAllSet); // [마이크, 모니터, 마우스] 출력 }} 합집합을 구할때의 addAll 사용법과 같다. 특정 값 제거하기(remove)특정 값을 제거하고 싶을 때는 다음과 같이 remove 메소드를 사용한다. 12345678910import java.util.Arrays;import java.util.HashSet;public class SetExample { public static void main(String[] args) { HashSet&lt;String&gt; removeSet = new HashSet&lt;&gt;(Arrays.asList(&quot;마이크&quot;, &quot;모니터&quot;, &quot;마우스&quot;)); removeSet.remove(&quot;모니터&quot;); System.out.println(removeSet); // [마이크, 마우스] 출력 }} 이 포스팅은 아래의 출처를 필사하여 작성한 포스팅입니다. Reference.점프 투 자바 3-9 집합(Set) - 박응용","link":"/2022/02/05/Java-Set/"},{"title":"깃허브 프로필 꾸미기","text":"아직까지 꾸준히 깃허브와 블로그를 통해 글을 쓰고있지만 사실 처음부터 마음에 걸렸던 것이 두 가지가 있다. 그건 블로그의 테마(현재 ICARUS)와 다른사람들에 비해 아무 손질도 안한듯한 내 깃허브 프로필인데 이 두 가지 중 오늘은 깃허브 프로필을 조금이라도 꾸며보려고 구글링을 하고 포스팅도 한다. 일단 지금 포스팅과 꾸미기를 동시에 할 예정인데 아래는 꾸미기 전의 내 프로필이다. 뭔가 있긴 있어도 재미없고 딱딱한느낌이다 리포지토리 생성 깃허브에는 숨겨진 기능이 있는데, 바로 자신의 닉네임으로 리포지토리를 만드는 것이다. 이 리포지토리는 깃허브 프로필에 README.md를 추가해 주는데 이를 통해서 프로필을 꾸밀수 있다. 이후 리포지토리 연결은 여기를 참고하면 된다. 만약 README.md가 추가되지않았다면 간단히 추가할 수 있다. (이후 git pull을 통해 로컬로 당겨와 동기화 필수) 기본적으로 만들어진 README.md의 프로필 적용모습 파일에는 주석으로 간단한 설명들이 적혀져 있고, 이젠 이 README.md를 꾸며주면 된다. Shields.io 를 통해 README에 뱃지넣기 다른사람들의 깃허브 프로필을 보면 위와같은 뱃지들이 있는것을 자주 볼수 있다. 이뻐보이는데? 나도 안 할 수 없다 프로필에 뱃지를 넣는 방법을 알아보자 README.md에 다음과 같이 코드를 작성한다. 12&lt;a href=&quot;클릭시 이동할 링크&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/뱃지내용-배경색?style=뱃지모양&amp;logo=로고이름&amp;logoColor=로고색상&quot;/&gt;&lt;/a&gt;&lt;!--단락 상단 뱃지 코드--&gt;&lt;a href=&quot;링크&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/GithubBlog-skyblue?style=flat&amp;logo=Blogger&amp;logoColor=FFFFFF&quot;/&gt;&lt;/a&gt; 각각의 설명은 다음과 같다. 뱃지내용 : 뱃지에 작성될 텍스트 배경색 : 뱃지의 배경색 등등 헥스코드사용도 가능 뱃지모양 위 사진 스타일 다섯가지 중 선택할수 있고 위에 단락 상단 예시의 경우엔 flat 을 사용했다. 사진을 보고 헷갈려서 logo=appveyor 까지 넣으면 안된다. 로고이름 Simple Icons 위 사이트에서 찾고싶은 아이콘을 검색하고 적당한 아이콘을 찾아 아이콘의 이름을 입력해주면 된다.(사진에선 Blogger) 로고색상 로고색상은 아이콘마다 색이 있긴하지만 다른색으로 바꾸어 적용할수도 있다. 색상의 적용에 대해서는 배경색 부분 참고. 더 상세한 기능은 Shields.io 사이트에서 확인 후 적용 가능하다. README에 깃허브 스탯 표시하기 위 뱃지들이 익숙하다면 아마 이것도 접해보지 않았을까 싶다. 바로 깃허브 스탯이다. 깃허브의 여러 정보를 알려주는 위젯? 같은건데 이걸 한번 설정해보자. README.md에 다음 코드를 작성한다. 1![WooJeong's GitHub stats](https://github-readme-stats.vercel.app/api?username=유저네임&amp;show_icons=true&amp;theme=radical) 유저네임 부분을 지우고 본인 깃허브 ID를 작성한다. 이렇게 감사하게도 단 두단계로 이루어져있다… 테마나 아이콘을 바꿔가며 꾸밀수도 있는데 아래 링크에서 확인 할 수 있다. github-readme-stats/README.md at master · anuraghazra/github-readme-stats REFERENCE.깃허브 프로필 꾸미기!","link":"/2022/02/12/github-profile-deco/"},{"title":"(JAVA) 자바 플랫폼 3대 구성요소 (JDK, JRE, JVM)","text":"자바, 스프링 강의를 듣거나 책을 보다보면 JDK, JRE, JVM에 대한 내용이 가끔 나온다.강의에서 나올때마다 자바의 필수요소인가보다 하며 지나쳤었지만 이번 포스팅을 통해 짚어보고 넘어가려 한다. JDK (자바 개발 키트, Java Development Kit) JDK란 자바 플랫폼의 등장 이래 지금까지 가장 널리 사용되고 있는 소프트웨어 개발 키트(SDK) - 위키백과 즉, Java로 소프트웨어를 개발할 수 있도록 여러 기능들을 제공하는 패키지이다. JDK의 구성Java로의 개발을 담당하는 패키지답게 매우 많다. 자주 들어본것만 간추려보자면 javac : 자바 컴파일러, 자바 소스파일(.java)을 바이트코드(.class)로 변환한다. java : javac가 만든 클래스 파일을 해석 및 실행한다. jar : 서로 관련있는 클래스 라이브러리들과 리소스를 하나의 파일로 묶어주는 도구이다. JDB : Java Debugger, 자바 디버깅 툴 JRE (Java Runtime Environment) : Java가 동작하는데 필요한 JVM, 라이브러리 등 다양한 파일들을 포함한다. Java를 실행시키기 위해필요하다. JVM(Java Virtual Machine) : Java가 실제로 동작하는 가상환경. JVM 덕분에 하나의 소스파일을 만들더라도 여러 환경(OS) 에서 원활히 동작이 가능하다. JDK의 종류 Java SE : Standard Edition표준 자바 플랫폼으로 표준적인 컴퓨팅 환경을 지원하기 위한 자바 가성머신 규격 및 API 집합을 포함한다.이후의 Java EE, Java ME는 구체적인 목적에 따라 Java SE를 기반으로 API를 추가하거나 자바 가상머신 규격 및 API의 일부를 택하여 정의 된다. Java EE : Enterprise EditionJava SE에 웹 어플리케이션 서버에서 동작하는 기능을 추가한 플랫폼이 스펙에 따라 제품을 구현한 것을 웹 어플리케이션 서버( WAS )라 한다.(톰캣 등) Java ME : Micro Edition제한된 자원을 가진 휴대전화, PDA 등에서 Java 프로그래밍 언어를 지원하기 위해 만든 플랫폼 중 하나이다. JRE (자바 런타임 환경, Java Runtime Environment) 컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경을 말한다.자바 프로그램을 실행시키기 위한 라이브러리, JVM, 기타 파일들을 포함하고있다.자바 프로그램을 실행시키기 위해서는 JRE를 반드시 설치해야하고 JRE에는 개발과 관련된 도구는 포함되어 있지 않다. JVM (자바 가상 머신, Java Virtual Machine) JVM은 Java Virtual Machine(자바 가상머신)의 약자로 자바 소스코드로 만들어지는 자바 바이트코드 파일을 실행할 수 있다.JVM은 자바와 다르게 플랫폼에 의존적므로 맥, 윈도우, 리눅스의 JVM은 각각 다르다.하지만 컴파일된 바이트코드 파일은 어떤 JVM에서도 동작시킬 수 있다. 즉, 코드를 작성하면 JVM이 설치된 어떤 플랫폼에서도 동작시킬수 있다. JVM의 역할은 다음과 같다. 바이트코드를 읽는다. 바이트코드를 검증한다. 바이트코드를 실행한다. 실행환경(Runtime Environment)의 규격을 제공한다. (필요한 라이브러리 및 기타파일) 마지막으로 각각의 관계를 살펴보면 다음 그림과 같다. Reference.자바 개발키트 위키백과[Java] Java SE, JDK, JRE","link":"/2022/02/14/Java-JDK-JRE-JVM/"},{"title":"(JAVA) 제네릭(generic)","text":"요즘 쓰는 포스팅의 주제는 항상 듣고있는 강의에서 나온다. 강의에서는 제네릭을 직접 언급하지는 않았지만 List 자료형이나 Map 자료형들을 사용할때 제네릭 &lt;&gt; 을 사용한다. 제네릭을 알고는 있었지만 모양만 알고있었을뿐 용법과, 사용처에대해서는 몰랐기에 포스팅 작성을 통해 알아보려 한다. 제네릭(generic) 이란 ? 자바에서 제네릭이란 데이터의 타입(data type)을 일반화한다(generalize)는 것을 의미한다고 한다. …. 여전히 모호하다. 그래서 다른 글을 읽어본 결과 클래스 / 인터페이스 / 메소드 에서 사용할 매개변수의 타입을 클래스 외부에서 설정하는 것 이라고 한다. 그렇다면 제네릭을 사용하는 이유는 무엇일까 제네릭을 사용하는 이유제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있기 때문이다. 자바 컴파일러는 코드에서 잘못 사용된 타입 때문에 발생하는 문제점을 제거하기 위해 제네릭코드에 대해 강한 타입 체크를 한다. 실행시 에러가 나는 것보다 컴파일 시 미리 강하게 체크하여 에러를 사전방지하는게 더 좋기 때문. 또 제네릭 코드를 사용하면 타입을 국한하기 때문에 요소를 찾아올 때 타입 변환을 할 필요가 없어 프로그램 성능이 향상된다. 강한 타입체크를 하여 에러를 사전방지하기 위함 타입 변환을 할 필요가 없게 타입을 국한하여 프로그램 성능 향상을 위함 제네릭의 사용 제네릭 타입은 타입을 매개변수로 갖는 클래스와 인터페이스를 말한다. 제네릭 타입은 클래스 또는 인터페이스 이름 뒤에 &lt;&gt; 부호가 붙으며 사이에 타입 파라미터가 위치한다. 12public class 클래스명&lt;T&gt; {}public interface 인터페이스명&lt;T&gt; {} 타입 파라미터는 정해진 규칙은 없으며, 일반적으로 대문자 알파벳 한글자로 표현한다. 자주 사용하는 타입 파라미터 타입 파라미터 뜻 &lt;T&gt; Type &lt;E&gt; Element &lt;K&gt; Key &lt;N&gt; Number &lt;V&gt; Value &lt;R&gt; Result 제네릭의 사용 예시12345678910111213141516public class exam&lt;T&gt; { List&lt;T&gt; examList = new ArrayList&lt;&gt;(); public void method1(T input) { examList.add(input); }}class GenericClass { public static void main(String[] args) { exam&lt;String&gt; stringExam = new exam&lt;&gt;(); exam&lt;Integer&gt; integerExam = new exam&lt;&gt;(); }} exam 클래스는 로 제네릭이 설정되어 있고 내부의 List타입의 examList 객체도 로 제네릭 설정이 되어있다. GenericClass 클래스는 두 개의 객체 stringExam과 intergerExam 이 있으며 두 객체의 타입은 exam 타입이다. exam 타입은 선언부에 제네릭이 설정되어있으니 사용하는 쪽에서도 제네릭 타입을 명시 해줘야 한다. 이 코드에서는 각각 과 로 설정해주었다. 이제 stringExam객체는 타입이 String인 데이터만, integerExam객체는 타입이 int 인 데이터만 사용할 수 있다. 정말 그런지 확인을 해 보면 stringExam.method1의 매개변수로 문자열을 주었을때는 컴파일에러가 발생하지 않다가 문자열만 들어가야하는 List에 정수를 매개변수로 주니 컴파일 에러가 발생한다. 반대의 경우도 마찬가지. 이와같이 제네릭을 사용할 경우 클래스 내부에서 사용하는 데이터의 타입을 지정할 수 있으며, 타입을 잘못 사용하여 발생하는 에러를 최소화 할 수 있다. 이는 회원가입폼의 ID란에서 특수문자를 사용하지 못하게 예외처리를 하는것과 비슷하다. 제네릭에 사용 가능한 타입 데이터 타입의 종류여기서 간단히 데이터 타입의 종류와 특징을 알아보면 기본형 타입 참조형 타입 종류 - 정수형 : byte, short, int, long - 실수형 : float, double - 문자형 : char - 논리 타입 : boolean 기본형 이외의 모든 형태 - 배열(array[]) - 열거(enum) - 클래스(class) - 인터페이스(interface) 특징 - 직접 값을 넣을 수 있음 - 스택 영역에 저장 - 값들을 저장하고 있는 객체를 가르키는 ‘주소’를 넣을 수 있음 - 힙 영역에 저장 그렇다면 제네릭에는 어떤 타입을 설정할수 있을까? 제네릭의 타입으로는 참조형 데이터 타입만 설정 가능하다. int, byte, double, char 같은 기본형 데이터 타입은 설정할 수 없다. ????? 분명 우리는 위 코드에서 정수형데이터로 Integer가 입력이 되는것을 보았다. Integer와 같은 형태를 래퍼클래스(wrapper class) 라고 한다. 래퍼클래스는 기본형 데이터 타입을 참조형 데이터 타입으로 바꿔주는 클래스다. 위 코드에서는 기본형인 int 가 아닌 래퍼클래스인 Integer를 사용함으로써 설정이 가능했던 것이다. Reference.제네릭(Generic) 사용법 &amp; 예제 총정리 - 코딩팩토리 제네릭의 개념 - TCP SCHOOL.com Java 제네릭(Generic) 이란?? - 비실이의 개발 성장기","link":"/2022/02/17/Java-generic/"},{"title":"(JAVA) BufferedReader와 BufferedWriter를 통한 입출력","text":"백준의 자바 알고리즘 문제를 풀어보던 중 버퍼를 활용한 입출력을 사용해야 하나는 문제가 있었다. 나는 자바에서 입출력이라고는 Scanner와 println()밖에 몰랐기에 버퍼를 통한 입출력은 사용해본적이 없었다. 찾아보니 버퍼 입출력이 스캐너보다 효율면에서 훨씬 낫다는것을 알게되었고, 그로인해 작업속도차이가 많이 난다는것도 알게되었다. 그래서! 이번 포스팅의 목표는 버퍼를 활용한 입출력에대해 알아보고 활용할 수 있을 정도로 공부하는게 목적이다. Buffer BufferedReader / BufferedWriter는 Buffer에 있는 IO 클래스이다. 스캐너와 다르게 입력된 데이터가 바로 전달되지않고 중간에 버퍼링이 된 후에 전달된다. 출력도 마찬가지로 버퍼를 거쳐 간접적으로 출력장치로 전달되고, 시스템의 데이터 처리 효율성을 높여주며 버퍼스트림을 InputStreamReader / OutputStreamWriter 을 함께 사용하여 버퍼링을 하게 되면 입출력 스트림으로부터 미리 버퍼에 데이터를 갖다 놓기 때문에 보다 효율적인 입출력이 가능하다. BufferedReader 123BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); // 객체 생성Stirng s = bf.readLine(); // 문자열의 경우int i = Integer.parseInt(bf.readLine()); // 정수의 경우 객체 생성은 1라인에서 bf 라는 이름만 마음대로 바꾸면 된다. 입력은 문자열과 숫자가 받는 방식이 좀 다른데 readLine() 메소드의 결과가 문자열이기때문에 정수형 변수에 저장할 경우 Integer 로 형변환을 해주어야 한다. 주의할 점이 있다면 예외처리를 꼭 해주어야 한다는 점인데 보통은 throws IOException 을 통해 해결한다. 이렇게 하면 버퍼를 통해 읽어들인 문자열 or 숫자를 변수에 저장한 것이다. StringTokenizer 읽어들인 데이터는 Line 단위로만 나뉘어지기 때문에 공백단위로 데이터를 가공하려면 따로 작업을 해줘야 한다. 123456String s = &quot;123 456&quot;;StringTokenizer st = new StringTokenizer(s); // 객체생성 및 s를 st의 인자로 전달 String a = st.nextToken(); // 공백으로 나뉘어진 s의 123이 문자열로 a에 저장int b = Integer.parseInt(st.nextToken()); // s의 456이 숫자로 b에 저장String array[] = s.split(&quot; &quot;); // 공백마다 데이터를 끊어 배열에 저장함 위 코드에서 보이듯 StringTokenizer에 nextToken()함수를 사용하면 readLine()을 통해 입력받은 값을 공백단위로 구분하여 순서대로 호출할 수 있다. 다음으로는 String.split()함수가 있는데 문자열을 공백단위로 끊어 배열에 저장하는 방식이다. BufferdedWriter 일반적으로 문자를 출력할때에 System.out.println();을 사용한다. 크지않은 양의 출력일 경우 성능차이는 체감하지 못할 수 있지만 출력이 많아진다면 입력과 마찬가지로 버퍼를 활용하는것이 효율적이다. 123456BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); // 객체생성String s = &quot;12345&quot;; // 출력할 문자열bw.write(s); // 버퍼에 &quot;12345&quot;가 담긴 s 문자열을 올린다.bw.newLine(); // 줄바꿈bw.flush(); // 버퍼에 있는 데이터를 모두 출력시킴bw.close(); // 스트림을 닫음 BufferedWriter의 경우 버퍼를 잡아 놓았기 때문에 반드시 flush() / close() 를 반드시 호출하여 버퍼를 비우고 닫아주어야 한다. 또한, bw.write에는 System.out.println();과 같이 자동개행기능이 없기때문에 개행을 해주어야 할 경우에는 \\n을 통해 따로 처리해주어야 한다. 사용 예제 백준에 있는 문제를 풀어보자. 12345678910111213public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int x = Integer.parseInt(bf.readLine()); for (int i = 0; i &lt; x; i++) { StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;); bw.write((Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken())+ &quot;\\n&quot;); } bw.flush(); bw.close();} 라인 1 : throws IOException을 통해 버퍼 사용에 필요한 예외처리를 해줌 라인 2,3 : 버퍼 입출력 객체 생성 라인 5 : 정수형 변수에 반복횟수 지정을 위해 readLine()함수로 입력을 받고 정수형으로 형변환 라인 8 : st변수명으로 StringTokenizer 객체 생성과 동시에 입력을 공백으로 나누어 받음 라인 9 : 버퍼에 라인 8에서 입력된 나눠진 문자열을 첫번째와 두번째 것만 정수로 변환한 뒤 더하고 그 값을 버퍼에 올린다. 이후 \\n으로 버퍼내부에서 개행 라인 11 : 반복문을 통해 버퍼에 작성된 데이터를 모두 출력한다. 라인 12 : 스트림을 닫는다. 스캐너보다는 다소 복잡하다. 그래도 속도면에서 확실한 이점이 있다고 하니 버퍼 사용에 익숙해지는것이 좋을 것 같다. Reference.[Java] BufferedReader, BufferedWriter를 활용한 빠른 입출력 - 코딩팩토리","link":"/2022/02/19/Java-Buffer/"},{"title":"(ORACLE) NULL값을 치환하는 NVL, NVL2 함수","text":"SQL을 사용하다 보면 NULL을 다른 결과로 치환하여 출력하는 문제가 가끔 나온다. 오라클에서는 이를 NVL 함수로 간단히 처리 가능한데 문제가 있다면 이 쿼리를 다른 DBMS에서 사용할 때 이다. ORACLE : NVL MYSQL : IFNULL MSSQL : ISNULL 세 개의 DBMS 모두 사용하는 함수가 다른데 그렇기 때문에 서로 호환이 안된다. NVL 함수의 사용법12345-- 기본형NVL(컬럼, NULL일 경우의 반환값)NVL(컬럼, '') -- 컬럼의 값이 NULL일 경우 ''으로 치환함NVL(컬럼, 0) -- 컬럼의 값이 NULL일 경우 0으로 치환함 예제123-- NAME 컬럼의 값이 NULL 일 경우 'No name'으로 치환SELECT NVL(NAME, 'No name')FROM ANIMAL_INS; NVL2 함수의 사용법기본적으로 NVL함수와 비슷하나 NULL값이 아닐때도 치환을 해준다 12345-- 기본형NVL2(컬럼, NULL이 아닐경우의 반환값, NULL일 경우의 반환값)NVL2(컬럼, '학생', '교사')NVL2(컬럼, '대중교통', '자동차') 예제123-- DATETIME 컬럼의 값이 NULL 일경우 '정규직' NULL이 아닐경우 '계약직'SELECT NVL(DATETIME, '계약직', '정규직')FROM EMPLOYEE;","link":"/2022/02/23/Oracle-NVL/"},{"title":"(JAVA) BufferedWriter.write() 의 출력 타입","text":"버퍼를 요 며칠간 써보고 있지만 아직 스캐너를 쓸 때에 비해서는 익숙치 않다. 그러던 중 백준의 알고리즘 문제를 풀면서 BufferedWriter.write() 함수를 사용할 때 마다 숫자가 아스키코드로 출력되어 문제가 되었다. 문제예시를 한번 보자면 12345678910111213141516public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int x = Integer.parseInt(bf.readLine()); for (int i = x; i &gt; 0; i--) { bw.write(i); bw.newLine(); } bw.flush(); bw.close(); }} 숫자를 입력하면 그 숫자부터 1까지 -1되며 출력되는 매우 간단한 코드이다. 그런데 실행하면 다음과 같이 출력된다. 분명 5를 입력했으니 5부터 1까지 차례로 출력되어야 하지만 글자가 깨져 출력되고있다. 이는 숫자 자체가 아닌 5에서 1까지 해당하는 아스키코드가 대응하여 출력되었기 때문이다. 아스키코드에서 ! 인 33을 입력하면 !와 32인 공백문자가 출력되는걸 볼 수 있다. 원인원인은 bw.write(i) 부분에서 정수 타입인 i를 그대로 출력하려고 했기 때문이다. 해결정수형을 그대로 출력하려고 했을때 문제가 발생했기에 형변환을 해주어야 한다. 따라서 정수 타입 변수를 버퍼를 통해 출력하고 싶으면 문자열로의 형변환이 필요하다. 12345678910111213141516public class Main { public static void main(String[] args) throws IOException { BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int x = Integer.parseInt(bf.readLine()); for (int i = x; i &gt; 0; i--) { bw.write(String.valueOf(i)); bw.newLine(); } bw.flush(); bw.close(); }} bw.write(i) 처럼 정수형으로 바로 출력하는 대신 bw.write(String.valueOf(i)) 처럼 문자열로 형변환하면 다음처럼 출력이된다.","link":"/2022/02/24/Java-BufferedWriter-output/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"pandas","slug":"pandas","link":"/tags/pandas/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Install","slug":"Install","link":"/tags/Install/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/tags/Data-Visualization/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Decision Tree","slug":"Decision-Tree","link":"/tags/Decision-Tree/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"Kaggle","slug":"Kaggle","link":"/tags/Kaggle/"},{"name":"Function","slug":"Function","link":"/tags/Function/"},{"name":"Grammar","slug":"Grammar","link":"/tags/Grammar/"},{"name":"Plotly","slug":"Plotly","link":"/tags/Plotly/"},{"name":"Repository","slug":"Repository","link":"/tags/Repository/"},{"name":"Link","slug":"Link","link":"/tags/Link/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Decorator","slug":"Decorator","link":"/tags/Decorator/"},{"name":"Context manager","slug":"Context-manager","link":"/tags/Context-manager/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"branch","slug":"branch","link":"/tags/branch/"},{"name":"version","slug":"version","link":"/tags/version/"},{"name":"Callback","slug":"Callback","link":"/tags/Callback/"},{"name":"checkout","slug":"checkout","link":"/tags/checkout/"},{"name":"Crawling","slug":"Crawling","link":"/tags/Crawling/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","link":"/tags/BeautifulSoup/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"deploy","slug":"deploy","link":"/tags/deploy/"},{"name":"stub","slug":"stub","link":"/tags/stub/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"PyCharm","slug":"PyCharm","link":"/tags/PyCharm/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"PostgresSQL","slug":"PostgresSQL","link":"/tags/PostgresSQL/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"query","slug":"query","link":"/tags/query/"},{"name":"Setting","slug":"Setting","link":"/tags/Setting/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/tags/PostgreSQL/"},{"name":"Data","slug":"Data","link":"/tags/Data/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"Overloading","slug":"Overloading","link":"/tags/Overloading/"},{"name":"Overriding","slug":"Overriding","link":"/tags/Overriding/"},{"name":"Set","slug":"Set","link":"/tags/Set/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"JRE","slug":"JRE","link":"/tags/JRE/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Generic","slug":"Generic","link":"/tags/Generic/"},{"name":"Buffer","slug":"Buffer","link":"/tags/Buffer/"},{"name":"BufferedReader","slug":"BufferedReader","link":"/tags/BufferedReader/"},{"name":"BufferedWriter","slug":"BufferedWriter","link":"/tags/BufferedWriter/"},{"name":"ORACLE","slug":"ORACLE","link":"/tags/ORACLE/"},{"name":"FUNCTION","slug":"FUNCTION","link":"/tags/FUNCTION/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"pandas","slug":"pandas","link":"/categories/pandas/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Data Visualization","slug":"Data-Visualization","link":"/categories/Data-Visualization/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"deploy","slug":"deploy","link":"/categories/deploy/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"DB","slug":"DB","link":"/categories/DB/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"PostgreSQL","slug":"PostgreSQL","link":"/categories/PostgreSQL/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"ORACLE","slug":"ORACLE","link":"/categories/ORACLE/"}]}